// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "sqlite"
}

model User {
  id            String   @id @default(uuid())
  name          String
  email         String   @unique
  emailVerified Boolean  @default(false)
  image         String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  sessions           Session[]
  accounts           Account[]
  profile            UserProfile?
  dna                UserDNA?
  teamMembers        TeamMember[]
  userStrengths      UserStrength[]
  reports            Report[]
  assessmentSessions AssessmentSession[]
  assessmentAnswers  UserAssessmentAnswer[]

  // Peer Feedback relations
  requestedFeedback   FeedbackRequest[]    @relation("RequestedFeedback")
  receivedFeedback    FeedbackRequest[]    @relation("ReceivedFeedback")
  feedbackSummary     FeedbackSummary?
  strengthAdjustments StrengthAdjustment[]

  // Sub-Team relations
  createdSubTeams SubTeam[] @relation("SubTeamCreator")

  // Gamification & Development relations
  gamification        UserGamification?
  xpTransactions      XpTransaction[]
  moduleProgress      UserModuleProgress[]
  challengeProgress   UserChallengeProgress[]
  recommendations     UserRecommendation[]
  initiatedChallenges CollaborativeChallenge[] @relation("InitiatorChallenges")
  partnerChallenges   CollaborativeChallenge[] @relation("PartnerChallenges")

  // Development Refactor - New Relations
  professionalProfile UserProfessionalProfile?
  personalizedModules DevelopmentModule[]      @relation("PersonalizedModules")

  @@index([email])
}

model Session {
  id        String   @id @default(uuid())
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Account {
  id                    String    @id @default(uuid())
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerId, accountId])
  @@index([userId])
}

model Verification {
  id         String   @id @default(uuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([identifier, value])
}

// Extended user profile information
model UserProfile {
  id              String   @id @default(uuid())
  userId          String   @unique
  career          String?
  age             Int?
  gender          String? // 'M', 'F', 'O'
  description     String?
  hobbies         String? // JSON array stored as string
  profileImageUrl String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// User DNA generated from strengths
model UserDNA {
  id         String   @id @default(uuid())
  userId     String   @unique
  title      String
  summary    String
  dimensions String // JSON array stored as string
  synergies  String // JSON array stored as string
  idealRole  String // JSON array stored as string
  purpose    String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// Teams
model Team {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  members  TeamMember[]
  reports  Report[]
  subTeams SubTeam[]    @relation("TeamSubTeams")

  @@index([name])
}

// Team membership (many-to-many relationship)
model TeamMember {
  id        String   @id @default(uuid())
  userId    String
  teamId    String
  role      String? // Optional role within the team
  joinedAt  DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([userId, teamId])
  @@index([userId])
  @@index([teamId])
}

// Strength domains (Doing, Feeling, Motivating, Thinking)
model Domain {
  id                 String   @id @default(uuid())
  name               String   @unique // "Doing", "Feeling", "Motivating", "Thinking"
  nameEs             String // Spanish name
  description        String
  metaphor           String
  keyQuestion        String
  summary            String
  contributionToTeam String // JSON array stored as string
  potentialPitfall   String
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  strengths           Strength[]
  domainFocuses       DomainFocus[]
  assessmentQuestions AssessmentQuestion[]

  @@index([name])
}

// Strengths catalog
model Strength {
  id                      String   @id @default(uuid())
  name                    String   @unique // English name (e.g., "Deliverer")
  nameEs                  String // Spanish name (e.g., "Cumplidor")
  domainId                String
  briefDefinition         String
  fullDefinition          String
  howToUseMoreEffectively String? // JSON array stored as string
  watchOuts               String? // JSON array stored as string
  strengthsDynamics       String?
  bestPartners            String? // JSON array stored as string
  careerApplications      String? // JSON array stored as string
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  domain              Domain               @relation(fields: [domainId], references: [id], onDelete: Cascade)
  userStrengths       UserStrength[]
  assessmentQuestions AssessmentQuestion[]
  strengthAdjustments StrengthAdjustment[]

  @@index([domainId])
  @@index([name])
}

// User's selected strengths (many-to-many, limited to 5 per user)
model UserStrength {
  id         String   @id @default(uuid())
  userId     String
  strengthId String
  rank       Int // 1-5, representing the order of importance
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  strength Strength @relation(fields: [strengthId], references: [id], onDelete: Cascade)

  @@unique([userId, strengthId])
  @@unique([userId, rank])
  @@index([userId])
  @@index([strengthId])
}

// Focus axes for culture calculation
// Represents the two axes: Energy (Action/Reflection) and Orientation (Results/People)
model Focus {
  id          String   @id @default(uuid())
  name        String   @unique // "Action", "Reflection", "Results", "People"
  nameEs      String // Spanish name
  axis        String // "energy" or "orientation"
  description String
  icon        String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations to domains that contribute to this focus
  domainFocuses           DomainFocus[]
  // Relations to cultures
  cultureFocusEnergy      Culture[]     @relation("CultureEnergy")
  cultureFocusOrientation Culture[]     @relation("CultureOrientation")

  @@index([name])
  @@index([axis])
}

// Many-to-many relationship between Domain and Focus
// Each domain contributes to exactly 2 focuses (one per axis)
model DomainFocus {
  id        String   @id @default(uuid())
  domainId  String
  focusId   String
  weight    Float    @default(1.0) // Weight of contribution (for future fine-tuning)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  domain Domain @relation(fields: [domainId], references: [id], onDelete: Cascade)
  focus  Focus  @relation(fields: [focusId], references: [id], onDelete: Cascade)

  @@unique([domainId, focusId])
  @@index([domainId])
  @@index([focusId])
}

// Team Cultures that emerge from domain combinations
model Culture {
  id                 String   @id @default(uuid())
  name               String   @unique // "Execution", "Influence", "Strategy", "Cohesion"
  nameEs             String // Spanish name
  subtitle           String // Short metaphor
  description        String // Full description
  focusEnergyId      String // Action or Reflection
  focusOrientationId String // Results or People
  attributes         String // JSON array of key attributes
  icon               String?
  color              String // For UI theming
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  focusEnergy      Focus @relation("CultureEnergy", fields: [focusEnergyId], references: [id])
  focusOrientation Focus @relation("CultureOrientation", fields: [focusOrientationId], references: [id])

  @@unique([focusEnergyId, focusOrientationId])
  @@index([name])
}

// ============================================================
// AI-Generated Reports
// ============================================================

enum ReportType {
  // Individual Reports
  INDIVIDUAL_FULL // Full personal report with all sections
  INDIVIDUAL_STRENGTHS // Core strengths report
  INDIVIDUAL_DEVELOPMENT // Development opportunities
  INDIVIDUAL_RELATIONSHIPS // Strengths and relationships

  // Team Reports
  TEAM_CULTURE // Team culture map analysis
  TEAM_STRENGTHS_DISTRIBUTION // Strengths distribution across team
  TEAM_DOMAIN_COVERAGE // Domain coverage analysis
  TEAM_FULL // Full team assessment
  TEAM_TIPS // Team relationship tips and book recommendations
}

enum ReportStatus {
  PENDING // Report requested but not started
  GENERATING // AI is generating the report
  COMPLETED // Report generated successfully
  FAILED // Report generation failed
}

model Report {
  id        String       @id @default(uuid())
  type      ReportType
  status    ReportStatus @default(PENDING)
  version   Int          @default(1) // Track changes over time
  content   String? // JSON serialized report content
  error     String? // Error message if failed
  modelUsed String? // AI model used for generation
  metadata  String? // JSON with generation metadata (tokens, duration, etc.)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  // Relations - one of these will be set based on report type
  userId String?
  teamId String?

  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)
  team Team? @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([type, userId, teamId]) // Prevent duplicate reports per user/team combination (covers both individual and team reports)
  @@index([userId])
  @@index([teamId])
  @@index([type])
  @@index([status])
}

// ============================================================
// Assessment System
// ============================================================

enum QuestionType {
  SCALE // 1-5 Likert scale
  CHOICE // Single select from options
  RANKING // Order multiple items by preference
}

enum SessionStatus {
  IN_PROGRESS // User is actively taking the assessment
  COMPLETED // Assessment finished successfully
  ABANDONED // Inactive for 30+ days or user started new session
}

// Assessment questions organized by phase
model AssessmentQuestion {
  id         String       @id @default(uuid())
  phase      Int // 1 (Domain Discovery), 2 (Strength Refinement), 3 (Ranking Confirmation)
  order      Int // Display order within phase
  text       String // Question text
  type       QuestionType
  options    String? // JSON array for choice/ranking questions
  scaleRange String? // JSON object with min, max, labels for scale questions
  domainId   String // Primary domain this question measures
  strengthId String? // Optional specific strength for Phase 2/3 questions
  weight     Float        @default(1.0) // Importance weight for scoring (0.1-2.0)
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt

  domain   Domain                 @relation(fields: [domainId], references: [id], onDelete: Cascade)
  strength Strength?              @relation(fields: [strengthId], references: [id], onDelete: SetNull)
  answers  UserAssessmentAnswer[]

  @@unique([phase, order]) // Ensure unique ordering within each phase
  @@index([phase])
  @@index([domainId])
  @@index([strengthId])
}

// User's answers to assessment questions
model UserAssessmentAnswer {
  id         String   @id @default(uuid())
  userId     String
  sessionId  String
  questionId String
  answer     String // JSON: number for scale, string for choice, string[] for ranking
  confidence Int? // Self-reported confidence (1-5), optional
  answeredAt DateTime @default(now())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user     User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  session  AssessmentSession  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  question AssessmentQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([sessionId, questionId]) // One answer per question per session
  @@index([userId])
  @@index([sessionId])
  @@index([questionId])
}

// Assessment session tracking
model AssessmentSession {
  id             String        @id @default(uuid())
  userId         String
  status         SessionStatus @default(IN_PROGRESS)
  phase          Int           @default(1) // Current phase: 1, 2, or 3
  currentStep    Int           @default(1) // Current question number in overall flow
  totalSteps     Int           @default(60) // Total questions (20+30+10)
  domainScores   String? // JSON: Record<domainId, score> - calculated after Phase 1
  strengthScores String? // JSON: Record<strengthId, score> - calculated after Phase 2
  results        String? // JSON: AssessmentResults - final calculated results
  startedAt      DateTime      @default(now())
  lastActivityAt DateTime      @default(now())
  completedAt    DateTime?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  user    User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  answers UserAssessmentAnswer[]

  @@index([userId, status])
  @@index([lastActivityAt]) // For cleanup job
}

// ============================================================
// Peer Feedback System
// ============================================================

enum FeedbackRequestStatus {
  PENDING // Request sent, awaiting response
  COMPLETED // Respondent completed the feedback
  DECLINED // Respondent declined to provide feedback
  EXPIRED // Request expired after 14 days
}

// Feedback request from one user to another
model FeedbackRequest {
  id           String                @id @default(uuid())
  requesterId  String // User requesting feedback
  respondentId String // User providing feedback
  status       FeedbackRequestStatus @default(PENDING)
  isAnonymous  Boolean               @default(true)
  sentAt       DateTime              @default(now())
  completedAt  DateTime?
  expiresAt    DateTime // sentAt + 14 days
  createdAt    DateTime              @default(now())
  updatedAt    DateTime              @updatedAt

  requester  User               @relation("RequestedFeedback", fields: [requesterId], references: [id], onDelete: Cascade)
  respondent User               @relation("ReceivedFeedback", fields: [respondentId], references: [id], onDelete: Cascade)
  responses  FeedbackResponse[]

  @@unique([requesterId, respondentId, sentAt]) // Prevent duplicate requests at same time
  @@index([respondentId, status]) // Query pending requests for a user
  @@index([requesterId]) // Query sent requests by a user
  @@index([expiresAt]) // Cleanup expired requests
  @@index([status])
}

// Behavioral questions for peer feedback (5 questions total)
model FeedbackQuestion {
  id              String   @id @default(uuid())
  text            String // Question text
  answerType      String // "scale" | "behavioral_choice"
  answerOptions   String // JSON: array of answer options
  strengthMapping String // JSON: { "optionId": { "strengthId": weight } }
  order           Int      @unique // Display order (1-5)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  responses FeedbackResponse[]

  @@index([order])
}

// Individual response to a feedback question
model FeedbackResponse {
  id            String   @id @default(uuid())
  requestId     String
  questionId    String
  answer        String // JSON: selected option(s)
  anonymousHash String? // One-way hash for anonymous responses (prevents duplicates)
  createdAt     DateTime @default(now())

  request  FeedbackRequest  @relation(fields: [requestId], references: [id], onDelete: Cascade)
  question FeedbackQuestion @relation(fields: [questionId], references: [id])

  @@unique([requestId, questionId]) // One answer per question per request
  @@index([requestId]) // Query all responses for a request
  @@index([anonymousHash]) // Duplicate detection
}

// Aggregated feedback insights for a user
model FeedbackSummary {
  id                  String    @id @default(uuid())
  userId              String    @unique
  totalResponses      Int       @default(0)
  lastResponseAt      DateTime?
  strengthAdjustments String // JSON: { "strengthId": { "delta": number, "confidence": number } }
  insights            String? // AI-generated summary text
  insightsGeneratedAt DateTime?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([lastResponseAt]) // Track recent feedback activity
}

enum StrengthAdjustmentStatus {
  PENDING // Suggested but not acted upon
  ACCEPTED // User accepted the adjustment
  REJECTED // User rejected the adjustment
}

// Proposed strength profile adjustments based on peer feedback
model StrengthAdjustment {
  id             String                   @id @default(uuid())
  userId         String
  strengthId     String
  suggestedDelta Float // -1.0 to +1.0 confidence adjustment
  supportingData String // JSON: evidence from feedback
  status         StrengthAdjustmentStatus @default(PENDING)
  createdAt      DateTime                 @default(now())
  processedAt    DateTime?

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  strength Strength @relation(fields: [strengthId], references: [id])

  @@unique([userId, strengthId, createdAt]) // One suggestion per strength per cycle
  @@index([userId, status]) // Query pending adjustments
  @@index([strengthId])
}

// ============================================================
// Sub-Team Builder System
// ============================================================

// Virtual team composed of members from a parent team
model SubTeam {
  id                   String    @id @default(uuid())
  parentTeamId         String
  projectTypeProfileId String
  name                 String
  description          String?
  members              String // JSON: array of userIds
  matchScore           Float? // 0-100, calculated
  analysis             String? // JSON: detailed match breakdown
  status               String    @default("active") // "active" | "archived"
  createdBy            String
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  deletedAt            DateTime? // Soft delete

  parentTeam         Team               @relation("TeamSubTeams", fields: [parentTeamId], references: [id], onDelete: Cascade)
  projectTypeProfile ProjectTypeProfile @relation("ProjectType", fields: [projectTypeProfileId], references: [id])
  creator            User               @relation("SubTeamCreator", fields: [createdBy], references: [id])

  @@index([parentTeamId, deletedAt])
  @@index([createdBy])
  @@index([projectTypeProfileId])
  @@index([status])
}

// Project type profiles for different project characteristics
model ProjectTypeProfile {
  id                String   @id @default(uuid())
  type              String   @unique // "innovation" | "execution" | "crisis" | "growth"
  name              String
  nameEs            String
  idealStrengths    String // JSON: array of strength names
  criticalDomains   String // JSON: domain weights
  cultureFit        String // JSON: culture preferences
  description       String
  descriptionEs     String
  characteristics   String? // JSON: array of characteristics
  characteristicsEs String? // JSON: array of Spanish characteristics
  icon              String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  subTeams SubTeam[] @relation("ProjectType")

  @@index([type])
}

// =============================================================================
// GAMIFICATION & DEVELOPMENT MODULES (Feature 004-strength-pathways)
// =============================================================================

// User gamification profile - XP, levels, streaks, and statistics
model UserGamification {
  id                      String    @id @default(uuid())
  userId                  String    @unique
  xpTotal                 Int       @default(0)
  currentLevel            Int       @default(1)
  currentLevelXp          Int       @default(0)
  nextLevelXpRequired     Int       @default(500)
  longestStreak           Int       @default(0)
  currentStreak           Int       @default(0)
  lastActivityDate        DateTime?
  modulesCompleted        Int       @default(0)
  challengesCompleted     Int       @default(0)
  collaborativeChallenges Int       @default(0)
  createdAt               DateTime  @default(now())
  updatedAt               DateTime  @updatedAt

  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  badges         UserBadge[]
  xpTransactions XpTransaction[]

  @@index([userId])
  @@index([xpTotal])
  @@index([currentLevel])
}

// XP transaction log - ensures idempotency and provides audit trail
model XpTransaction {
  id          String   @id @default(uuid())
  userId      String
  amount      Int
  source      String // "feedback_given", "feedback_insights", "assessment_completed", "module_completed", "challenge_completed"
  sourceId    String // FeedbackRequest.id, FeedbackSummary.id, AssessmentSession.id, DevelopmentModule.id, Challenge.id
  streakBonus Float?
  metadata    String? // JSON for additional context (e.g., { "respondentName": "John", "requestedBy": "Jane" })
  createdAt   DateTime @default(now())

  user         User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  gamification UserGamification? @relation(fields: [userId], references: [userId])

  @@unique([userId, source, sourceId]) // Idempotency guarantee - each action can only award XP once
  @@index([userId, createdAt])
  @@index([source])
  @@index([sourceId])
}

// Badge catalog - achievements that can be unlocked
model Badge {
  id             String   @id @default(uuid())
  key            String   @unique
  nameEs         String
  descriptionEs  String
  iconUrl        String
  tier           String // "bronze", "silver", "gold", "platinum"
  unlockCriteria String // JSON: { type: "xp" | "modules" | "challenges" | "streak" | "collaborative", threshold: number }
  xpReward       Int      @default(0)
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  userBadges UserBadge[]

  @@index([key])
  @@index([tier])
}

// User's unlocked badges - many-to-many relationship
model UserBadge {
  id             String   @id @default(uuid())
  gamificationId String
  badgeId        String
  unlockedAt     DateTime @default(now())

  gamification UserGamification @relation(fields: [gamificationId], references: [id], onDelete: Cascade)
  badge        Badge            @relation(fields: [badgeId], references: [id], onDelete: Cascade)

  @@unique([gamificationId, badgeId])
  @@index([gamificationId])
  @@index([badgeId])
}

// User professional profile for personalized module generation
model UserProfessionalProfile {
  id              String    @id @default(uuid())
  userId          String    @unique
  roleStatus      String    @default("neutral") // "satisfied" | "partially_satisfied" | "unsatisfied" | "neutral"
  currentRole     String? // User's current job title/role
  industryContext String? // Industry/sector context
  careerGoals     String? // JSON array of goal strings
  completedAt     DateTime? // When user finished the questionnaire
  skippedAt       DateTime? // When user skipped (if allowed)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([roleStatus])
}

// Development modules - educational content for each strength
model DevelopmentModule {
  id               String  @id @default(uuid())
  key              String  @unique
  titleEs          String
  descriptionEs    String
  content          String // Markdown content
  estimatedMinutes Int
  xpReward         Int
  level            String // "beginner", "intermediate", "advanced"
  strengthKey      String? // Optional: linked to specific strength
  domainKey        String? // Optional: linked to specific domain (deprecated)
  order            Int     @default(0)
  isActive         Boolean @default(true)

  // Module type and personalization fields
  moduleType  String  @default("general") // "general" | "personalized"
  userId      String? // Only for personalized modules
  isArchived  Boolean @default(false) // Soft-delete for domain modules
  generatedBy String? // AI model used for personalized modules

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  challenges   Challenge[]
  userProgress UserModuleProgress[]
  user         User?                @relation("PersonalizedModules", fields: [userId], references: [id], onDelete: Cascade)

  @@index([strengthKey])
  @@index([domainKey])
  @@index([level])
  @@index([order])
  @@index([moduleType, strengthKey])
  @@index([userId, moduleType])
  @@index([isArchived])
}

// Challenges within modules - practical activities
model Challenge {
  id            String   @id @default(uuid())
  moduleId      String
  titleEs       String
  descriptionEs String
  type          String // "reflection", "action", "collaboration"
  xpReward      Int
  order         Int      @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  module                  DevelopmentModule        @relation(fields: [moduleId], references: [id], onDelete: Cascade)
  userChallengeProgress   UserChallengeProgress[]
  collaborativeChallenges CollaborativeChallenge[]

  @@index([moduleId])
  @@index([type])
  @@index([order])
}

// User progress tracking for modules
model UserModuleProgress {
  id                  String    @id @default(uuid())
  userId              String
  moduleId            String
  status              String    @default("not_started") // "not_started", "in_progress", "completed"
  completedChallenges Int       @default(0)
  totalChallenges     Int
  moduleXpEarned      Int       @default(0)
  startedAt           DateTime?
  completedAt         DateTime?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  user   User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  module DevelopmentModule @relation(fields: [moduleId], references: [id], onDelete: Cascade)

  @@unique([userId, moduleId])
  @@index([userId])
  @@index([moduleId])
  @@index([status])
}

// User progress tracking for individual challenges
model UserChallengeProgress {
  id          String    @id @default(uuid())
  userId      String
  challengeId String
  completed   Boolean   @default(false)
  xpAwarded   Int       @default(0)
  completedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  challenge Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)

  @@unique([userId, challengeId])
  @@index([userId])
  @@index([challengeId])
}

// Collaborative challenges between users
model CollaborativeChallenge {
  id                   String    @id @default(uuid())
  challengeId          String
  initiatorUserId      String
  partnerUserId        String
  initiatorCompleted   Boolean   @default(false)
  partnerCompleted     Boolean   @default(false)
  initiatorCompletedAt DateTime?
  partnerCompletedAt   DateTime?
  xpBonusAwarded       Int?
  status               String    @default("pending") // "pending", "confirmed", "expired"
  expiresAt            DateTime
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  challenge     Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  initiatorUser User      @relation("InitiatorChallenges", fields: [initiatorUserId], references: [id], onDelete: Cascade)
  partnerUser   User      @relation("PartnerChallenges", fields: [partnerUserId], references: [id], onDelete: Cascade)

  @@unique([challengeId, initiatorUserId, partnerUserId])
  @@index([initiatorUserId])
  @@index([partnerUserId])
  @@index([status])
}

// AI Coach recommendations cache
model UserRecommendation {
  id                 String   @id @default(uuid())
  userId             String
  recommendationType String // "next-module", "challenge", "peer-match"
  recommendations    String // JSON array of recommendations
  strengthsHash      String // MD5 hash of user's current strengths
  modelUsed          String // "gpt-4o-mini"
  expiresAt          DateTime
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, recommendationType])
  @@index([userId])
  @@index([expiresAt])
}
