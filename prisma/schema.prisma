// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "sqlite"
}

model User {
  id            String   @id @default(uuid())
  name          String
  email         String   @unique
  emailVerified Boolean  @default(false)
  image         String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  sessions           Session[]
  accounts           Account[]
  profile            UserProfile?
  dna                UserDNA?
  teamMembers        TeamMember[]
  userStrengths      UserStrength[]
  reports            Report[]
  assessmentSessions AssessmentSession[]
  assessmentAnswers  UserAssessmentAnswer[]

  // Peer Feedback relations
  requestedFeedback   FeedbackRequest[]    @relation("RequestedFeedback")
  receivedFeedback    FeedbackRequest[]    @relation("ReceivedFeedback")
  feedbackSummary     FeedbackSummary?
  strengthAdjustments StrengthAdjustment[]

  @@index([email])
}

model Session {
  id        String   @id @default(uuid())
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Account {
  id                    String    @id @default(uuid())
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerId, accountId])
  @@index([userId])
}

model Verification {
  id         String   @id @default(uuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([identifier, value])
}

// Extended user profile information
model UserProfile {
  id              String   @id @default(uuid())
  userId          String   @unique
  career          String?
  age             Int?
  gender          String? // 'M', 'F', 'O'
  description     String?
  hobbies         String? // JSON array stored as string
  profileImageUrl String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// User DNA generated from strengths
model UserDNA {
  id         String   @id @default(uuid())
  userId     String   @unique
  title      String
  summary    String
  dimensions String // JSON array stored as string
  synergies  String // JSON array stored as string
  idealRole  String // JSON array stored as string
  purpose    String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// Teams
model Team {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  members TeamMember[]
  reports Report[]

  @@index([name])
}

// Team membership (many-to-many relationship)
model TeamMember {
  id        String   @id @default(uuid())
  userId    String
  teamId    String
  role      String? // Optional role within the team
  joinedAt  DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([userId, teamId])
  @@index([userId])
  @@index([teamId])
}

// Strength domains (Doing, Feeling, Motivating, Thinking)
model Domain {
  id                 String   @id @default(uuid())
  name               String   @unique // "Doing", "Feeling", "Motivating", "Thinking"
  nameEs             String // Spanish name
  description        String
  metaphor           String
  keyQuestion        String
  summary            String
  contributionToTeam String // JSON array stored as string
  potentialPitfall   String
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  strengths           Strength[]
  domainFocuses       DomainFocus[]
  assessmentQuestions AssessmentQuestion[]

  @@index([name])
}

// Strengths catalog
model Strength {
  id                      String   @id @default(uuid())
  name                    String   @unique // English name (e.g., "Deliverer")
  nameEs                  String // Spanish name (e.g., "Cumplidor")
  domainId                String
  briefDefinition         String
  fullDefinition          String
  howToUseMoreEffectively String? // JSON array stored as string
  watchOuts               String? // JSON array stored as string
  strengthsDynamics       String?
  bestPartners            String? // JSON array stored as string
  careerApplications      String? // JSON array stored as string
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  domain              Domain               @relation(fields: [domainId], references: [id], onDelete: Cascade)
  userStrengths       UserStrength[]
  assessmentQuestions AssessmentQuestion[]
  strengthAdjustments StrengthAdjustment[]

  @@index([domainId])
  @@index([name])
}

// User's selected strengths (many-to-many, limited to 5 per user)
model UserStrength {
  id         String   @id @default(uuid())
  userId     String
  strengthId String
  rank       Int // 1-5, representing the order of importance
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  strength Strength @relation(fields: [strengthId], references: [id], onDelete: Cascade)

  @@unique([userId, strengthId])
  @@unique([userId, rank])
  @@index([userId])
  @@index([strengthId])
}

// Focus axes for culture calculation
// Represents the two axes: Energy (Action/Reflection) and Orientation (Results/People)
model Focus {
  id          String   @id @default(uuid())
  name        String   @unique // "Action", "Reflection", "Results", "People"
  nameEs      String // Spanish name
  axis        String // "energy" or "orientation"
  description String
  icon        String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations to domains that contribute to this focus
  domainFocuses           DomainFocus[]
  // Relations to cultures
  cultureFocusEnergy      Culture[]     @relation("CultureEnergy")
  cultureFocusOrientation Culture[]     @relation("CultureOrientation")

  @@index([name])
  @@index([axis])
}

// Many-to-many relationship between Domain and Focus
// Each domain contributes to exactly 2 focuses (one per axis)
model DomainFocus {
  id        String   @id @default(uuid())
  domainId  String
  focusId   String
  weight    Float    @default(1.0) // Weight of contribution (for future fine-tuning)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  domain Domain @relation(fields: [domainId], references: [id], onDelete: Cascade)
  focus  Focus  @relation(fields: [focusId], references: [id], onDelete: Cascade)

  @@unique([domainId, focusId])
  @@index([domainId])
  @@index([focusId])
}

// Team Cultures that emerge from domain combinations
model Culture {
  id                 String   @id @default(uuid())
  name               String   @unique // "Execution", "Influence", "Strategy", "Cohesion"
  nameEs             String // Spanish name
  subtitle           String // Short metaphor
  description        String // Full description
  focusEnergyId      String // Action or Reflection
  focusOrientationId String // Results or People
  attributes         String // JSON array of key attributes
  icon               String?
  color              String // For UI theming
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  focusEnergy      Focus @relation("CultureEnergy", fields: [focusEnergyId], references: [id])
  focusOrientation Focus @relation("CultureOrientation", fields: [focusOrientationId], references: [id])

  @@unique([focusEnergyId, focusOrientationId])
  @@index([name])
}

// ============================================================
// AI-Generated Reports
// ============================================================

enum ReportType {
  // Individual Reports
  INDIVIDUAL_FULL // Full personal report with all sections
  INDIVIDUAL_STRENGTHS // Core strengths report
  INDIVIDUAL_DEVELOPMENT // Development opportunities
  INDIVIDUAL_RELATIONSHIPS // Strengths and relationships

  // Team Reports
  TEAM_CULTURE // Team culture map analysis
  TEAM_STRENGTHS_DISTRIBUTION // Strengths distribution across team
  TEAM_DOMAIN_COVERAGE // Domain coverage analysis
  TEAM_FULL // Full team assessment
  TEAM_TIPS // Team relationship tips and book recommendations
}

enum ReportStatus {
  PENDING // Report requested but not started
  GENERATING // AI is generating the report
  COMPLETED // Report generated successfully
  FAILED // Report generation failed
}

model Report {
  id        String       @id @default(uuid())
  type      ReportType
  status    ReportStatus @default(PENDING)
  version   Int          @default(1) // Track changes over time
  content   String? // JSON serialized report content
  error     String? // Error message if failed
  modelUsed String? // AI model used for generation
  metadata  String? // JSON with generation metadata (tokens, duration, etc.)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  // Relations - one of these will be set based on report type
  userId String?
  teamId String?

  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)
  team Team? @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([type, userId, teamId]) // Prevent duplicate reports per user/team combination (covers both individual and team reports)
  @@index([userId])
  @@index([teamId])
  @@index([type])
  @@index([status])
}

// ============================================================
// Assessment System
// ============================================================

enum QuestionType {
  SCALE // 1-5 Likert scale
  CHOICE // Single select from options
  RANKING // Order multiple items by preference
}

enum SessionStatus {
  IN_PROGRESS // User is actively taking the assessment
  COMPLETED // Assessment finished successfully
  ABANDONED // Inactive for 30+ days or user started new session
}

// Assessment questions organized by phase
model AssessmentQuestion {
  id         String       @id @default(uuid())
  phase      Int // 1 (Domain Discovery), 2 (Strength Refinement), 3 (Ranking Confirmation)
  order      Int // Display order within phase
  text       String // Question text
  type       QuestionType
  options    String? // JSON array for choice/ranking questions
  scaleRange String? // JSON object with min, max, labels for scale questions
  domainId   String // Primary domain this question measures
  strengthId String? // Optional specific strength for Phase 2/3 questions
  weight     Float        @default(1.0) // Importance weight for scoring (0.1-2.0)
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt

  domain   Domain                 @relation(fields: [domainId], references: [id], onDelete: Cascade)
  strength Strength?              @relation(fields: [strengthId], references: [id], onDelete: SetNull)
  answers  UserAssessmentAnswer[]

  @@unique([phase, order]) // Ensure unique ordering within each phase
  @@index([phase])
  @@index([domainId])
  @@index([strengthId])
}

// User's answers to assessment questions
model UserAssessmentAnswer {
  id         String   @id @default(uuid())
  userId     String
  sessionId  String
  questionId String
  answer     String // JSON: number for scale, string for choice, string[] for ranking
  confidence Int? // Self-reported confidence (1-5), optional
  answeredAt DateTime @default(now())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user     User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  session  AssessmentSession  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  question AssessmentQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([sessionId, questionId]) // One answer per question per session
  @@index([userId])
  @@index([sessionId])
  @@index([questionId])
}

// Assessment session tracking
model AssessmentSession {
  id             String        @id @default(uuid())
  userId         String
  status         SessionStatus @default(IN_PROGRESS)
  phase          Int           @default(1) // Current phase: 1, 2, or 3
  currentStep    Int           @default(1) // Current question number in overall flow
  totalSteps     Int           @default(60) // Total questions (20+30+10)
  domainScores   String? // JSON: Record<domainId, score> - calculated after Phase 1
  strengthScores String? // JSON: Record<strengthId, score> - calculated after Phase 2
  results        String? // JSON: AssessmentResults - final calculated results
  startedAt      DateTime      @default(now())
  lastActivityAt DateTime      @default(now())
  completedAt    DateTime?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  user    User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  answers UserAssessmentAnswer[]

  @@index([userId, status])
  @@index([lastActivityAt]) // For cleanup job
}

// ============================================================
// Peer Feedback System
// ============================================================

enum FeedbackRequestStatus {
  PENDING // Request sent, awaiting response
  COMPLETED // Respondent completed the feedback
  DECLINED // Respondent declined to provide feedback
  EXPIRED // Request expired after 14 days
}

// Feedback request from one user to another
model FeedbackRequest {
  id           String                @id @default(uuid())
  requesterId  String // User requesting feedback
  respondentId String // User providing feedback
  status       FeedbackRequestStatus @default(PENDING)
  isAnonymous  Boolean               @default(true)
  sentAt       DateTime              @default(now())
  completedAt  DateTime?
  expiresAt    DateTime // sentAt + 14 days
  createdAt    DateTime              @default(now())
  updatedAt    DateTime              @updatedAt

  requester  User               @relation("RequestedFeedback", fields: [requesterId], references: [id], onDelete: Cascade)
  respondent User               @relation("ReceivedFeedback", fields: [respondentId], references: [id], onDelete: Cascade)
  responses  FeedbackResponse[]

  @@unique([requesterId, respondentId, sentAt]) // Prevent duplicate requests at same time
  @@index([respondentId, status]) // Query pending requests for a user
  @@index([requesterId]) // Query sent requests by a user
  @@index([expiresAt]) // Cleanup expired requests
  @@index([status])
}

// Behavioral questions for peer feedback (5 questions total)
model FeedbackQuestion {
  id              String   @id @default(uuid())
  text            String // Question text
  answerType      String // "scale" | "behavioral_choice"
  answerOptions   String // JSON: array of answer options
  strengthMapping String // JSON: { "optionId": { "strengthId": weight } }
  order           Int      @unique // Display order (1-5)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  responses FeedbackResponse[]

  @@index([order])
}

// Individual response to a feedback question
model FeedbackResponse {
  id            String   @id @default(uuid())
  requestId     String
  questionId    String
  answer        String // JSON: selected option(s)
  anonymousHash String? // One-way hash for anonymous responses (prevents duplicates)
  createdAt     DateTime @default(now())

  request  FeedbackRequest  @relation(fields: [requestId], references: [id], onDelete: Cascade)
  question FeedbackQuestion @relation(fields: [questionId], references: [id])

  @@unique([requestId, questionId]) // One answer per question per request
  @@index([requestId]) // Query all responses for a request
  @@index([anonymousHash]) // Duplicate detection
}

// Aggregated feedback insights for a user
model FeedbackSummary {
  id                  String    @id @default(uuid())
  userId              String    @unique
  totalResponses      Int       @default(0)
  lastResponseAt      DateTime?
  strengthAdjustments String // JSON: { "strengthId": { "delta": number, "confidence": number } }
  insights            String? // AI-generated summary text
  insightsGeneratedAt DateTime?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([lastResponseAt]) // Track recent feedback activity
}

enum StrengthAdjustmentStatus {
  PENDING // Suggested but not acted upon
  ACCEPTED // User accepted the adjustment
  REJECTED // User rejected the adjustment
}

// Proposed strength profile adjustments based on peer feedback
model StrengthAdjustment {
  id             String                   @id @default(uuid())
  userId         String
  strengthId     String
  suggestedDelta Float // -1.0 to +1.0 confidence adjustment
  supportingData String // JSON: evidence from feedback
  status         StrengthAdjustmentStatus @default(PENDING)
  createdAt      DateTime                 @default(now())
  processedAt    DateTime?

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  strength Strength @relation(fields: [strengthId], references: [id])

  @@unique([userId, strengthId, createdAt]) // One suggestion per strength per cycle
  @@index([userId, status]) // Query pending adjustments
  @@index([strengthId])
}
