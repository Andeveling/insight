/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports the `AssessmentSession` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client";
import type * as $Enums from "../enums";
import type * as Prisma from "../internal/prismaNamespace";

/**
 * Model AssessmentSession
 *
 */
export type AssessmentSessionModel =
	runtime.Types.Result.DefaultSelection<Prisma.$AssessmentSessionPayload>;

export type AggregateAssessmentSession = {
	_count: AssessmentSessionCountAggregateOutputType | null;
	_avg: AssessmentSessionAvgAggregateOutputType | null;
	_sum: AssessmentSessionSumAggregateOutputType | null;
	_min: AssessmentSessionMinAggregateOutputType | null;
	_max: AssessmentSessionMaxAggregateOutputType | null;
};

export type AssessmentSessionAvgAggregateOutputType = {
	phase: number | null;
	currentStep: number | null;
	totalSteps: number | null;
};

export type AssessmentSessionSumAggregateOutputType = {
	phase: number | null;
	currentStep: number | null;
	totalSteps: number | null;
};

export type AssessmentSessionMinAggregateOutputType = {
	id: string | null;
	userId: string | null;
	status: $Enums.SessionStatus | null;
	phase: number | null;
	currentStep: number | null;
	totalSteps: number | null;
	domainScores: string | null;
	strengthScores: string | null;
	results: string | null;
	startedAt: Date | null;
	lastActivityAt: Date | null;
	completedAt: Date | null;
	createdAt: Date | null;
	updatedAt: Date | null;
};

export type AssessmentSessionMaxAggregateOutputType = {
	id: string | null;
	userId: string | null;
	status: $Enums.SessionStatus | null;
	phase: number | null;
	currentStep: number | null;
	totalSteps: number | null;
	domainScores: string | null;
	strengthScores: string | null;
	results: string | null;
	startedAt: Date | null;
	lastActivityAt: Date | null;
	completedAt: Date | null;
	createdAt: Date | null;
	updatedAt: Date | null;
};

export type AssessmentSessionCountAggregateOutputType = {
	id: number;
	userId: number;
	status: number;
	phase: number;
	currentStep: number;
	totalSteps: number;
	domainScores: number;
	strengthScores: number;
	results: number;
	startedAt: number;
	lastActivityAt: number;
	completedAt: number;
	createdAt: number;
	updatedAt: number;
	_all: number;
};

export type AssessmentSessionAvgAggregateInputType = {
	phase?: true;
	currentStep?: true;
	totalSteps?: true;
};

export type AssessmentSessionSumAggregateInputType = {
	phase?: true;
	currentStep?: true;
	totalSteps?: true;
};

export type AssessmentSessionMinAggregateInputType = {
	id?: true;
	userId?: true;
	status?: true;
	phase?: true;
	currentStep?: true;
	totalSteps?: true;
	domainScores?: true;
	strengthScores?: true;
	results?: true;
	startedAt?: true;
	lastActivityAt?: true;
	completedAt?: true;
	createdAt?: true;
	updatedAt?: true;
};

export type AssessmentSessionMaxAggregateInputType = {
	id?: true;
	userId?: true;
	status?: true;
	phase?: true;
	currentStep?: true;
	totalSteps?: true;
	domainScores?: true;
	strengthScores?: true;
	results?: true;
	startedAt?: true;
	lastActivityAt?: true;
	completedAt?: true;
	createdAt?: true;
	updatedAt?: true;
};

export type AssessmentSessionCountAggregateInputType = {
	id?: true;
	userId?: true;
	status?: true;
	phase?: true;
	currentStep?: true;
	totalSteps?: true;
	domainScores?: true;
	strengthScores?: true;
	results?: true;
	startedAt?: true;
	lastActivityAt?: true;
	completedAt?: true;
	createdAt?: true;
	updatedAt?: true;
	_all?: true;
};

export type AssessmentSessionAggregateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which AssessmentSession to aggregate.
	 */
	where?: Prisma.AssessmentSessionWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of AssessmentSessions to fetch.
	 */
	orderBy?:
		| Prisma.AssessmentSessionOrderByWithRelationInput
		| Prisma.AssessmentSessionOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the start position
	 */
	cursor?: Prisma.AssessmentSessionWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` AssessmentSessions from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` AssessmentSessions.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Count returned AssessmentSessions
	 **/
	_count?: true | AssessmentSessionCountAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to average
	 **/
	_avg?: AssessmentSessionAvgAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to sum
	 **/
	_sum?: AssessmentSessionSumAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the minimum value
	 **/
	_min?: AssessmentSessionMinAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the maximum value
	 **/
	_max?: AssessmentSessionMaxAggregateInputType;
};

export type GetAssessmentSessionAggregateType<
	T extends AssessmentSessionAggregateArgs,
> = {
	[P in keyof T & keyof AggregateAssessmentSession]: P extends
		| "_count"
		| "count"
		? T[P] extends true
			? number
			: Prisma.GetScalarType<T[P], AggregateAssessmentSession[P]>
		: Prisma.GetScalarType<T[P], AggregateAssessmentSession[P]>;
};

export type AssessmentSessionGroupByArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.AssessmentSessionWhereInput;
	orderBy?:
		| Prisma.AssessmentSessionOrderByWithAggregationInput
		| Prisma.AssessmentSessionOrderByWithAggregationInput[];
	by:
		| Prisma.AssessmentSessionScalarFieldEnum[]
		| Prisma.AssessmentSessionScalarFieldEnum;
	having?: Prisma.AssessmentSessionScalarWhereWithAggregatesInput;
	take?: number;
	skip?: number;
	_count?: AssessmentSessionCountAggregateInputType | true;
	_avg?: AssessmentSessionAvgAggregateInputType;
	_sum?: AssessmentSessionSumAggregateInputType;
	_min?: AssessmentSessionMinAggregateInputType;
	_max?: AssessmentSessionMaxAggregateInputType;
};

export type AssessmentSessionGroupByOutputType = {
	id: string;
	userId: string;
	status: $Enums.SessionStatus;
	phase: number;
	currentStep: number;
	totalSteps: number;
	domainScores: string | null;
	strengthScores: string | null;
	results: string | null;
	startedAt: Date;
	lastActivityAt: Date;
	completedAt: Date | null;
	createdAt: Date;
	updatedAt: Date;
	_count: AssessmentSessionCountAggregateOutputType | null;
	_avg: AssessmentSessionAvgAggregateOutputType | null;
	_sum: AssessmentSessionSumAggregateOutputType | null;
	_min: AssessmentSessionMinAggregateOutputType | null;
	_max: AssessmentSessionMaxAggregateOutputType | null;
};

type GetAssessmentSessionGroupByPayload<
	T extends AssessmentSessionGroupByArgs,
> = Prisma.PrismaPromise<
	Array<
		Prisma.PickEnumerable<AssessmentSessionGroupByOutputType, T["by"]> & {
			[P in keyof T &
				keyof AssessmentSessionGroupByOutputType]: P extends "_count"
				? T[P] extends boolean
					? number
					: Prisma.GetScalarType<T[P], AssessmentSessionGroupByOutputType[P]>
				: Prisma.GetScalarType<T[P], AssessmentSessionGroupByOutputType[P]>;
		}
	>
>;

export type AssessmentSessionWhereInput = {
	AND?:
		| Prisma.AssessmentSessionWhereInput
		| Prisma.AssessmentSessionWhereInput[];
	OR?: Prisma.AssessmentSessionWhereInput[];
	NOT?:
		| Prisma.AssessmentSessionWhereInput
		| Prisma.AssessmentSessionWhereInput[];
	id?: Prisma.StringFilter<"AssessmentSession"> | string;
	userId?: Prisma.StringFilter<"AssessmentSession"> | string;
	status?:
		| Prisma.EnumSessionStatusFilter<"AssessmentSession">
		| $Enums.SessionStatus;
	phase?: Prisma.IntFilter<"AssessmentSession"> | number;
	currentStep?: Prisma.IntFilter<"AssessmentSession"> | number;
	totalSteps?: Prisma.IntFilter<"AssessmentSession"> | number;
	domainScores?:
		| Prisma.StringNullableFilter<"AssessmentSession">
		| string
		| null;
	strengthScores?:
		| Prisma.StringNullableFilter<"AssessmentSession">
		| string
		| null;
	results?: Prisma.StringNullableFilter<"AssessmentSession"> | string | null;
	startedAt?: Prisma.DateTimeFilter<"AssessmentSession"> | Date | string;
	lastActivityAt?: Prisma.DateTimeFilter<"AssessmentSession"> | Date | string;
	completedAt?:
		| Prisma.DateTimeNullableFilter<"AssessmentSession">
		| Date
		| string
		| null;
	createdAt?: Prisma.DateTimeFilter<"AssessmentSession"> | Date | string;
	updatedAt?: Prisma.DateTimeFilter<"AssessmentSession"> | Date | string;
	user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>;
	answers?: Prisma.UserAssessmentAnswerListRelationFilter;
};

export type AssessmentSessionOrderByWithRelationInput = {
	id?: Prisma.SortOrder;
	userId?: Prisma.SortOrder;
	status?: Prisma.SortOrder;
	phase?: Prisma.SortOrder;
	currentStep?: Prisma.SortOrder;
	totalSteps?: Prisma.SortOrder;
	domainScores?: Prisma.SortOrderInput | Prisma.SortOrder;
	strengthScores?: Prisma.SortOrderInput | Prisma.SortOrder;
	results?: Prisma.SortOrderInput | Prisma.SortOrder;
	startedAt?: Prisma.SortOrder;
	lastActivityAt?: Prisma.SortOrder;
	completedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	user?: Prisma.UserOrderByWithRelationInput;
	answers?: Prisma.UserAssessmentAnswerOrderByRelationAggregateInput;
};

export type AssessmentSessionWhereUniqueInput = Prisma.AtLeast<
	{
		id?: string;
		AND?:
			| Prisma.AssessmentSessionWhereInput
			| Prisma.AssessmentSessionWhereInput[];
		OR?: Prisma.AssessmentSessionWhereInput[];
		NOT?:
			| Prisma.AssessmentSessionWhereInput
			| Prisma.AssessmentSessionWhereInput[];
		userId?: Prisma.StringFilter<"AssessmentSession"> | string;
		status?:
			| Prisma.EnumSessionStatusFilter<"AssessmentSession">
			| $Enums.SessionStatus;
		phase?: Prisma.IntFilter<"AssessmentSession"> | number;
		currentStep?: Prisma.IntFilter<"AssessmentSession"> | number;
		totalSteps?: Prisma.IntFilter<"AssessmentSession"> | number;
		domainScores?:
			| Prisma.StringNullableFilter<"AssessmentSession">
			| string
			| null;
		strengthScores?:
			| Prisma.StringNullableFilter<"AssessmentSession">
			| string
			| null;
		results?: Prisma.StringNullableFilter<"AssessmentSession"> | string | null;
		startedAt?: Prisma.DateTimeFilter<"AssessmentSession"> | Date | string;
		lastActivityAt?: Prisma.DateTimeFilter<"AssessmentSession"> | Date | string;
		completedAt?:
			| Prisma.DateTimeNullableFilter<"AssessmentSession">
			| Date
			| string
			| null;
		createdAt?: Prisma.DateTimeFilter<"AssessmentSession"> | Date | string;
		updatedAt?: Prisma.DateTimeFilter<"AssessmentSession"> | Date | string;
		user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>;
		answers?: Prisma.UserAssessmentAnswerListRelationFilter;
	},
	"id"
>;

export type AssessmentSessionOrderByWithAggregationInput = {
	id?: Prisma.SortOrder;
	userId?: Prisma.SortOrder;
	status?: Prisma.SortOrder;
	phase?: Prisma.SortOrder;
	currentStep?: Prisma.SortOrder;
	totalSteps?: Prisma.SortOrder;
	domainScores?: Prisma.SortOrderInput | Prisma.SortOrder;
	strengthScores?: Prisma.SortOrderInput | Prisma.SortOrder;
	results?: Prisma.SortOrderInput | Prisma.SortOrder;
	startedAt?: Prisma.SortOrder;
	lastActivityAt?: Prisma.SortOrder;
	completedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	_count?: Prisma.AssessmentSessionCountOrderByAggregateInput;
	_avg?: Prisma.AssessmentSessionAvgOrderByAggregateInput;
	_max?: Prisma.AssessmentSessionMaxOrderByAggregateInput;
	_min?: Prisma.AssessmentSessionMinOrderByAggregateInput;
	_sum?: Prisma.AssessmentSessionSumOrderByAggregateInput;
};

export type AssessmentSessionScalarWhereWithAggregatesInput = {
	AND?:
		| Prisma.AssessmentSessionScalarWhereWithAggregatesInput
		| Prisma.AssessmentSessionScalarWhereWithAggregatesInput[];
	OR?: Prisma.AssessmentSessionScalarWhereWithAggregatesInput[];
	NOT?:
		| Prisma.AssessmentSessionScalarWhereWithAggregatesInput
		| Prisma.AssessmentSessionScalarWhereWithAggregatesInput[];
	id?: Prisma.StringWithAggregatesFilter<"AssessmentSession"> | string;
	userId?: Prisma.StringWithAggregatesFilter<"AssessmentSession"> | string;
	status?:
		| Prisma.EnumSessionStatusWithAggregatesFilter<"AssessmentSession">
		| $Enums.SessionStatus;
	phase?: Prisma.IntWithAggregatesFilter<"AssessmentSession"> | number;
	currentStep?: Prisma.IntWithAggregatesFilter<"AssessmentSession"> | number;
	totalSteps?: Prisma.IntWithAggregatesFilter<"AssessmentSession"> | number;
	domainScores?:
		| Prisma.StringNullableWithAggregatesFilter<"AssessmentSession">
		| string
		| null;
	strengthScores?:
		| Prisma.StringNullableWithAggregatesFilter<"AssessmentSession">
		| string
		| null;
	results?:
		| Prisma.StringNullableWithAggregatesFilter<"AssessmentSession">
		| string
		| null;
	startedAt?:
		| Prisma.DateTimeWithAggregatesFilter<"AssessmentSession">
		| Date
		| string;
	lastActivityAt?:
		| Prisma.DateTimeWithAggregatesFilter<"AssessmentSession">
		| Date
		| string;
	completedAt?:
		| Prisma.DateTimeNullableWithAggregatesFilter<"AssessmentSession">
		| Date
		| string
		| null;
	createdAt?:
		| Prisma.DateTimeWithAggregatesFilter<"AssessmentSession">
		| Date
		| string;
	updatedAt?:
		| Prisma.DateTimeWithAggregatesFilter<"AssessmentSession">
		| Date
		| string;
};

export type AssessmentSessionCreateInput = {
	id?: string;
	status?: $Enums.SessionStatus;
	phase?: number;
	currentStep?: number;
	totalSteps?: number;
	domainScores?: string | null;
	strengthScores?: string | null;
	results?: string | null;
	startedAt?: Date | string;
	lastActivityAt?: Date | string;
	completedAt?: Date | string | null;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	user: Prisma.UserCreateNestedOneWithoutAssessmentSessionsInput;
	answers?: Prisma.UserAssessmentAnswerCreateNestedManyWithoutSessionInput;
};

export type AssessmentSessionUncheckedCreateInput = {
	id?: string;
	userId: string;
	status?: $Enums.SessionStatus;
	phase?: number;
	currentStep?: number;
	totalSteps?: number;
	domainScores?: string | null;
	strengthScores?: string | null;
	results?: string | null;
	startedAt?: Date | string;
	lastActivityAt?: Date | string;
	completedAt?: Date | string | null;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	answers?: Prisma.UserAssessmentAnswerUncheckedCreateNestedManyWithoutSessionInput;
};

export type AssessmentSessionUpdateInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	status?:
		| Prisma.EnumSessionStatusFieldUpdateOperationsInput
		| $Enums.SessionStatus;
	phase?: Prisma.IntFieldUpdateOperationsInput | number;
	currentStep?: Prisma.IntFieldUpdateOperationsInput | number;
	totalSteps?: Prisma.IntFieldUpdateOperationsInput | number;
	domainScores?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	strengthScores?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	results?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	startedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	lastActivityAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	completedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	user?: Prisma.UserUpdateOneRequiredWithoutAssessmentSessionsNestedInput;
	answers?: Prisma.UserAssessmentAnswerUpdateManyWithoutSessionNestedInput;
};

export type AssessmentSessionUncheckedUpdateInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	userId?: Prisma.StringFieldUpdateOperationsInput | string;
	status?:
		| Prisma.EnumSessionStatusFieldUpdateOperationsInput
		| $Enums.SessionStatus;
	phase?: Prisma.IntFieldUpdateOperationsInput | number;
	currentStep?: Prisma.IntFieldUpdateOperationsInput | number;
	totalSteps?: Prisma.IntFieldUpdateOperationsInput | number;
	domainScores?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	strengthScores?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	results?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	startedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	lastActivityAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	completedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	answers?: Prisma.UserAssessmentAnswerUncheckedUpdateManyWithoutSessionNestedInput;
};

export type AssessmentSessionCreateManyInput = {
	id?: string;
	userId: string;
	status?: $Enums.SessionStatus;
	phase?: number;
	currentStep?: number;
	totalSteps?: number;
	domainScores?: string | null;
	strengthScores?: string | null;
	results?: string | null;
	startedAt?: Date | string;
	lastActivityAt?: Date | string;
	completedAt?: Date | string | null;
	createdAt?: Date | string;
	updatedAt?: Date | string;
};

export type AssessmentSessionUpdateManyMutationInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	status?:
		| Prisma.EnumSessionStatusFieldUpdateOperationsInput
		| $Enums.SessionStatus;
	phase?: Prisma.IntFieldUpdateOperationsInput | number;
	currentStep?: Prisma.IntFieldUpdateOperationsInput | number;
	totalSteps?: Prisma.IntFieldUpdateOperationsInput | number;
	domainScores?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	strengthScores?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	results?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	startedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	lastActivityAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	completedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type AssessmentSessionUncheckedUpdateManyInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	userId?: Prisma.StringFieldUpdateOperationsInput | string;
	status?:
		| Prisma.EnumSessionStatusFieldUpdateOperationsInput
		| $Enums.SessionStatus;
	phase?: Prisma.IntFieldUpdateOperationsInput | number;
	currentStep?: Prisma.IntFieldUpdateOperationsInput | number;
	totalSteps?: Prisma.IntFieldUpdateOperationsInput | number;
	domainScores?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	strengthScores?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	results?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	startedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	lastActivityAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	completedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type AssessmentSessionListRelationFilter = {
	every?: Prisma.AssessmentSessionWhereInput;
	some?: Prisma.AssessmentSessionWhereInput;
	none?: Prisma.AssessmentSessionWhereInput;
};

export type AssessmentSessionOrderByRelationAggregateInput = {
	_count?: Prisma.SortOrder;
};

export type AssessmentSessionScalarRelationFilter = {
	is?: Prisma.AssessmentSessionWhereInput;
	isNot?: Prisma.AssessmentSessionWhereInput;
};

export type AssessmentSessionCountOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	userId?: Prisma.SortOrder;
	status?: Prisma.SortOrder;
	phase?: Prisma.SortOrder;
	currentStep?: Prisma.SortOrder;
	totalSteps?: Prisma.SortOrder;
	domainScores?: Prisma.SortOrder;
	strengthScores?: Prisma.SortOrder;
	results?: Prisma.SortOrder;
	startedAt?: Prisma.SortOrder;
	lastActivityAt?: Prisma.SortOrder;
	completedAt?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
};

export type AssessmentSessionAvgOrderByAggregateInput = {
	phase?: Prisma.SortOrder;
	currentStep?: Prisma.SortOrder;
	totalSteps?: Prisma.SortOrder;
};

export type AssessmentSessionMaxOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	userId?: Prisma.SortOrder;
	status?: Prisma.SortOrder;
	phase?: Prisma.SortOrder;
	currentStep?: Prisma.SortOrder;
	totalSteps?: Prisma.SortOrder;
	domainScores?: Prisma.SortOrder;
	strengthScores?: Prisma.SortOrder;
	results?: Prisma.SortOrder;
	startedAt?: Prisma.SortOrder;
	lastActivityAt?: Prisma.SortOrder;
	completedAt?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
};

export type AssessmentSessionMinOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	userId?: Prisma.SortOrder;
	status?: Prisma.SortOrder;
	phase?: Prisma.SortOrder;
	currentStep?: Prisma.SortOrder;
	totalSteps?: Prisma.SortOrder;
	domainScores?: Prisma.SortOrder;
	strengthScores?: Prisma.SortOrder;
	results?: Prisma.SortOrder;
	startedAt?: Prisma.SortOrder;
	lastActivityAt?: Prisma.SortOrder;
	completedAt?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
};

export type AssessmentSessionSumOrderByAggregateInput = {
	phase?: Prisma.SortOrder;
	currentStep?: Prisma.SortOrder;
	totalSteps?: Prisma.SortOrder;
};

export type AssessmentSessionCreateNestedManyWithoutUserInput = {
	create?:
		| Prisma.XOR<
				Prisma.AssessmentSessionCreateWithoutUserInput,
				Prisma.AssessmentSessionUncheckedCreateWithoutUserInput
		  >
		| Prisma.AssessmentSessionCreateWithoutUserInput[]
		| Prisma.AssessmentSessionUncheckedCreateWithoutUserInput[];
	connectOrCreate?:
		| Prisma.AssessmentSessionCreateOrConnectWithoutUserInput
		| Prisma.AssessmentSessionCreateOrConnectWithoutUserInput[];
	createMany?: Prisma.AssessmentSessionCreateManyUserInputEnvelope;
	connect?:
		| Prisma.AssessmentSessionWhereUniqueInput
		| Prisma.AssessmentSessionWhereUniqueInput[];
};

export type AssessmentSessionUncheckedCreateNestedManyWithoutUserInput = {
	create?:
		| Prisma.XOR<
				Prisma.AssessmentSessionCreateWithoutUserInput,
				Prisma.AssessmentSessionUncheckedCreateWithoutUserInput
		  >
		| Prisma.AssessmentSessionCreateWithoutUserInput[]
		| Prisma.AssessmentSessionUncheckedCreateWithoutUserInput[];
	connectOrCreate?:
		| Prisma.AssessmentSessionCreateOrConnectWithoutUserInput
		| Prisma.AssessmentSessionCreateOrConnectWithoutUserInput[];
	createMany?: Prisma.AssessmentSessionCreateManyUserInputEnvelope;
	connect?:
		| Prisma.AssessmentSessionWhereUniqueInput
		| Prisma.AssessmentSessionWhereUniqueInput[];
};

export type AssessmentSessionUpdateManyWithoutUserNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.AssessmentSessionCreateWithoutUserInput,
				Prisma.AssessmentSessionUncheckedCreateWithoutUserInput
		  >
		| Prisma.AssessmentSessionCreateWithoutUserInput[]
		| Prisma.AssessmentSessionUncheckedCreateWithoutUserInput[];
	connectOrCreate?:
		| Prisma.AssessmentSessionCreateOrConnectWithoutUserInput
		| Prisma.AssessmentSessionCreateOrConnectWithoutUserInput[];
	upsert?:
		| Prisma.AssessmentSessionUpsertWithWhereUniqueWithoutUserInput
		| Prisma.AssessmentSessionUpsertWithWhereUniqueWithoutUserInput[];
	createMany?: Prisma.AssessmentSessionCreateManyUserInputEnvelope;
	set?:
		| Prisma.AssessmentSessionWhereUniqueInput
		| Prisma.AssessmentSessionWhereUniqueInput[];
	disconnect?:
		| Prisma.AssessmentSessionWhereUniqueInput
		| Prisma.AssessmentSessionWhereUniqueInput[];
	delete?:
		| Prisma.AssessmentSessionWhereUniqueInput
		| Prisma.AssessmentSessionWhereUniqueInput[];
	connect?:
		| Prisma.AssessmentSessionWhereUniqueInput
		| Prisma.AssessmentSessionWhereUniqueInput[];
	update?:
		| Prisma.AssessmentSessionUpdateWithWhereUniqueWithoutUserInput
		| Prisma.AssessmentSessionUpdateWithWhereUniqueWithoutUserInput[];
	updateMany?:
		| Prisma.AssessmentSessionUpdateManyWithWhereWithoutUserInput
		| Prisma.AssessmentSessionUpdateManyWithWhereWithoutUserInput[];
	deleteMany?:
		| Prisma.AssessmentSessionScalarWhereInput
		| Prisma.AssessmentSessionScalarWhereInput[];
};

export type AssessmentSessionUncheckedUpdateManyWithoutUserNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.AssessmentSessionCreateWithoutUserInput,
				Prisma.AssessmentSessionUncheckedCreateWithoutUserInput
		  >
		| Prisma.AssessmentSessionCreateWithoutUserInput[]
		| Prisma.AssessmentSessionUncheckedCreateWithoutUserInput[];
	connectOrCreate?:
		| Prisma.AssessmentSessionCreateOrConnectWithoutUserInput
		| Prisma.AssessmentSessionCreateOrConnectWithoutUserInput[];
	upsert?:
		| Prisma.AssessmentSessionUpsertWithWhereUniqueWithoutUserInput
		| Prisma.AssessmentSessionUpsertWithWhereUniqueWithoutUserInput[];
	createMany?: Prisma.AssessmentSessionCreateManyUserInputEnvelope;
	set?:
		| Prisma.AssessmentSessionWhereUniqueInput
		| Prisma.AssessmentSessionWhereUniqueInput[];
	disconnect?:
		| Prisma.AssessmentSessionWhereUniqueInput
		| Prisma.AssessmentSessionWhereUniqueInput[];
	delete?:
		| Prisma.AssessmentSessionWhereUniqueInput
		| Prisma.AssessmentSessionWhereUniqueInput[];
	connect?:
		| Prisma.AssessmentSessionWhereUniqueInput
		| Prisma.AssessmentSessionWhereUniqueInput[];
	update?:
		| Prisma.AssessmentSessionUpdateWithWhereUniqueWithoutUserInput
		| Prisma.AssessmentSessionUpdateWithWhereUniqueWithoutUserInput[];
	updateMany?:
		| Prisma.AssessmentSessionUpdateManyWithWhereWithoutUserInput
		| Prisma.AssessmentSessionUpdateManyWithWhereWithoutUserInput[];
	deleteMany?:
		| Prisma.AssessmentSessionScalarWhereInput
		| Prisma.AssessmentSessionScalarWhereInput[];
};

export type AssessmentSessionCreateNestedOneWithoutAnswersInput = {
	create?: Prisma.XOR<
		Prisma.AssessmentSessionCreateWithoutAnswersInput,
		Prisma.AssessmentSessionUncheckedCreateWithoutAnswersInput
	>;
	connectOrCreate?: Prisma.AssessmentSessionCreateOrConnectWithoutAnswersInput;
	connect?: Prisma.AssessmentSessionWhereUniqueInput;
};

export type AssessmentSessionUpdateOneRequiredWithoutAnswersNestedInput = {
	create?: Prisma.XOR<
		Prisma.AssessmentSessionCreateWithoutAnswersInput,
		Prisma.AssessmentSessionUncheckedCreateWithoutAnswersInput
	>;
	connectOrCreate?: Prisma.AssessmentSessionCreateOrConnectWithoutAnswersInput;
	upsert?: Prisma.AssessmentSessionUpsertWithoutAnswersInput;
	connect?: Prisma.AssessmentSessionWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.AssessmentSessionUpdateToOneWithWhereWithoutAnswersInput,
			Prisma.AssessmentSessionUpdateWithoutAnswersInput
		>,
		Prisma.AssessmentSessionUncheckedUpdateWithoutAnswersInput
	>;
};

export type EnumSessionStatusFieldUpdateOperationsInput = {
	set?: $Enums.SessionStatus;
};

export type AssessmentSessionCreateWithoutUserInput = {
	id?: string;
	status?: $Enums.SessionStatus;
	phase?: number;
	currentStep?: number;
	totalSteps?: number;
	domainScores?: string | null;
	strengthScores?: string | null;
	results?: string | null;
	startedAt?: Date | string;
	lastActivityAt?: Date | string;
	completedAt?: Date | string | null;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	answers?: Prisma.UserAssessmentAnswerCreateNestedManyWithoutSessionInput;
};

export type AssessmentSessionUncheckedCreateWithoutUserInput = {
	id?: string;
	status?: $Enums.SessionStatus;
	phase?: number;
	currentStep?: number;
	totalSteps?: number;
	domainScores?: string | null;
	strengthScores?: string | null;
	results?: string | null;
	startedAt?: Date | string;
	lastActivityAt?: Date | string;
	completedAt?: Date | string | null;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	answers?: Prisma.UserAssessmentAnswerUncheckedCreateNestedManyWithoutSessionInput;
};

export type AssessmentSessionCreateOrConnectWithoutUserInput = {
	where: Prisma.AssessmentSessionWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.AssessmentSessionCreateWithoutUserInput,
		Prisma.AssessmentSessionUncheckedCreateWithoutUserInput
	>;
};

export type AssessmentSessionCreateManyUserInputEnvelope = {
	data:
		| Prisma.AssessmentSessionCreateManyUserInput
		| Prisma.AssessmentSessionCreateManyUserInput[];
};

export type AssessmentSessionUpsertWithWhereUniqueWithoutUserInput = {
	where: Prisma.AssessmentSessionWhereUniqueInput;
	update: Prisma.XOR<
		Prisma.AssessmentSessionUpdateWithoutUserInput,
		Prisma.AssessmentSessionUncheckedUpdateWithoutUserInput
	>;
	create: Prisma.XOR<
		Prisma.AssessmentSessionCreateWithoutUserInput,
		Prisma.AssessmentSessionUncheckedCreateWithoutUserInput
	>;
};

export type AssessmentSessionUpdateWithWhereUniqueWithoutUserInput = {
	where: Prisma.AssessmentSessionWhereUniqueInput;
	data: Prisma.XOR<
		Prisma.AssessmentSessionUpdateWithoutUserInput,
		Prisma.AssessmentSessionUncheckedUpdateWithoutUserInput
	>;
};

export type AssessmentSessionUpdateManyWithWhereWithoutUserInput = {
	where: Prisma.AssessmentSessionScalarWhereInput;
	data: Prisma.XOR<
		Prisma.AssessmentSessionUpdateManyMutationInput,
		Prisma.AssessmentSessionUncheckedUpdateManyWithoutUserInput
	>;
};

export type AssessmentSessionScalarWhereInput = {
	AND?:
		| Prisma.AssessmentSessionScalarWhereInput
		| Prisma.AssessmentSessionScalarWhereInput[];
	OR?: Prisma.AssessmentSessionScalarWhereInput[];
	NOT?:
		| Prisma.AssessmentSessionScalarWhereInput
		| Prisma.AssessmentSessionScalarWhereInput[];
	id?: Prisma.StringFilter<"AssessmentSession"> | string;
	userId?: Prisma.StringFilter<"AssessmentSession"> | string;
	status?:
		| Prisma.EnumSessionStatusFilter<"AssessmentSession">
		| $Enums.SessionStatus;
	phase?: Prisma.IntFilter<"AssessmentSession"> | number;
	currentStep?: Prisma.IntFilter<"AssessmentSession"> | number;
	totalSteps?: Prisma.IntFilter<"AssessmentSession"> | number;
	domainScores?:
		| Prisma.StringNullableFilter<"AssessmentSession">
		| string
		| null;
	strengthScores?:
		| Prisma.StringNullableFilter<"AssessmentSession">
		| string
		| null;
	results?: Prisma.StringNullableFilter<"AssessmentSession"> | string | null;
	startedAt?: Prisma.DateTimeFilter<"AssessmentSession"> | Date | string;
	lastActivityAt?: Prisma.DateTimeFilter<"AssessmentSession"> | Date | string;
	completedAt?:
		| Prisma.DateTimeNullableFilter<"AssessmentSession">
		| Date
		| string
		| null;
	createdAt?: Prisma.DateTimeFilter<"AssessmentSession"> | Date | string;
	updatedAt?: Prisma.DateTimeFilter<"AssessmentSession"> | Date | string;
};

export type AssessmentSessionCreateWithoutAnswersInput = {
	id?: string;
	status?: $Enums.SessionStatus;
	phase?: number;
	currentStep?: number;
	totalSteps?: number;
	domainScores?: string | null;
	strengthScores?: string | null;
	results?: string | null;
	startedAt?: Date | string;
	lastActivityAt?: Date | string;
	completedAt?: Date | string | null;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	user: Prisma.UserCreateNestedOneWithoutAssessmentSessionsInput;
};

export type AssessmentSessionUncheckedCreateWithoutAnswersInput = {
	id?: string;
	userId: string;
	status?: $Enums.SessionStatus;
	phase?: number;
	currentStep?: number;
	totalSteps?: number;
	domainScores?: string | null;
	strengthScores?: string | null;
	results?: string | null;
	startedAt?: Date | string;
	lastActivityAt?: Date | string;
	completedAt?: Date | string | null;
	createdAt?: Date | string;
	updatedAt?: Date | string;
};

export type AssessmentSessionCreateOrConnectWithoutAnswersInput = {
	where: Prisma.AssessmentSessionWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.AssessmentSessionCreateWithoutAnswersInput,
		Prisma.AssessmentSessionUncheckedCreateWithoutAnswersInput
	>;
};

export type AssessmentSessionUpsertWithoutAnswersInput = {
	update: Prisma.XOR<
		Prisma.AssessmentSessionUpdateWithoutAnswersInput,
		Prisma.AssessmentSessionUncheckedUpdateWithoutAnswersInput
	>;
	create: Prisma.XOR<
		Prisma.AssessmentSessionCreateWithoutAnswersInput,
		Prisma.AssessmentSessionUncheckedCreateWithoutAnswersInput
	>;
	where?: Prisma.AssessmentSessionWhereInput;
};

export type AssessmentSessionUpdateToOneWithWhereWithoutAnswersInput = {
	where?: Prisma.AssessmentSessionWhereInput;
	data: Prisma.XOR<
		Prisma.AssessmentSessionUpdateWithoutAnswersInput,
		Prisma.AssessmentSessionUncheckedUpdateWithoutAnswersInput
	>;
};

export type AssessmentSessionUpdateWithoutAnswersInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	status?:
		| Prisma.EnumSessionStatusFieldUpdateOperationsInput
		| $Enums.SessionStatus;
	phase?: Prisma.IntFieldUpdateOperationsInput | number;
	currentStep?: Prisma.IntFieldUpdateOperationsInput | number;
	totalSteps?: Prisma.IntFieldUpdateOperationsInput | number;
	domainScores?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	strengthScores?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	results?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	startedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	lastActivityAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	completedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	user?: Prisma.UserUpdateOneRequiredWithoutAssessmentSessionsNestedInput;
};

export type AssessmentSessionUncheckedUpdateWithoutAnswersInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	userId?: Prisma.StringFieldUpdateOperationsInput | string;
	status?:
		| Prisma.EnumSessionStatusFieldUpdateOperationsInput
		| $Enums.SessionStatus;
	phase?: Prisma.IntFieldUpdateOperationsInput | number;
	currentStep?: Prisma.IntFieldUpdateOperationsInput | number;
	totalSteps?: Prisma.IntFieldUpdateOperationsInput | number;
	domainScores?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	strengthScores?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	results?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	startedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	lastActivityAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	completedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type AssessmentSessionCreateManyUserInput = {
	id?: string;
	status?: $Enums.SessionStatus;
	phase?: number;
	currentStep?: number;
	totalSteps?: number;
	domainScores?: string | null;
	strengthScores?: string | null;
	results?: string | null;
	startedAt?: Date | string;
	lastActivityAt?: Date | string;
	completedAt?: Date | string | null;
	createdAt?: Date | string;
	updatedAt?: Date | string;
};

export type AssessmentSessionUpdateWithoutUserInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	status?:
		| Prisma.EnumSessionStatusFieldUpdateOperationsInput
		| $Enums.SessionStatus;
	phase?: Prisma.IntFieldUpdateOperationsInput | number;
	currentStep?: Prisma.IntFieldUpdateOperationsInput | number;
	totalSteps?: Prisma.IntFieldUpdateOperationsInput | number;
	domainScores?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	strengthScores?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	results?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	startedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	lastActivityAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	completedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	answers?: Prisma.UserAssessmentAnswerUpdateManyWithoutSessionNestedInput;
};

export type AssessmentSessionUncheckedUpdateWithoutUserInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	status?:
		| Prisma.EnumSessionStatusFieldUpdateOperationsInput
		| $Enums.SessionStatus;
	phase?: Prisma.IntFieldUpdateOperationsInput | number;
	currentStep?: Prisma.IntFieldUpdateOperationsInput | number;
	totalSteps?: Prisma.IntFieldUpdateOperationsInput | number;
	domainScores?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	strengthScores?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	results?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	startedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	lastActivityAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	completedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	answers?: Prisma.UserAssessmentAnswerUncheckedUpdateManyWithoutSessionNestedInput;
};

export type AssessmentSessionUncheckedUpdateManyWithoutUserInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	status?:
		| Prisma.EnumSessionStatusFieldUpdateOperationsInput
		| $Enums.SessionStatus;
	phase?: Prisma.IntFieldUpdateOperationsInput | number;
	currentStep?: Prisma.IntFieldUpdateOperationsInput | number;
	totalSteps?: Prisma.IntFieldUpdateOperationsInput | number;
	domainScores?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	strengthScores?:
		| Prisma.NullableStringFieldUpdateOperationsInput
		| string
		| null;
	results?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	startedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	lastActivityAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	completedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

/**
 * Count Type AssessmentSessionCountOutputType
 */

export type AssessmentSessionCountOutputType = {
	answers: number;
};

export type AssessmentSessionCountOutputTypeSelect<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	answers?: boolean | AssessmentSessionCountOutputTypeCountAnswersArgs;
};

/**
 * AssessmentSessionCountOutputType without action
 */
export type AssessmentSessionCountOutputTypeDefaultArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the AssessmentSessionCountOutputType
	 */
	select?: Prisma.AssessmentSessionCountOutputTypeSelect<ExtArgs> | null;
};

/**
 * AssessmentSessionCountOutputType without action
 */
export type AssessmentSessionCountOutputTypeCountAnswersArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.UserAssessmentAnswerWhereInput;
};

export type AssessmentSessionSelect<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		userId?: boolean;
		status?: boolean;
		phase?: boolean;
		currentStep?: boolean;
		totalSteps?: boolean;
		domainScores?: boolean;
		strengthScores?: boolean;
		results?: boolean;
		startedAt?: boolean;
		lastActivityAt?: boolean;
		completedAt?: boolean;
		createdAt?: boolean;
		updatedAt?: boolean;
		user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
		answers?: boolean | Prisma.AssessmentSession$answersArgs<ExtArgs>;
		_count?:
			| boolean
			| Prisma.AssessmentSessionCountOutputTypeDefaultArgs<ExtArgs>;
	},
	ExtArgs["result"]["assessmentSession"]
>;

export type AssessmentSessionSelectCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		userId?: boolean;
		status?: boolean;
		phase?: boolean;
		currentStep?: boolean;
		totalSteps?: boolean;
		domainScores?: boolean;
		strengthScores?: boolean;
		results?: boolean;
		startedAt?: boolean;
		lastActivityAt?: boolean;
		completedAt?: boolean;
		createdAt?: boolean;
		updatedAt?: boolean;
		user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
	},
	ExtArgs["result"]["assessmentSession"]
>;

export type AssessmentSessionSelectUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		userId?: boolean;
		status?: boolean;
		phase?: boolean;
		currentStep?: boolean;
		totalSteps?: boolean;
		domainScores?: boolean;
		strengthScores?: boolean;
		results?: boolean;
		startedAt?: boolean;
		lastActivityAt?: boolean;
		completedAt?: boolean;
		createdAt?: boolean;
		updatedAt?: boolean;
		user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
	},
	ExtArgs["result"]["assessmentSession"]
>;

export type AssessmentSessionSelectScalar = {
	id?: boolean;
	userId?: boolean;
	status?: boolean;
	phase?: boolean;
	currentStep?: boolean;
	totalSteps?: boolean;
	domainScores?: boolean;
	strengthScores?: boolean;
	results?: boolean;
	startedAt?: boolean;
	lastActivityAt?: boolean;
	completedAt?: boolean;
	createdAt?: boolean;
	updatedAt?: boolean;
};

export type AssessmentSessionOmit<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
	| "id"
	| "userId"
	| "status"
	| "phase"
	| "currentStep"
	| "totalSteps"
	| "domainScores"
	| "strengthScores"
	| "results"
	| "startedAt"
	| "lastActivityAt"
	| "completedAt"
	| "createdAt"
	| "updatedAt",
	ExtArgs["result"]["assessmentSession"]
>;
export type AssessmentSessionInclude<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
	answers?: boolean | Prisma.AssessmentSession$answersArgs<ExtArgs>;
	_count?:
		| boolean
		| Prisma.AssessmentSessionCountOutputTypeDefaultArgs<ExtArgs>;
};
export type AssessmentSessionIncludeCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
};
export type AssessmentSessionIncludeUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
};

export type $AssessmentSessionPayload<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	name: "AssessmentSession";
	objects: {
		user: Prisma.$UserPayload<ExtArgs>;
		answers: Prisma.$UserAssessmentAnswerPayload<ExtArgs>[];
	};
	scalars: runtime.Types.Extensions.GetPayloadResult<
		{
			id: string;
			userId: string;
			status: $Enums.SessionStatus;
			phase: number;
			currentStep: number;
			totalSteps: number;
			domainScores: string | null;
			strengthScores: string | null;
			results: string | null;
			startedAt: Date;
			lastActivityAt: Date;
			completedAt: Date | null;
			createdAt: Date;
			updatedAt: Date;
		},
		ExtArgs["result"]["assessmentSession"]
	>;
	composites: {};
};

export type AssessmentSessionGetPayload<
	S extends boolean | null | undefined | AssessmentSessionDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$AssessmentSessionPayload, S>;

export type AssessmentSessionCountArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = Omit<
	AssessmentSessionFindManyArgs,
	"select" | "include" | "distinct" | "omit"
> & {
	select?: AssessmentSessionCountAggregateInputType | true;
};

export interface AssessmentSessionDelegate<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> {
	[K: symbol]: {
		types: Prisma.TypeMap<ExtArgs>["model"]["AssessmentSession"];
		meta: { name: "AssessmentSession" };
	};
	/**
	 * Find zero or one AssessmentSession that matches the filter.
	 * @param {AssessmentSessionFindUniqueArgs} args - Arguments to find a AssessmentSession
	 * @example
	 * // Get one AssessmentSession
	 * const assessmentSession = await prisma.assessmentSession.findUnique({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUnique<T extends AssessmentSessionFindUniqueArgs>(
		args: Prisma.SelectSubset<T, AssessmentSessionFindUniqueArgs<ExtArgs>>,
	): Prisma.Prisma__AssessmentSessionClient<
		runtime.Types.Result.GetResult<
			Prisma.$AssessmentSessionPayload<ExtArgs>,
			T,
			"findUnique",
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find one AssessmentSession that matches the filter or throw an error with `error.code='P2025'`
	 * if no matches were found.
	 * @param {AssessmentSessionFindUniqueOrThrowArgs} args - Arguments to find a AssessmentSession
	 * @example
	 * // Get one AssessmentSession
	 * const assessmentSession = await prisma.assessmentSession.findUniqueOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUniqueOrThrow<T extends AssessmentSessionFindUniqueOrThrowArgs>(
		args: Prisma.SelectSubset<
			T,
			AssessmentSessionFindUniqueOrThrowArgs<ExtArgs>
		>,
	): Prisma.Prisma__AssessmentSessionClient<
		runtime.Types.Result.GetResult<
			Prisma.$AssessmentSessionPayload<ExtArgs>,
			T,
			"findUniqueOrThrow",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first AssessmentSession that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {AssessmentSessionFindFirstArgs} args - Arguments to find a AssessmentSession
	 * @example
	 * // Get one AssessmentSession
	 * const assessmentSession = await prisma.assessmentSession.findFirst({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirst<T extends AssessmentSessionFindFirstArgs>(
		args?: Prisma.SelectSubset<T, AssessmentSessionFindFirstArgs<ExtArgs>>,
	): Prisma.Prisma__AssessmentSessionClient<
		runtime.Types.Result.GetResult<
			Prisma.$AssessmentSessionPayload<ExtArgs>,
			T,
			"findFirst",
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first AssessmentSession that matches the filter or
	 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {AssessmentSessionFindFirstOrThrowArgs} args - Arguments to find a AssessmentSession
	 * @example
	 * // Get one AssessmentSession
	 * const assessmentSession = await prisma.assessmentSession.findFirstOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirstOrThrow<T extends AssessmentSessionFindFirstOrThrowArgs>(
		args?: Prisma.SelectSubset<
			T,
			AssessmentSessionFindFirstOrThrowArgs<ExtArgs>
		>,
	): Prisma.Prisma__AssessmentSessionClient<
		runtime.Types.Result.GetResult<
			Prisma.$AssessmentSessionPayload<ExtArgs>,
			T,
			"findFirstOrThrow",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find zero or more AssessmentSessions that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {AssessmentSessionFindManyArgs} args - Arguments to filter and select certain fields only.
	 * @example
	 * // Get all AssessmentSessions
	 * const assessmentSessions = await prisma.assessmentSession.findMany()
	 *
	 * // Get first 10 AssessmentSessions
	 * const assessmentSessions = await prisma.assessmentSession.findMany({ take: 10 })
	 *
	 * // Only select the `id`
	 * const assessmentSessionWithIdOnly = await prisma.assessmentSession.findMany({ select: { id: true } })
	 *
	 */
	findMany<T extends AssessmentSessionFindManyArgs>(
		args?: Prisma.SelectSubset<T, AssessmentSessionFindManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$AssessmentSessionPayload<ExtArgs>,
			T,
			"findMany",
			GlobalOmitOptions
		>
	>;

	/**
	 * Create a AssessmentSession.
	 * @param {AssessmentSessionCreateArgs} args - Arguments to create a AssessmentSession.
	 * @example
	 * // Create one AssessmentSession
	 * const AssessmentSession = await prisma.assessmentSession.create({
	 *   data: {
	 *     // ... data to create a AssessmentSession
	 *   }
	 * })
	 *
	 */
	create<T extends AssessmentSessionCreateArgs>(
		args: Prisma.SelectSubset<T, AssessmentSessionCreateArgs<ExtArgs>>,
	): Prisma.Prisma__AssessmentSessionClient<
		runtime.Types.Result.GetResult<
			Prisma.$AssessmentSessionPayload<ExtArgs>,
			T,
			"create",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Create many AssessmentSessions.
	 * @param {AssessmentSessionCreateManyArgs} args - Arguments to create many AssessmentSessions.
	 * @example
	 * // Create many AssessmentSessions
	 * const assessmentSession = await prisma.assessmentSession.createMany({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 */
	createMany<T extends AssessmentSessionCreateManyArgs>(
		args?: Prisma.SelectSubset<T, AssessmentSessionCreateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Create many AssessmentSessions and returns the data saved in the database.
	 * @param {AssessmentSessionCreateManyAndReturnArgs} args - Arguments to create many AssessmentSessions.
	 * @example
	 * // Create many AssessmentSessions
	 * const assessmentSession = await prisma.assessmentSession.createManyAndReturn({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Create many AssessmentSessions and only return the `id`
	 * const assessmentSessionWithIdOnly = await prisma.assessmentSession.createManyAndReturn({
	 *   select: { id: true },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 *
	 */
	createManyAndReturn<T extends AssessmentSessionCreateManyAndReturnArgs>(
		args?: Prisma.SelectSubset<
			T,
			AssessmentSessionCreateManyAndReturnArgs<ExtArgs>
		>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$AssessmentSessionPayload<ExtArgs>,
			T,
			"createManyAndReturn",
			GlobalOmitOptions
		>
	>;

	/**
	 * Delete a AssessmentSession.
	 * @param {AssessmentSessionDeleteArgs} args - Arguments to delete one AssessmentSession.
	 * @example
	 * // Delete one AssessmentSession
	 * const AssessmentSession = await prisma.assessmentSession.delete({
	 *   where: {
	 *     // ... filter to delete one AssessmentSession
	 *   }
	 * })
	 *
	 */
	delete<T extends AssessmentSessionDeleteArgs>(
		args: Prisma.SelectSubset<T, AssessmentSessionDeleteArgs<ExtArgs>>,
	): Prisma.Prisma__AssessmentSessionClient<
		runtime.Types.Result.GetResult<
			Prisma.$AssessmentSessionPayload<ExtArgs>,
			T,
			"delete",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Update one AssessmentSession.
	 * @param {AssessmentSessionUpdateArgs} args - Arguments to update one AssessmentSession.
	 * @example
	 * // Update one AssessmentSession
	 * const assessmentSession = await prisma.assessmentSession.update({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	update<T extends AssessmentSessionUpdateArgs>(
		args: Prisma.SelectSubset<T, AssessmentSessionUpdateArgs<ExtArgs>>,
	): Prisma.Prisma__AssessmentSessionClient<
		runtime.Types.Result.GetResult<
			Prisma.$AssessmentSessionPayload<ExtArgs>,
			T,
			"update",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Delete zero or more AssessmentSessions.
	 * @param {AssessmentSessionDeleteManyArgs} args - Arguments to filter AssessmentSessions to delete.
	 * @example
	 * // Delete a few AssessmentSessions
	 * const { count } = await prisma.assessmentSession.deleteMany({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 *
	 */
	deleteMany<T extends AssessmentSessionDeleteManyArgs>(
		args?: Prisma.SelectSubset<T, AssessmentSessionDeleteManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Update zero or more AssessmentSessions.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {AssessmentSessionUpdateManyArgs} args - Arguments to update one or more rows.
	 * @example
	 * // Update many AssessmentSessions
	 * const assessmentSession = await prisma.assessmentSession.updateMany({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	updateMany<T extends AssessmentSessionUpdateManyArgs>(
		args: Prisma.SelectSubset<T, AssessmentSessionUpdateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Update zero or more AssessmentSessions and returns the data updated in the database.
	 * @param {AssessmentSessionUpdateManyAndReturnArgs} args - Arguments to update many AssessmentSessions.
	 * @example
	 * // Update many AssessmentSessions
	 * const assessmentSession = await prisma.assessmentSession.updateManyAndReturn({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Update zero or more AssessmentSessions and only return the `id`
	 * const assessmentSessionWithIdOnly = await prisma.assessmentSession.updateManyAndReturn({
	 *   select: { id: true },
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 *
	 */
	updateManyAndReturn<T extends AssessmentSessionUpdateManyAndReturnArgs>(
		args: Prisma.SelectSubset<
			T,
			AssessmentSessionUpdateManyAndReturnArgs<ExtArgs>
		>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$AssessmentSessionPayload<ExtArgs>,
			T,
			"updateManyAndReturn",
			GlobalOmitOptions
		>
	>;

	/**
	 * Create or update one AssessmentSession.
	 * @param {AssessmentSessionUpsertArgs} args - Arguments to update or create a AssessmentSession.
	 * @example
	 * // Update or create a AssessmentSession
	 * const assessmentSession = await prisma.assessmentSession.upsert({
	 *   create: {
	 *     // ... data to create a AssessmentSession
	 *   },
	 *   update: {
	 *     // ... in case it already exists, update
	 *   },
	 *   where: {
	 *     // ... the filter for the AssessmentSession we want to update
	 *   }
	 * })
	 */
	upsert<T extends AssessmentSessionUpsertArgs>(
		args: Prisma.SelectSubset<T, AssessmentSessionUpsertArgs<ExtArgs>>,
	): Prisma.Prisma__AssessmentSessionClient<
		runtime.Types.Result.GetResult<
			Prisma.$AssessmentSessionPayload<ExtArgs>,
			T,
			"upsert",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Count the number of AssessmentSessions.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {AssessmentSessionCountArgs} args - Arguments to filter AssessmentSessions to count.
	 * @example
	 * // Count the number of AssessmentSessions
	 * const count = await prisma.assessmentSession.count({
	 *   where: {
	 *     // ... the filter for the AssessmentSessions we want to count
	 *   }
	 * })
	 **/
	count<T extends AssessmentSessionCountArgs>(
		args?: Prisma.Subset<T, AssessmentSessionCountArgs>,
	): Prisma.PrismaPromise<
		T extends runtime.Types.Utils.Record<"select", any>
			? T["select"] extends true
				? number
				: Prisma.GetScalarType<
						T["select"],
						AssessmentSessionCountAggregateOutputType
					>
			: number
	>;

	/**
	 * Allows you to perform aggregations operations on a AssessmentSession.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {AssessmentSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
	 * @example
	 * // Ordered by age ascending
	 * // Where email contains prisma.io
	 * // Limited to the 10 users
	 * const aggregations = await prisma.user.aggregate({
	 *   _avg: {
	 *     age: true,
	 *   },
	 *   where: {
	 *     email: {
	 *       contains: "prisma.io",
	 *     },
	 *   },
	 *   orderBy: {
	 *     age: "asc",
	 *   },
	 *   take: 10,
	 * })
	 **/
	aggregate<T extends AssessmentSessionAggregateArgs>(
		args: Prisma.Subset<T, AssessmentSessionAggregateArgs>,
	): Prisma.PrismaPromise<GetAssessmentSessionAggregateType<T>>;

	/**
	 * Group by AssessmentSession.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {AssessmentSessionGroupByArgs} args - Group by arguments.
	 * @example
	 * // Group by city, order by createdAt, get count
	 * const result = await prisma.user.groupBy({
	 *   by: ['city', 'createdAt'],
	 *   orderBy: {
	 *     createdAt: true
	 *   },
	 *   _count: {
	 *     _all: true
	 *   },
	 * })
	 *
	 **/
	groupBy<
		T extends AssessmentSessionGroupByArgs,
		HasSelectOrTake extends Prisma.Or<
			Prisma.Extends<"skip", Prisma.Keys<T>>,
			Prisma.Extends<"take", Prisma.Keys<T>>
		>,
		OrderByArg extends Prisma.True extends HasSelectOrTake
			? { orderBy: AssessmentSessionGroupByArgs["orderBy"] }
			: { orderBy?: AssessmentSessionGroupByArgs["orderBy"] },
		OrderFields extends Prisma.ExcludeUnderscoreKeys<
			Prisma.Keys<Prisma.MaybeTupleToUnion<T["orderBy"]>>
		>,
		ByFields extends Prisma.MaybeTupleToUnion<T["by"]>,
		ByValid extends Prisma.Has<ByFields, OrderFields>,
		HavingFields extends Prisma.GetHavingFields<T["having"]>,
		HavingValid extends Prisma.Has<ByFields, HavingFields>,
		ByEmpty extends T["by"] extends never[] ? Prisma.True : Prisma.False,
		InputErrors extends ByEmpty extends Prisma.True
			? `Error: "by" must not be empty.`
			: HavingValid extends Prisma.False
				? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
										Error,
										"Field ",
										P,
										` in "having" needs to be provided in "by"`,
									];
					}[HavingFields]
				: "take" extends Prisma.Keys<T>
					? "orderBy" extends Prisma.Keys<T>
						? ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields]
						: 'Error: If you provide "take", you also need to provide "orderBy"'
					: "skip" extends Prisma.Keys<T>
						? "orderBy" extends Prisma.Keys<T>
							? ByValid extends Prisma.True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
									}[OrderFields]
							: 'Error: If you provide "skip", you also need to provide "orderBy"'
						: ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields],
	>(
		args: Prisma.SubsetIntersection<
			T,
			AssessmentSessionGroupByArgs,
			OrderByArg
		> &
			InputErrors,
	): {} extends InputErrors
		? GetAssessmentSessionGroupByPayload<T>
		: Prisma.PrismaPromise<InputErrors>;
	/**
	 * Fields of the AssessmentSession model
	 */
	readonly fields: AssessmentSessionFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for AssessmentSession.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__AssessmentSessionClient<
	T,
	Null = never,
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
	readonly [Symbol.toStringTag]: "PrismaPromise";
	user<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>,
	): Prisma.Prisma__UserClient<
		| runtime.Types.Result.GetResult<
				Prisma.$UserPayload<ExtArgs>,
				T,
				"findUniqueOrThrow",
				GlobalOmitOptions
		  >
		| Null,
		Null,
		ExtArgs,
		GlobalOmitOptions
	>;
	answers<T extends Prisma.AssessmentSession$answersArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.AssessmentSession$answersArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$UserAssessmentAnswerPayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	/**
	 * Attaches callbacks for the resolution and/or rejection of the Promise.
	 * @param onfulfilled The callback to execute when the Promise is resolved.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of which ever callback is executed.
	 */
	then<TResult1 = T, TResult2 = never>(
		onfulfilled?:
			| ((value: T) => TResult1 | PromiseLike<TResult1>)
			| undefined
			| null,
		onrejected?:
			| ((reason: any) => TResult2 | PromiseLike<TResult2>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
	/**
	 * Attaches a callback for only the rejection of the Promise.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of the callback.
	 */
	catch<TResult = never>(
		onrejected?:
			| ((reason: any) => TResult | PromiseLike<TResult>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<T | TResult>;
	/**
	 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
	 * resolved value cannot be modified from the callback.
	 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
	 * @returns A Promise for the completion of the callback.
	 */
	finally(
		onfinally?: (() => void) | undefined | null,
	): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the AssessmentSession model
 */
export interface AssessmentSessionFieldRefs {
	readonly id: Prisma.FieldRef<"AssessmentSession", "String">;
	readonly userId: Prisma.FieldRef<"AssessmentSession", "String">;
	readonly status: Prisma.FieldRef<"AssessmentSession", "SessionStatus">;
	readonly phase: Prisma.FieldRef<"AssessmentSession", "Int">;
	readonly currentStep: Prisma.FieldRef<"AssessmentSession", "Int">;
	readonly totalSteps: Prisma.FieldRef<"AssessmentSession", "Int">;
	readonly domainScores: Prisma.FieldRef<"AssessmentSession", "String">;
	readonly strengthScores: Prisma.FieldRef<"AssessmentSession", "String">;
	readonly results: Prisma.FieldRef<"AssessmentSession", "String">;
	readonly startedAt: Prisma.FieldRef<"AssessmentSession", "DateTime">;
	readonly lastActivityAt: Prisma.FieldRef<"AssessmentSession", "DateTime">;
	readonly completedAt: Prisma.FieldRef<"AssessmentSession", "DateTime">;
	readonly createdAt: Prisma.FieldRef<"AssessmentSession", "DateTime">;
	readonly updatedAt: Prisma.FieldRef<"AssessmentSession", "DateTime">;
}

// Custom InputTypes
/**
 * AssessmentSession findUnique
 */
export type AssessmentSessionFindUniqueArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the AssessmentSession
	 */
	select?: Prisma.AssessmentSessionSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the AssessmentSession
	 */
	omit?: Prisma.AssessmentSessionOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AssessmentSessionInclude<ExtArgs> | null;
	/**
	 * Filter, which AssessmentSession to fetch.
	 */
	where: Prisma.AssessmentSessionWhereUniqueInput;
};

/**
 * AssessmentSession findUniqueOrThrow
 */
export type AssessmentSessionFindUniqueOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the AssessmentSession
	 */
	select?: Prisma.AssessmentSessionSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the AssessmentSession
	 */
	omit?: Prisma.AssessmentSessionOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AssessmentSessionInclude<ExtArgs> | null;
	/**
	 * Filter, which AssessmentSession to fetch.
	 */
	where: Prisma.AssessmentSessionWhereUniqueInput;
};

/**
 * AssessmentSession findFirst
 */
export type AssessmentSessionFindFirstArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the AssessmentSession
	 */
	select?: Prisma.AssessmentSessionSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the AssessmentSession
	 */
	omit?: Prisma.AssessmentSessionOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AssessmentSessionInclude<ExtArgs> | null;
	/**
	 * Filter, which AssessmentSession to fetch.
	 */
	where?: Prisma.AssessmentSessionWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of AssessmentSessions to fetch.
	 */
	orderBy?:
		| Prisma.AssessmentSessionOrderByWithRelationInput
		| Prisma.AssessmentSessionOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for AssessmentSessions.
	 */
	cursor?: Prisma.AssessmentSessionWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` AssessmentSessions from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` AssessmentSessions.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of AssessmentSessions.
	 */
	distinct?:
		| Prisma.AssessmentSessionScalarFieldEnum
		| Prisma.AssessmentSessionScalarFieldEnum[];
};

/**
 * AssessmentSession findFirstOrThrow
 */
export type AssessmentSessionFindFirstOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the AssessmentSession
	 */
	select?: Prisma.AssessmentSessionSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the AssessmentSession
	 */
	omit?: Prisma.AssessmentSessionOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AssessmentSessionInclude<ExtArgs> | null;
	/**
	 * Filter, which AssessmentSession to fetch.
	 */
	where?: Prisma.AssessmentSessionWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of AssessmentSessions to fetch.
	 */
	orderBy?:
		| Prisma.AssessmentSessionOrderByWithRelationInput
		| Prisma.AssessmentSessionOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for AssessmentSessions.
	 */
	cursor?: Prisma.AssessmentSessionWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` AssessmentSessions from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` AssessmentSessions.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of AssessmentSessions.
	 */
	distinct?:
		| Prisma.AssessmentSessionScalarFieldEnum
		| Prisma.AssessmentSessionScalarFieldEnum[];
};

/**
 * AssessmentSession findMany
 */
export type AssessmentSessionFindManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the AssessmentSession
	 */
	select?: Prisma.AssessmentSessionSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the AssessmentSession
	 */
	omit?: Prisma.AssessmentSessionOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AssessmentSessionInclude<ExtArgs> | null;
	/**
	 * Filter, which AssessmentSessions to fetch.
	 */
	where?: Prisma.AssessmentSessionWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of AssessmentSessions to fetch.
	 */
	orderBy?:
		| Prisma.AssessmentSessionOrderByWithRelationInput
		| Prisma.AssessmentSessionOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for listing AssessmentSessions.
	 */
	cursor?: Prisma.AssessmentSessionWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` AssessmentSessions from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` AssessmentSessions.
	 */
	skip?: number;
	distinct?:
		| Prisma.AssessmentSessionScalarFieldEnum
		| Prisma.AssessmentSessionScalarFieldEnum[];
};

/**
 * AssessmentSession create
 */
export type AssessmentSessionCreateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the AssessmentSession
	 */
	select?: Prisma.AssessmentSessionSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the AssessmentSession
	 */
	omit?: Prisma.AssessmentSessionOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AssessmentSessionInclude<ExtArgs> | null;
	/**
	 * The data needed to create a AssessmentSession.
	 */
	data: Prisma.XOR<
		Prisma.AssessmentSessionCreateInput,
		Prisma.AssessmentSessionUncheckedCreateInput
	>;
};

/**
 * AssessmentSession createMany
 */
export type AssessmentSessionCreateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to create many AssessmentSessions.
	 */
	data:
		| Prisma.AssessmentSessionCreateManyInput
		| Prisma.AssessmentSessionCreateManyInput[];
};

/**
 * AssessmentSession createManyAndReturn
 */
export type AssessmentSessionCreateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the AssessmentSession
	 */
	select?: Prisma.AssessmentSessionSelectCreateManyAndReturn<ExtArgs> | null;
	/**
	 * Omit specific fields from the AssessmentSession
	 */
	omit?: Prisma.AssessmentSessionOmit<ExtArgs> | null;
	/**
	 * The data used to create many AssessmentSessions.
	 */
	data:
		| Prisma.AssessmentSessionCreateManyInput
		| Prisma.AssessmentSessionCreateManyInput[];
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AssessmentSessionIncludeCreateManyAndReturn<ExtArgs> | null;
};

/**
 * AssessmentSession update
 */
export type AssessmentSessionUpdateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the AssessmentSession
	 */
	select?: Prisma.AssessmentSessionSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the AssessmentSession
	 */
	omit?: Prisma.AssessmentSessionOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AssessmentSessionInclude<ExtArgs> | null;
	/**
	 * The data needed to update a AssessmentSession.
	 */
	data: Prisma.XOR<
		Prisma.AssessmentSessionUpdateInput,
		Prisma.AssessmentSessionUncheckedUpdateInput
	>;
	/**
	 * Choose, which AssessmentSession to update.
	 */
	where: Prisma.AssessmentSessionWhereUniqueInput;
};

/**
 * AssessmentSession updateMany
 */
export type AssessmentSessionUpdateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to update AssessmentSessions.
	 */
	data: Prisma.XOR<
		Prisma.AssessmentSessionUpdateManyMutationInput,
		Prisma.AssessmentSessionUncheckedUpdateManyInput
	>;
	/**
	 * Filter which AssessmentSessions to update
	 */
	where?: Prisma.AssessmentSessionWhereInput;
	/**
	 * Limit how many AssessmentSessions to update.
	 */
	limit?: number;
};

/**
 * AssessmentSession updateManyAndReturn
 */
export type AssessmentSessionUpdateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the AssessmentSession
	 */
	select?: Prisma.AssessmentSessionSelectUpdateManyAndReturn<ExtArgs> | null;
	/**
	 * Omit specific fields from the AssessmentSession
	 */
	omit?: Prisma.AssessmentSessionOmit<ExtArgs> | null;
	/**
	 * The data used to update AssessmentSessions.
	 */
	data: Prisma.XOR<
		Prisma.AssessmentSessionUpdateManyMutationInput,
		Prisma.AssessmentSessionUncheckedUpdateManyInput
	>;
	/**
	 * Filter which AssessmentSessions to update
	 */
	where?: Prisma.AssessmentSessionWhereInput;
	/**
	 * Limit how many AssessmentSessions to update.
	 */
	limit?: number;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AssessmentSessionIncludeUpdateManyAndReturn<ExtArgs> | null;
};

/**
 * AssessmentSession upsert
 */
export type AssessmentSessionUpsertArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the AssessmentSession
	 */
	select?: Prisma.AssessmentSessionSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the AssessmentSession
	 */
	omit?: Prisma.AssessmentSessionOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AssessmentSessionInclude<ExtArgs> | null;
	/**
	 * The filter to search for the AssessmentSession to update in case it exists.
	 */
	where: Prisma.AssessmentSessionWhereUniqueInput;
	/**
	 * In case the AssessmentSession found by the `where` argument doesn't exist, create a new AssessmentSession with this data.
	 */
	create: Prisma.XOR<
		Prisma.AssessmentSessionCreateInput,
		Prisma.AssessmentSessionUncheckedCreateInput
	>;
	/**
	 * In case the AssessmentSession was found with the provided `where` argument, update it with this data.
	 */
	update: Prisma.XOR<
		Prisma.AssessmentSessionUpdateInput,
		Prisma.AssessmentSessionUncheckedUpdateInput
	>;
};

/**
 * AssessmentSession delete
 */
export type AssessmentSessionDeleteArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the AssessmentSession
	 */
	select?: Prisma.AssessmentSessionSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the AssessmentSession
	 */
	omit?: Prisma.AssessmentSessionOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AssessmentSessionInclude<ExtArgs> | null;
	/**
	 * Filter which AssessmentSession to delete.
	 */
	where: Prisma.AssessmentSessionWhereUniqueInput;
};

/**
 * AssessmentSession deleteMany
 */
export type AssessmentSessionDeleteManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which AssessmentSessions to delete
	 */
	where?: Prisma.AssessmentSessionWhereInput;
	/**
	 * Limit how many AssessmentSessions to delete.
	 */
	limit?: number;
};

/**
 * AssessmentSession.answers
 */
export type AssessmentSession$answersArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the UserAssessmentAnswer
	 */
	select?: Prisma.UserAssessmentAnswerSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the UserAssessmentAnswer
	 */
	omit?: Prisma.UserAssessmentAnswerOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.UserAssessmentAnswerInclude<ExtArgs> | null;
	where?: Prisma.UserAssessmentAnswerWhereInput;
	orderBy?:
		| Prisma.UserAssessmentAnswerOrderByWithRelationInput
		| Prisma.UserAssessmentAnswerOrderByWithRelationInput[];
	cursor?: Prisma.UserAssessmentAnswerWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?:
		| Prisma.UserAssessmentAnswerScalarFieldEnum
		| Prisma.UserAssessmentAnswerScalarFieldEnum[];
};

/**
 * AssessmentSession without action
 */
export type AssessmentSessionDefaultArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the AssessmentSession
	 */
	select?: Prisma.AssessmentSessionSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the AssessmentSession
	 */
	omit?: Prisma.AssessmentSessionOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AssessmentSessionInclude<ExtArgs> | null;
};
