/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports the `CollaborativeChallenge` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client";
import type * as $Enums from "../enums";
import type * as Prisma from "../internal/prismaNamespace";

/**
 * Model CollaborativeChallenge
 *
 */
export type CollaborativeChallengeModel =
	runtime.Types.Result.DefaultSelection<Prisma.$CollaborativeChallengePayload>;

export type AggregateCollaborativeChallenge = {
	_count: CollaborativeChallengeCountAggregateOutputType | null;
	_avg: CollaborativeChallengeAvgAggregateOutputType | null;
	_sum: CollaborativeChallengeSumAggregateOutputType | null;
	_min: CollaborativeChallengeMinAggregateOutputType | null;
	_max: CollaborativeChallengeMaxAggregateOutputType | null;
};

export type CollaborativeChallengeAvgAggregateOutputType = {
	xpBonusAwarded: number | null;
};

export type CollaborativeChallengeSumAggregateOutputType = {
	xpBonusAwarded: number | null;
};

export type CollaborativeChallengeMinAggregateOutputType = {
	id: string | null;
	challengeId: string | null;
	initiatorUserId: string | null;
	partnerUserId: string | null;
	initiatorCompleted: boolean | null;
	partnerCompleted: boolean | null;
	initiatorCompletedAt: Date | null;
	partnerCompletedAt: Date | null;
	xpBonusAwarded: number | null;
	status: string | null;
	expiresAt: Date | null;
	createdAt: Date | null;
	updatedAt: Date | null;
};

export type CollaborativeChallengeMaxAggregateOutputType = {
	id: string | null;
	challengeId: string | null;
	initiatorUserId: string | null;
	partnerUserId: string | null;
	initiatorCompleted: boolean | null;
	partnerCompleted: boolean | null;
	initiatorCompletedAt: Date | null;
	partnerCompletedAt: Date | null;
	xpBonusAwarded: number | null;
	status: string | null;
	expiresAt: Date | null;
	createdAt: Date | null;
	updatedAt: Date | null;
};

export type CollaborativeChallengeCountAggregateOutputType = {
	id: number;
	challengeId: number;
	initiatorUserId: number;
	partnerUserId: number;
	initiatorCompleted: number;
	partnerCompleted: number;
	initiatorCompletedAt: number;
	partnerCompletedAt: number;
	xpBonusAwarded: number;
	status: number;
	expiresAt: number;
	createdAt: number;
	updatedAt: number;
	_all: number;
};

export type CollaborativeChallengeAvgAggregateInputType = {
	xpBonusAwarded?: true;
};

export type CollaborativeChallengeSumAggregateInputType = {
	xpBonusAwarded?: true;
};

export type CollaborativeChallengeMinAggregateInputType = {
	id?: true;
	challengeId?: true;
	initiatorUserId?: true;
	partnerUserId?: true;
	initiatorCompleted?: true;
	partnerCompleted?: true;
	initiatorCompletedAt?: true;
	partnerCompletedAt?: true;
	xpBonusAwarded?: true;
	status?: true;
	expiresAt?: true;
	createdAt?: true;
	updatedAt?: true;
};

export type CollaborativeChallengeMaxAggregateInputType = {
	id?: true;
	challengeId?: true;
	initiatorUserId?: true;
	partnerUserId?: true;
	initiatorCompleted?: true;
	partnerCompleted?: true;
	initiatorCompletedAt?: true;
	partnerCompletedAt?: true;
	xpBonusAwarded?: true;
	status?: true;
	expiresAt?: true;
	createdAt?: true;
	updatedAt?: true;
};

export type CollaborativeChallengeCountAggregateInputType = {
	id?: true;
	challengeId?: true;
	initiatorUserId?: true;
	partnerUserId?: true;
	initiatorCompleted?: true;
	partnerCompleted?: true;
	initiatorCompletedAt?: true;
	partnerCompletedAt?: true;
	xpBonusAwarded?: true;
	status?: true;
	expiresAt?: true;
	createdAt?: true;
	updatedAt?: true;
	_all?: true;
};

export type CollaborativeChallengeAggregateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which CollaborativeChallenge to aggregate.
	 */
	where?: Prisma.CollaborativeChallengeWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of CollaborativeChallenges to fetch.
	 */
	orderBy?:
		| Prisma.CollaborativeChallengeOrderByWithRelationInput
		| Prisma.CollaborativeChallengeOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the start position
	 */
	cursor?: Prisma.CollaborativeChallengeWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` CollaborativeChallenges from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` CollaborativeChallenges.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Count returned CollaborativeChallenges
	 **/
	_count?: true | CollaborativeChallengeCountAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to average
	 **/
	_avg?: CollaborativeChallengeAvgAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to sum
	 **/
	_sum?: CollaborativeChallengeSumAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the minimum value
	 **/
	_min?: CollaborativeChallengeMinAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the maximum value
	 **/
	_max?: CollaborativeChallengeMaxAggregateInputType;
};

export type GetCollaborativeChallengeAggregateType<
	T extends CollaborativeChallengeAggregateArgs,
> = {
	[P in keyof T & keyof AggregateCollaborativeChallenge]: P extends
		| "_count"
		| "count"
		? T[P] extends true
			? number
			: Prisma.GetScalarType<T[P], AggregateCollaborativeChallenge[P]>
		: Prisma.GetScalarType<T[P], AggregateCollaborativeChallenge[P]>;
};

export type CollaborativeChallengeGroupByArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.CollaborativeChallengeWhereInput;
	orderBy?:
		| Prisma.CollaborativeChallengeOrderByWithAggregationInput
		| Prisma.CollaborativeChallengeOrderByWithAggregationInput[];
	by:
		| Prisma.CollaborativeChallengeScalarFieldEnum[]
		| Prisma.CollaborativeChallengeScalarFieldEnum;
	having?: Prisma.CollaborativeChallengeScalarWhereWithAggregatesInput;
	take?: number;
	skip?: number;
	_count?: CollaborativeChallengeCountAggregateInputType | true;
	_avg?: CollaborativeChallengeAvgAggregateInputType;
	_sum?: CollaborativeChallengeSumAggregateInputType;
	_min?: CollaborativeChallengeMinAggregateInputType;
	_max?: CollaborativeChallengeMaxAggregateInputType;
};

export type CollaborativeChallengeGroupByOutputType = {
	id: string;
	challengeId: string;
	initiatorUserId: string;
	partnerUserId: string;
	initiatorCompleted: boolean;
	partnerCompleted: boolean;
	initiatorCompletedAt: Date | null;
	partnerCompletedAt: Date | null;
	xpBonusAwarded: number | null;
	status: string;
	expiresAt: Date;
	createdAt: Date;
	updatedAt: Date;
	_count: CollaborativeChallengeCountAggregateOutputType | null;
	_avg: CollaborativeChallengeAvgAggregateOutputType | null;
	_sum: CollaborativeChallengeSumAggregateOutputType | null;
	_min: CollaborativeChallengeMinAggregateOutputType | null;
	_max: CollaborativeChallengeMaxAggregateOutputType | null;
};

type GetCollaborativeChallengeGroupByPayload<
	T extends CollaborativeChallengeGroupByArgs,
> = Prisma.PrismaPromise<
	Array<
		Prisma.PickEnumerable<CollaborativeChallengeGroupByOutputType, T["by"]> & {
			[P in keyof T &
				keyof CollaborativeChallengeGroupByOutputType]: P extends "_count"
				? T[P] extends boolean
					? number
					: Prisma.GetScalarType<
							T[P],
							CollaborativeChallengeGroupByOutputType[P]
						>
				: Prisma.GetScalarType<
						T[P],
						CollaborativeChallengeGroupByOutputType[P]
					>;
		}
	>
>;

export type CollaborativeChallengeWhereInput = {
	AND?:
		| Prisma.CollaborativeChallengeWhereInput
		| Prisma.CollaborativeChallengeWhereInput[];
	OR?: Prisma.CollaborativeChallengeWhereInput[];
	NOT?:
		| Prisma.CollaborativeChallengeWhereInput
		| Prisma.CollaborativeChallengeWhereInput[];
	id?: Prisma.StringFilter<"CollaborativeChallenge"> | string;
	challengeId?: Prisma.StringFilter<"CollaborativeChallenge"> | string;
	initiatorUserId?: Prisma.StringFilter<"CollaborativeChallenge"> | string;
	partnerUserId?: Prisma.StringFilter<"CollaborativeChallenge"> | string;
	initiatorCompleted?: Prisma.BoolFilter<"CollaborativeChallenge"> | boolean;
	partnerCompleted?: Prisma.BoolFilter<"CollaborativeChallenge"> | boolean;
	initiatorCompletedAt?:
		| Prisma.DateTimeNullableFilter<"CollaborativeChallenge">
		| Date
		| string
		| null;
	partnerCompletedAt?:
		| Prisma.DateTimeNullableFilter<"CollaborativeChallenge">
		| Date
		| string
		| null;
	xpBonusAwarded?:
		| Prisma.IntNullableFilter<"CollaborativeChallenge">
		| number
		| null;
	status?: Prisma.StringFilter<"CollaborativeChallenge"> | string;
	expiresAt?: Prisma.DateTimeFilter<"CollaborativeChallenge"> | Date | string;
	createdAt?: Prisma.DateTimeFilter<"CollaborativeChallenge"> | Date | string;
	updatedAt?: Prisma.DateTimeFilter<"CollaborativeChallenge"> | Date | string;
	challenge?: Prisma.XOR<
		Prisma.ChallengeScalarRelationFilter,
		Prisma.ChallengeWhereInput
	>;
	initiatorUser?: Prisma.XOR<
		Prisma.UserScalarRelationFilter,
		Prisma.UserWhereInput
	>;
	partnerUser?: Prisma.XOR<
		Prisma.UserScalarRelationFilter,
		Prisma.UserWhereInput
	>;
};

export type CollaborativeChallengeOrderByWithRelationInput = {
	id?: Prisma.SortOrder;
	challengeId?: Prisma.SortOrder;
	initiatorUserId?: Prisma.SortOrder;
	partnerUserId?: Prisma.SortOrder;
	initiatorCompleted?: Prisma.SortOrder;
	partnerCompleted?: Prisma.SortOrder;
	initiatorCompletedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
	partnerCompletedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
	xpBonusAwarded?: Prisma.SortOrderInput | Prisma.SortOrder;
	status?: Prisma.SortOrder;
	expiresAt?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	challenge?: Prisma.ChallengeOrderByWithRelationInput;
	initiatorUser?: Prisma.UserOrderByWithRelationInput;
	partnerUser?: Prisma.UserOrderByWithRelationInput;
};

export type CollaborativeChallengeWhereUniqueInput = Prisma.AtLeast<
	{
		id?: string;
		challengeId_initiatorUserId_partnerUserId?: Prisma.CollaborativeChallengeChallengeIdInitiatorUserIdPartnerUserIdCompoundUniqueInput;
		AND?:
			| Prisma.CollaborativeChallengeWhereInput
			| Prisma.CollaborativeChallengeWhereInput[];
		OR?: Prisma.CollaborativeChallengeWhereInput[];
		NOT?:
			| Prisma.CollaborativeChallengeWhereInput
			| Prisma.CollaborativeChallengeWhereInput[];
		challengeId?: Prisma.StringFilter<"CollaborativeChallenge"> | string;
		initiatorUserId?: Prisma.StringFilter<"CollaborativeChallenge"> | string;
		partnerUserId?: Prisma.StringFilter<"CollaborativeChallenge"> | string;
		initiatorCompleted?: Prisma.BoolFilter<"CollaborativeChallenge"> | boolean;
		partnerCompleted?: Prisma.BoolFilter<"CollaborativeChallenge"> | boolean;
		initiatorCompletedAt?:
			| Prisma.DateTimeNullableFilter<"CollaborativeChallenge">
			| Date
			| string
			| null;
		partnerCompletedAt?:
			| Prisma.DateTimeNullableFilter<"CollaborativeChallenge">
			| Date
			| string
			| null;
		xpBonusAwarded?:
			| Prisma.IntNullableFilter<"CollaborativeChallenge">
			| number
			| null;
		status?: Prisma.StringFilter<"CollaborativeChallenge"> | string;
		expiresAt?: Prisma.DateTimeFilter<"CollaborativeChallenge"> | Date | string;
		createdAt?: Prisma.DateTimeFilter<"CollaborativeChallenge"> | Date | string;
		updatedAt?: Prisma.DateTimeFilter<"CollaborativeChallenge"> | Date | string;
		challenge?: Prisma.XOR<
			Prisma.ChallengeScalarRelationFilter,
			Prisma.ChallengeWhereInput
		>;
		initiatorUser?: Prisma.XOR<
			Prisma.UserScalarRelationFilter,
			Prisma.UserWhereInput
		>;
		partnerUser?: Prisma.XOR<
			Prisma.UserScalarRelationFilter,
			Prisma.UserWhereInput
		>;
	},
	"id" | "challengeId_initiatorUserId_partnerUserId"
>;

export type CollaborativeChallengeOrderByWithAggregationInput = {
	id?: Prisma.SortOrder;
	challengeId?: Prisma.SortOrder;
	initiatorUserId?: Prisma.SortOrder;
	partnerUserId?: Prisma.SortOrder;
	initiatorCompleted?: Prisma.SortOrder;
	partnerCompleted?: Prisma.SortOrder;
	initiatorCompletedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
	partnerCompletedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
	xpBonusAwarded?: Prisma.SortOrderInput | Prisma.SortOrder;
	status?: Prisma.SortOrder;
	expiresAt?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	_count?: Prisma.CollaborativeChallengeCountOrderByAggregateInput;
	_avg?: Prisma.CollaborativeChallengeAvgOrderByAggregateInput;
	_max?: Prisma.CollaborativeChallengeMaxOrderByAggregateInput;
	_min?: Prisma.CollaborativeChallengeMinOrderByAggregateInput;
	_sum?: Prisma.CollaborativeChallengeSumOrderByAggregateInput;
};

export type CollaborativeChallengeScalarWhereWithAggregatesInput = {
	AND?:
		| Prisma.CollaborativeChallengeScalarWhereWithAggregatesInput
		| Prisma.CollaborativeChallengeScalarWhereWithAggregatesInput[];
	OR?: Prisma.CollaborativeChallengeScalarWhereWithAggregatesInput[];
	NOT?:
		| Prisma.CollaborativeChallengeScalarWhereWithAggregatesInput
		| Prisma.CollaborativeChallengeScalarWhereWithAggregatesInput[];
	id?: Prisma.StringWithAggregatesFilter<"CollaborativeChallenge"> | string;
	challengeId?:
		| Prisma.StringWithAggregatesFilter<"CollaborativeChallenge">
		| string;
	initiatorUserId?:
		| Prisma.StringWithAggregatesFilter<"CollaborativeChallenge">
		| string;
	partnerUserId?:
		| Prisma.StringWithAggregatesFilter<"CollaborativeChallenge">
		| string;
	initiatorCompleted?:
		| Prisma.BoolWithAggregatesFilter<"CollaborativeChallenge">
		| boolean;
	partnerCompleted?:
		| Prisma.BoolWithAggregatesFilter<"CollaborativeChallenge">
		| boolean;
	initiatorCompletedAt?:
		| Prisma.DateTimeNullableWithAggregatesFilter<"CollaborativeChallenge">
		| Date
		| string
		| null;
	partnerCompletedAt?:
		| Prisma.DateTimeNullableWithAggregatesFilter<"CollaborativeChallenge">
		| Date
		| string
		| null;
	xpBonusAwarded?:
		| Prisma.IntNullableWithAggregatesFilter<"CollaborativeChallenge">
		| number
		| null;
	status?: Prisma.StringWithAggregatesFilter<"CollaborativeChallenge"> | string;
	expiresAt?:
		| Prisma.DateTimeWithAggregatesFilter<"CollaborativeChallenge">
		| Date
		| string;
	createdAt?:
		| Prisma.DateTimeWithAggregatesFilter<"CollaborativeChallenge">
		| Date
		| string;
	updatedAt?:
		| Prisma.DateTimeWithAggregatesFilter<"CollaborativeChallenge">
		| Date
		| string;
};

export type CollaborativeChallengeCreateInput = {
	id?: string;
	initiatorCompleted?: boolean;
	partnerCompleted?: boolean;
	initiatorCompletedAt?: Date | string | null;
	partnerCompletedAt?: Date | string | null;
	xpBonusAwarded?: number | null;
	status?: string;
	expiresAt: Date | string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	challenge: Prisma.ChallengeCreateNestedOneWithoutCollaborativeChallengesInput;
	initiatorUser: Prisma.UserCreateNestedOneWithoutInitiatedChallengesInput;
	partnerUser: Prisma.UserCreateNestedOneWithoutPartnerChallengesInput;
};

export type CollaborativeChallengeUncheckedCreateInput = {
	id?: string;
	challengeId: string;
	initiatorUserId: string;
	partnerUserId: string;
	initiatorCompleted?: boolean;
	partnerCompleted?: boolean;
	initiatorCompletedAt?: Date | string | null;
	partnerCompletedAt?: Date | string | null;
	xpBonusAwarded?: number | null;
	status?: string;
	expiresAt: Date | string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
};

export type CollaborativeChallengeUpdateInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	initiatorCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	partnerCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	initiatorCompletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	partnerCompletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	xpBonusAwarded?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	status?: Prisma.StringFieldUpdateOperationsInput | string;
	expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	challenge?: Prisma.ChallengeUpdateOneRequiredWithoutCollaborativeChallengesNestedInput;
	initiatorUser?: Prisma.UserUpdateOneRequiredWithoutInitiatedChallengesNestedInput;
	partnerUser?: Prisma.UserUpdateOneRequiredWithoutPartnerChallengesNestedInput;
};

export type CollaborativeChallengeUncheckedUpdateInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	challengeId?: Prisma.StringFieldUpdateOperationsInput | string;
	initiatorUserId?: Prisma.StringFieldUpdateOperationsInput | string;
	partnerUserId?: Prisma.StringFieldUpdateOperationsInput | string;
	initiatorCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	partnerCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	initiatorCompletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	partnerCompletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	xpBonusAwarded?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	status?: Prisma.StringFieldUpdateOperationsInput | string;
	expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type CollaborativeChallengeCreateManyInput = {
	id?: string;
	challengeId: string;
	initiatorUserId: string;
	partnerUserId: string;
	initiatorCompleted?: boolean;
	partnerCompleted?: boolean;
	initiatorCompletedAt?: Date | string | null;
	partnerCompletedAt?: Date | string | null;
	xpBonusAwarded?: number | null;
	status?: string;
	expiresAt: Date | string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
};

export type CollaborativeChallengeUpdateManyMutationInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	initiatorCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	partnerCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	initiatorCompletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	partnerCompletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	xpBonusAwarded?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	status?: Prisma.StringFieldUpdateOperationsInput | string;
	expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type CollaborativeChallengeUncheckedUpdateManyInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	challengeId?: Prisma.StringFieldUpdateOperationsInput | string;
	initiatorUserId?: Prisma.StringFieldUpdateOperationsInput | string;
	partnerUserId?: Prisma.StringFieldUpdateOperationsInput | string;
	initiatorCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	partnerCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	initiatorCompletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	partnerCompletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	xpBonusAwarded?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	status?: Prisma.StringFieldUpdateOperationsInput | string;
	expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type CollaborativeChallengeListRelationFilter = {
	every?: Prisma.CollaborativeChallengeWhereInput;
	some?: Prisma.CollaborativeChallengeWhereInput;
	none?: Prisma.CollaborativeChallengeWhereInput;
};

export type CollaborativeChallengeOrderByRelationAggregateInput = {
	_count?: Prisma.SortOrder;
};

export type CollaborativeChallengeChallengeIdInitiatorUserIdPartnerUserIdCompoundUniqueInput =
	{
		challengeId: string;
		initiatorUserId: string;
		partnerUserId: string;
	};

export type CollaborativeChallengeCountOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	challengeId?: Prisma.SortOrder;
	initiatorUserId?: Prisma.SortOrder;
	partnerUserId?: Prisma.SortOrder;
	initiatorCompleted?: Prisma.SortOrder;
	partnerCompleted?: Prisma.SortOrder;
	initiatorCompletedAt?: Prisma.SortOrder;
	partnerCompletedAt?: Prisma.SortOrder;
	xpBonusAwarded?: Prisma.SortOrder;
	status?: Prisma.SortOrder;
	expiresAt?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
};

export type CollaborativeChallengeAvgOrderByAggregateInput = {
	xpBonusAwarded?: Prisma.SortOrder;
};

export type CollaborativeChallengeMaxOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	challengeId?: Prisma.SortOrder;
	initiatorUserId?: Prisma.SortOrder;
	partnerUserId?: Prisma.SortOrder;
	initiatorCompleted?: Prisma.SortOrder;
	partnerCompleted?: Prisma.SortOrder;
	initiatorCompletedAt?: Prisma.SortOrder;
	partnerCompletedAt?: Prisma.SortOrder;
	xpBonusAwarded?: Prisma.SortOrder;
	status?: Prisma.SortOrder;
	expiresAt?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
};

export type CollaborativeChallengeMinOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	challengeId?: Prisma.SortOrder;
	initiatorUserId?: Prisma.SortOrder;
	partnerUserId?: Prisma.SortOrder;
	initiatorCompleted?: Prisma.SortOrder;
	partnerCompleted?: Prisma.SortOrder;
	initiatorCompletedAt?: Prisma.SortOrder;
	partnerCompletedAt?: Prisma.SortOrder;
	xpBonusAwarded?: Prisma.SortOrder;
	status?: Prisma.SortOrder;
	expiresAt?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
};

export type CollaborativeChallengeSumOrderByAggregateInput = {
	xpBonusAwarded?: Prisma.SortOrder;
};

export type CollaborativeChallengeCreateNestedManyWithoutInitiatorUserInput = {
	create?:
		| Prisma.XOR<
				Prisma.CollaborativeChallengeCreateWithoutInitiatorUserInput,
				Prisma.CollaborativeChallengeUncheckedCreateWithoutInitiatorUserInput
		  >
		| Prisma.CollaborativeChallengeCreateWithoutInitiatorUserInput[]
		| Prisma.CollaborativeChallengeUncheckedCreateWithoutInitiatorUserInput[];
	connectOrCreate?:
		| Prisma.CollaborativeChallengeCreateOrConnectWithoutInitiatorUserInput
		| Prisma.CollaborativeChallengeCreateOrConnectWithoutInitiatorUserInput[];
	createMany?: Prisma.CollaborativeChallengeCreateManyInitiatorUserInputEnvelope;
	connect?:
		| Prisma.CollaborativeChallengeWhereUniqueInput
		| Prisma.CollaborativeChallengeWhereUniqueInput[];
};

export type CollaborativeChallengeCreateNestedManyWithoutPartnerUserInput = {
	create?:
		| Prisma.XOR<
				Prisma.CollaborativeChallengeCreateWithoutPartnerUserInput,
				Prisma.CollaborativeChallengeUncheckedCreateWithoutPartnerUserInput
		  >
		| Prisma.CollaborativeChallengeCreateWithoutPartnerUserInput[]
		| Prisma.CollaborativeChallengeUncheckedCreateWithoutPartnerUserInput[];
	connectOrCreate?:
		| Prisma.CollaborativeChallengeCreateOrConnectWithoutPartnerUserInput
		| Prisma.CollaborativeChallengeCreateOrConnectWithoutPartnerUserInput[];
	createMany?: Prisma.CollaborativeChallengeCreateManyPartnerUserInputEnvelope;
	connect?:
		| Prisma.CollaborativeChallengeWhereUniqueInput
		| Prisma.CollaborativeChallengeWhereUniqueInput[];
};

export type CollaborativeChallengeUncheckedCreateNestedManyWithoutInitiatorUserInput =
	{
		create?:
			| Prisma.XOR<
					Prisma.CollaborativeChallengeCreateWithoutInitiatorUserInput,
					Prisma.CollaborativeChallengeUncheckedCreateWithoutInitiatorUserInput
			  >
			| Prisma.CollaborativeChallengeCreateWithoutInitiatorUserInput[]
			| Prisma.CollaborativeChallengeUncheckedCreateWithoutInitiatorUserInput[];
		connectOrCreate?:
			| Prisma.CollaborativeChallengeCreateOrConnectWithoutInitiatorUserInput
			| Prisma.CollaborativeChallengeCreateOrConnectWithoutInitiatorUserInput[];
		createMany?: Prisma.CollaborativeChallengeCreateManyInitiatorUserInputEnvelope;
		connect?:
			| Prisma.CollaborativeChallengeWhereUniqueInput
			| Prisma.CollaborativeChallengeWhereUniqueInput[];
	};

export type CollaborativeChallengeUncheckedCreateNestedManyWithoutPartnerUserInput =
	{
		create?:
			| Prisma.XOR<
					Prisma.CollaborativeChallengeCreateWithoutPartnerUserInput,
					Prisma.CollaborativeChallengeUncheckedCreateWithoutPartnerUserInput
			  >
			| Prisma.CollaborativeChallengeCreateWithoutPartnerUserInput[]
			| Prisma.CollaborativeChallengeUncheckedCreateWithoutPartnerUserInput[];
		connectOrCreate?:
			| Prisma.CollaborativeChallengeCreateOrConnectWithoutPartnerUserInput
			| Prisma.CollaborativeChallengeCreateOrConnectWithoutPartnerUserInput[];
		createMany?: Prisma.CollaborativeChallengeCreateManyPartnerUserInputEnvelope;
		connect?:
			| Prisma.CollaborativeChallengeWhereUniqueInput
			| Prisma.CollaborativeChallengeWhereUniqueInput[];
	};

export type CollaborativeChallengeUpdateManyWithoutInitiatorUserNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.CollaborativeChallengeCreateWithoutInitiatorUserInput,
				Prisma.CollaborativeChallengeUncheckedCreateWithoutInitiatorUserInput
		  >
		| Prisma.CollaborativeChallengeCreateWithoutInitiatorUserInput[]
		| Prisma.CollaborativeChallengeUncheckedCreateWithoutInitiatorUserInput[];
	connectOrCreate?:
		| Prisma.CollaborativeChallengeCreateOrConnectWithoutInitiatorUserInput
		| Prisma.CollaborativeChallengeCreateOrConnectWithoutInitiatorUserInput[];
	upsert?:
		| Prisma.CollaborativeChallengeUpsertWithWhereUniqueWithoutInitiatorUserInput
		| Prisma.CollaborativeChallengeUpsertWithWhereUniqueWithoutInitiatorUserInput[];
	createMany?: Prisma.CollaborativeChallengeCreateManyInitiatorUserInputEnvelope;
	set?:
		| Prisma.CollaborativeChallengeWhereUniqueInput
		| Prisma.CollaborativeChallengeWhereUniqueInput[];
	disconnect?:
		| Prisma.CollaborativeChallengeWhereUniqueInput
		| Prisma.CollaborativeChallengeWhereUniqueInput[];
	delete?:
		| Prisma.CollaborativeChallengeWhereUniqueInput
		| Prisma.CollaborativeChallengeWhereUniqueInput[];
	connect?:
		| Prisma.CollaborativeChallengeWhereUniqueInput
		| Prisma.CollaborativeChallengeWhereUniqueInput[];
	update?:
		| Prisma.CollaborativeChallengeUpdateWithWhereUniqueWithoutInitiatorUserInput
		| Prisma.CollaborativeChallengeUpdateWithWhereUniqueWithoutInitiatorUserInput[];
	updateMany?:
		| Prisma.CollaborativeChallengeUpdateManyWithWhereWithoutInitiatorUserInput
		| Prisma.CollaborativeChallengeUpdateManyWithWhereWithoutInitiatorUserInput[];
	deleteMany?:
		| Prisma.CollaborativeChallengeScalarWhereInput
		| Prisma.CollaborativeChallengeScalarWhereInput[];
};

export type CollaborativeChallengeUpdateManyWithoutPartnerUserNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.CollaborativeChallengeCreateWithoutPartnerUserInput,
				Prisma.CollaborativeChallengeUncheckedCreateWithoutPartnerUserInput
		  >
		| Prisma.CollaborativeChallengeCreateWithoutPartnerUserInput[]
		| Prisma.CollaborativeChallengeUncheckedCreateWithoutPartnerUserInput[];
	connectOrCreate?:
		| Prisma.CollaborativeChallengeCreateOrConnectWithoutPartnerUserInput
		| Prisma.CollaborativeChallengeCreateOrConnectWithoutPartnerUserInput[];
	upsert?:
		| Prisma.CollaborativeChallengeUpsertWithWhereUniqueWithoutPartnerUserInput
		| Prisma.CollaborativeChallengeUpsertWithWhereUniqueWithoutPartnerUserInput[];
	createMany?: Prisma.CollaborativeChallengeCreateManyPartnerUserInputEnvelope;
	set?:
		| Prisma.CollaborativeChallengeWhereUniqueInput
		| Prisma.CollaborativeChallengeWhereUniqueInput[];
	disconnect?:
		| Prisma.CollaborativeChallengeWhereUniqueInput
		| Prisma.CollaborativeChallengeWhereUniqueInput[];
	delete?:
		| Prisma.CollaborativeChallengeWhereUniqueInput
		| Prisma.CollaborativeChallengeWhereUniqueInput[];
	connect?:
		| Prisma.CollaborativeChallengeWhereUniqueInput
		| Prisma.CollaborativeChallengeWhereUniqueInput[];
	update?:
		| Prisma.CollaborativeChallengeUpdateWithWhereUniqueWithoutPartnerUserInput
		| Prisma.CollaborativeChallengeUpdateWithWhereUniqueWithoutPartnerUserInput[];
	updateMany?:
		| Prisma.CollaborativeChallengeUpdateManyWithWhereWithoutPartnerUserInput
		| Prisma.CollaborativeChallengeUpdateManyWithWhereWithoutPartnerUserInput[];
	deleteMany?:
		| Prisma.CollaborativeChallengeScalarWhereInput
		| Prisma.CollaborativeChallengeScalarWhereInput[];
};

export type CollaborativeChallengeUncheckedUpdateManyWithoutInitiatorUserNestedInput =
	{
		create?:
			| Prisma.XOR<
					Prisma.CollaborativeChallengeCreateWithoutInitiatorUserInput,
					Prisma.CollaborativeChallengeUncheckedCreateWithoutInitiatorUserInput
			  >
			| Prisma.CollaborativeChallengeCreateWithoutInitiatorUserInput[]
			| Prisma.CollaborativeChallengeUncheckedCreateWithoutInitiatorUserInput[];
		connectOrCreate?:
			| Prisma.CollaborativeChallengeCreateOrConnectWithoutInitiatorUserInput
			| Prisma.CollaborativeChallengeCreateOrConnectWithoutInitiatorUserInput[];
		upsert?:
			| Prisma.CollaborativeChallengeUpsertWithWhereUniqueWithoutInitiatorUserInput
			| Prisma.CollaborativeChallengeUpsertWithWhereUniqueWithoutInitiatorUserInput[];
		createMany?: Prisma.CollaborativeChallengeCreateManyInitiatorUserInputEnvelope;
		set?:
			| Prisma.CollaborativeChallengeWhereUniqueInput
			| Prisma.CollaborativeChallengeWhereUniqueInput[];
		disconnect?:
			| Prisma.CollaborativeChallengeWhereUniqueInput
			| Prisma.CollaborativeChallengeWhereUniqueInput[];
		delete?:
			| Prisma.CollaborativeChallengeWhereUniqueInput
			| Prisma.CollaborativeChallengeWhereUniqueInput[];
		connect?:
			| Prisma.CollaborativeChallengeWhereUniqueInput
			| Prisma.CollaborativeChallengeWhereUniqueInput[];
		update?:
			| Prisma.CollaborativeChallengeUpdateWithWhereUniqueWithoutInitiatorUserInput
			| Prisma.CollaborativeChallengeUpdateWithWhereUniqueWithoutInitiatorUserInput[];
		updateMany?:
			| Prisma.CollaborativeChallengeUpdateManyWithWhereWithoutInitiatorUserInput
			| Prisma.CollaborativeChallengeUpdateManyWithWhereWithoutInitiatorUserInput[];
		deleteMany?:
			| Prisma.CollaborativeChallengeScalarWhereInput
			| Prisma.CollaborativeChallengeScalarWhereInput[];
	};

export type CollaborativeChallengeUncheckedUpdateManyWithoutPartnerUserNestedInput =
	{
		create?:
			| Prisma.XOR<
					Prisma.CollaborativeChallengeCreateWithoutPartnerUserInput,
					Prisma.CollaborativeChallengeUncheckedCreateWithoutPartnerUserInput
			  >
			| Prisma.CollaborativeChallengeCreateWithoutPartnerUserInput[]
			| Prisma.CollaborativeChallengeUncheckedCreateWithoutPartnerUserInput[];
		connectOrCreate?:
			| Prisma.CollaborativeChallengeCreateOrConnectWithoutPartnerUserInput
			| Prisma.CollaborativeChallengeCreateOrConnectWithoutPartnerUserInput[];
		upsert?:
			| Prisma.CollaborativeChallengeUpsertWithWhereUniqueWithoutPartnerUserInput
			| Prisma.CollaborativeChallengeUpsertWithWhereUniqueWithoutPartnerUserInput[];
		createMany?: Prisma.CollaborativeChallengeCreateManyPartnerUserInputEnvelope;
		set?:
			| Prisma.CollaborativeChallengeWhereUniqueInput
			| Prisma.CollaborativeChallengeWhereUniqueInput[];
		disconnect?:
			| Prisma.CollaborativeChallengeWhereUniqueInput
			| Prisma.CollaborativeChallengeWhereUniqueInput[];
		delete?:
			| Prisma.CollaborativeChallengeWhereUniqueInput
			| Prisma.CollaborativeChallengeWhereUniqueInput[];
		connect?:
			| Prisma.CollaborativeChallengeWhereUniqueInput
			| Prisma.CollaborativeChallengeWhereUniqueInput[];
		update?:
			| Prisma.CollaborativeChallengeUpdateWithWhereUniqueWithoutPartnerUserInput
			| Prisma.CollaborativeChallengeUpdateWithWhereUniqueWithoutPartnerUserInput[];
		updateMany?:
			| Prisma.CollaborativeChallengeUpdateManyWithWhereWithoutPartnerUserInput
			| Prisma.CollaborativeChallengeUpdateManyWithWhereWithoutPartnerUserInput[];
		deleteMany?:
			| Prisma.CollaborativeChallengeScalarWhereInput
			| Prisma.CollaborativeChallengeScalarWhereInput[];
	};

export type CollaborativeChallengeCreateNestedManyWithoutChallengeInput = {
	create?:
		| Prisma.XOR<
				Prisma.CollaborativeChallengeCreateWithoutChallengeInput,
				Prisma.CollaborativeChallengeUncheckedCreateWithoutChallengeInput
		  >
		| Prisma.CollaborativeChallengeCreateWithoutChallengeInput[]
		| Prisma.CollaborativeChallengeUncheckedCreateWithoutChallengeInput[];
	connectOrCreate?:
		| Prisma.CollaborativeChallengeCreateOrConnectWithoutChallengeInput
		| Prisma.CollaborativeChallengeCreateOrConnectWithoutChallengeInput[];
	createMany?: Prisma.CollaborativeChallengeCreateManyChallengeInputEnvelope;
	connect?:
		| Prisma.CollaborativeChallengeWhereUniqueInput
		| Prisma.CollaborativeChallengeWhereUniqueInput[];
};

export type CollaborativeChallengeUncheckedCreateNestedManyWithoutChallengeInput =
	{
		create?:
			| Prisma.XOR<
					Prisma.CollaborativeChallengeCreateWithoutChallengeInput,
					Prisma.CollaborativeChallengeUncheckedCreateWithoutChallengeInput
			  >
			| Prisma.CollaborativeChallengeCreateWithoutChallengeInput[]
			| Prisma.CollaborativeChallengeUncheckedCreateWithoutChallengeInput[];
		connectOrCreate?:
			| Prisma.CollaborativeChallengeCreateOrConnectWithoutChallengeInput
			| Prisma.CollaborativeChallengeCreateOrConnectWithoutChallengeInput[];
		createMany?: Prisma.CollaborativeChallengeCreateManyChallengeInputEnvelope;
		connect?:
			| Prisma.CollaborativeChallengeWhereUniqueInput
			| Prisma.CollaborativeChallengeWhereUniqueInput[];
	};

export type CollaborativeChallengeUpdateManyWithoutChallengeNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.CollaborativeChallengeCreateWithoutChallengeInput,
				Prisma.CollaborativeChallengeUncheckedCreateWithoutChallengeInput
		  >
		| Prisma.CollaborativeChallengeCreateWithoutChallengeInput[]
		| Prisma.CollaborativeChallengeUncheckedCreateWithoutChallengeInput[];
	connectOrCreate?:
		| Prisma.CollaborativeChallengeCreateOrConnectWithoutChallengeInput
		| Prisma.CollaborativeChallengeCreateOrConnectWithoutChallengeInput[];
	upsert?:
		| Prisma.CollaborativeChallengeUpsertWithWhereUniqueWithoutChallengeInput
		| Prisma.CollaborativeChallengeUpsertWithWhereUniqueWithoutChallengeInput[];
	createMany?: Prisma.CollaborativeChallengeCreateManyChallengeInputEnvelope;
	set?:
		| Prisma.CollaborativeChallengeWhereUniqueInput
		| Prisma.CollaborativeChallengeWhereUniqueInput[];
	disconnect?:
		| Prisma.CollaborativeChallengeWhereUniqueInput
		| Prisma.CollaborativeChallengeWhereUniqueInput[];
	delete?:
		| Prisma.CollaborativeChallengeWhereUniqueInput
		| Prisma.CollaborativeChallengeWhereUniqueInput[];
	connect?:
		| Prisma.CollaborativeChallengeWhereUniqueInput
		| Prisma.CollaborativeChallengeWhereUniqueInput[];
	update?:
		| Prisma.CollaborativeChallengeUpdateWithWhereUniqueWithoutChallengeInput
		| Prisma.CollaborativeChallengeUpdateWithWhereUniqueWithoutChallengeInput[];
	updateMany?:
		| Prisma.CollaborativeChallengeUpdateManyWithWhereWithoutChallengeInput
		| Prisma.CollaborativeChallengeUpdateManyWithWhereWithoutChallengeInput[];
	deleteMany?:
		| Prisma.CollaborativeChallengeScalarWhereInput
		| Prisma.CollaborativeChallengeScalarWhereInput[];
};

export type CollaborativeChallengeUncheckedUpdateManyWithoutChallengeNestedInput =
	{
		create?:
			| Prisma.XOR<
					Prisma.CollaborativeChallengeCreateWithoutChallengeInput,
					Prisma.CollaborativeChallengeUncheckedCreateWithoutChallengeInput
			  >
			| Prisma.CollaborativeChallengeCreateWithoutChallengeInput[]
			| Prisma.CollaborativeChallengeUncheckedCreateWithoutChallengeInput[];
		connectOrCreate?:
			| Prisma.CollaborativeChallengeCreateOrConnectWithoutChallengeInput
			| Prisma.CollaborativeChallengeCreateOrConnectWithoutChallengeInput[];
		upsert?:
			| Prisma.CollaborativeChallengeUpsertWithWhereUniqueWithoutChallengeInput
			| Prisma.CollaborativeChallengeUpsertWithWhereUniqueWithoutChallengeInput[];
		createMany?: Prisma.CollaborativeChallengeCreateManyChallengeInputEnvelope;
		set?:
			| Prisma.CollaborativeChallengeWhereUniqueInput
			| Prisma.CollaborativeChallengeWhereUniqueInput[];
		disconnect?:
			| Prisma.CollaborativeChallengeWhereUniqueInput
			| Prisma.CollaborativeChallengeWhereUniqueInput[];
		delete?:
			| Prisma.CollaborativeChallengeWhereUniqueInput
			| Prisma.CollaborativeChallengeWhereUniqueInput[];
		connect?:
			| Prisma.CollaborativeChallengeWhereUniqueInput
			| Prisma.CollaborativeChallengeWhereUniqueInput[];
		update?:
			| Prisma.CollaborativeChallengeUpdateWithWhereUniqueWithoutChallengeInput
			| Prisma.CollaborativeChallengeUpdateWithWhereUniqueWithoutChallengeInput[];
		updateMany?:
			| Prisma.CollaborativeChallengeUpdateManyWithWhereWithoutChallengeInput
			| Prisma.CollaborativeChallengeUpdateManyWithWhereWithoutChallengeInput[];
		deleteMany?:
			| Prisma.CollaborativeChallengeScalarWhereInput
			| Prisma.CollaborativeChallengeScalarWhereInput[];
	};

export type CollaborativeChallengeCreateWithoutInitiatorUserInput = {
	id?: string;
	initiatorCompleted?: boolean;
	partnerCompleted?: boolean;
	initiatorCompletedAt?: Date | string | null;
	partnerCompletedAt?: Date | string | null;
	xpBonusAwarded?: number | null;
	status?: string;
	expiresAt: Date | string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	challenge: Prisma.ChallengeCreateNestedOneWithoutCollaborativeChallengesInput;
	partnerUser: Prisma.UserCreateNestedOneWithoutPartnerChallengesInput;
};

export type CollaborativeChallengeUncheckedCreateWithoutInitiatorUserInput = {
	id?: string;
	challengeId: string;
	partnerUserId: string;
	initiatorCompleted?: boolean;
	partnerCompleted?: boolean;
	initiatorCompletedAt?: Date | string | null;
	partnerCompletedAt?: Date | string | null;
	xpBonusAwarded?: number | null;
	status?: string;
	expiresAt: Date | string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
};

export type CollaborativeChallengeCreateOrConnectWithoutInitiatorUserInput = {
	where: Prisma.CollaborativeChallengeWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.CollaborativeChallengeCreateWithoutInitiatorUserInput,
		Prisma.CollaborativeChallengeUncheckedCreateWithoutInitiatorUserInput
	>;
};

export type CollaborativeChallengeCreateManyInitiatorUserInputEnvelope = {
	data:
		| Prisma.CollaborativeChallengeCreateManyInitiatorUserInput
		| Prisma.CollaborativeChallengeCreateManyInitiatorUserInput[];
};

export type CollaborativeChallengeCreateWithoutPartnerUserInput = {
	id?: string;
	initiatorCompleted?: boolean;
	partnerCompleted?: boolean;
	initiatorCompletedAt?: Date | string | null;
	partnerCompletedAt?: Date | string | null;
	xpBonusAwarded?: number | null;
	status?: string;
	expiresAt: Date | string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	challenge: Prisma.ChallengeCreateNestedOneWithoutCollaborativeChallengesInput;
	initiatorUser: Prisma.UserCreateNestedOneWithoutInitiatedChallengesInput;
};

export type CollaborativeChallengeUncheckedCreateWithoutPartnerUserInput = {
	id?: string;
	challengeId: string;
	initiatorUserId: string;
	initiatorCompleted?: boolean;
	partnerCompleted?: boolean;
	initiatorCompletedAt?: Date | string | null;
	partnerCompletedAt?: Date | string | null;
	xpBonusAwarded?: number | null;
	status?: string;
	expiresAt: Date | string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
};

export type CollaborativeChallengeCreateOrConnectWithoutPartnerUserInput = {
	where: Prisma.CollaborativeChallengeWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.CollaborativeChallengeCreateWithoutPartnerUserInput,
		Prisma.CollaborativeChallengeUncheckedCreateWithoutPartnerUserInput
	>;
};

export type CollaborativeChallengeCreateManyPartnerUserInputEnvelope = {
	data:
		| Prisma.CollaborativeChallengeCreateManyPartnerUserInput
		| Prisma.CollaborativeChallengeCreateManyPartnerUserInput[];
};

export type CollaborativeChallengeUpsertWithWhereUniqueWithoutInitiatorUserInput =
	{
		where: Prisma.CollaborativeChallengeWhereUniqueInput;
		update: Prisma.XOR<
			Prisma.CollaborativeChallengeUpdateWithoutInitiatorUserInput,
			Prisma.CollaborativeChallengeUncheckedUpdateWithoutInitiatorUserInput
		>;
		create: Prisma.XOR<
			Prisma.CollaborativeChallengeCreateWithoutInitiatorUserInput,
			Prisma.CollaborativeChallengeUncheckedCreateWithoutInitiatorUserInput
		>;
	};

export type CollaborativeChallengeUpdateWithWhereUniqueWithoutInitiatorUserInput =
	{
		where: Prisma.CollaborativeChallengeWhereUniqueInput;
		data: Prisma.XOR<
			Prisma.CollaborativeChallengeUpdateWithoutInitiatorUserInput,
			Prisma.CollaborativeChallengeUncheckedUpdateWithoutInitiatorUserInput
		>;
	};

export type CollaborativeChallengeUpdateManyWithWhereWithoutInitiatorUserInput =
	{
		where: Prisma.CollaborativeChallengeScalarWhereInput;
		data: Prisma.XOR<
			Prisma.CollaborativeChallengeUpdateManyMutationInput,
			Prisma.CollaborativeChallengeUncheckedUpdateManyWithoutInitiatorUserInput
		>;
	};

export type CollaborativeChallengeScalarWhereInput = {
	AND?:
		| Prisma.CollaborativeChallengeScalarWhereInput
		| Prisma.CollaborativeChallengeScalarWhereInput[];
	OR?: Prisma.CollaborativeChallengeScalarWhereInput[];
	NOT?:
		| Prisma.CollaborativeChallengeScalarWhereInput
		| Prisma.CollaborativeChallengeScalarWhereInput[];
	id?: Prisma.StringFilter<"CollaborativeChallenge"> | string;
	challengeId?: Prisma.StringFilter<"CollaborativeChallenge"> | string;
	initiatorUserId?: Prisma.StringFilter<"CollaborativeChallenge"> | string;
	partnerUserId?: Prisma.StringFilter<"CollaborativeChallenge"> | string;
	initiatorCompleted?: Prisma.BoolFilter<"CollaborativeChallenge"> | boolean;
	partnerCompleted?: Prisma.BoolFilter<"CollaborativeChallenge"> | boolean;
	initiatorCompletedAt?:
		| Prisma.DateTimeNullableFilter<"CollaborativeChallenge">
		| Date
		| string
		| null;
	partnerCompletedAt?:
		| Prisma.DateTimeNullableFilter<"CollaborativeChallenge">
		| Date
		| string
		| null;
	xpBonusAwarded?:
		| Prisma.IntNullableFilter<"CollaborativeChallenge">
		| number
		| null;
	status?: Prisma.StringFilter<"CollaborativeChallenge"> | string;
	expiresAt?: Prisma.DateTimeFilter<"CollaborativeChallenge"> | Date | string;
	createdAt?: Prisma.DateTimeFilter<"CollaborativeChallenge"> | Date | string;
	updatedAt?: Prisma.DateTimeFilter<"CollaborativeChallenge"> | Date | string;
};

export type CollaborativeChallengeUpsertWithWhereUniqueWithoutPartnerUserInput =
	{
		where: Prisma.CollaborativeChallengeWhereUniqueInput;
		update: Prisma.XOR<
			Prisma.CollaborativeChallengeUpdateWithoutPartnerUserInput,
			Prisma.CollaborativeChallengeUncheckedUpdateWithoutPartnerUserInput
		>;
		create: Prisma.XOR<
			Prisma.CollaborativeChallengeCreateWithoutPartnerUserInput,
			Prisma.CollaborativeChallengeUncheckedCreateWithoutPartnerUserInput
		>;
	};

export type CollaborativeChallengeUpdateWithWhereUniqueWithoutPartnerUserInput =
	{
		where: Prisma.CollaborativeChallengeWhereUniqueInput;
		data: Prisma.XOR<
			Prisma.CollaborativeChallengeUpdateWithoutPartnerUserInput,
			Prisma.CollaborativeChallengeUncheckedUpdateWithoutPartnerUserInput
		>;
	};

export type CollaborativeChallengeUpdateManyWithWhereWithoutPartnerUserInput = {
	where: Prisma.CollaborativeChallengeScalarWhereInput;
	data: Prisma.XOR<
		Prisma.CollaborativeChallengeUpdateManyMutationInput,
		Prisma.CollaborativeChallengeUncheckedUpdateManyWithoutPartnerUserInput
	>;
};

export type CollaborativeChallengeCreateWithoutChallengeInput = {
	id?: string;
	initiatorCompleted?: boolean;
	partnerCompleted?: boolean;
	initiatorCompletedAt?: Date | string | null;
	partnerCompletedAt?: Date | string | null;
	xpBonusAwarded?: number | null;
	status?: string;
	expiresAt: Date | string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	initiatorUser: Prisma.UserCreateNestedOneWithoutInitiatedChallengesInput;
	partnerUser: Prisma.UserCreateNestedOneWithoutPartnerChallengesInput;
};

export type CollaborativeChallengeUncheckedCreateWithoutChallengeInput = {
	id?: string;
	initiatorUserId: string;
	partnerUserId: string;
	initiatorCompleted?: boolean;
	partnerCompleted?: boolean;
	initiatorCompletedAt?: Date | string | null;
	partnerCompletedAt?: Date | string | null;
	xpBonusAwarded?: number | null;
	status?: string;
	expiresAt: Date | string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
};

export type CollaborativeChallengeCreateOrConnectWithoutChallengeInput = {
	where: Prisma.CollaborativeChallengeWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.CollaborativeChallengeCreateWithoutChallengeInput,
		Prisma.CollaborativeChallengeUncheckedCreateWithoutChallengeInput
	>;
};

export type CollaborativeChallengeCreateManyChallengeInputEnvelope = {
	data:
		| Prisma.CollaborativeChallengeCreateManyChallengeInput
		| Prisma.CollaborativeChallengeCreateManyChallengeInput[];
};

export type CollaborativeChallengeUpsertWithWhereUniqueWithoutChallengeInput = {
	where: Prisma.CollaborativeChallengeWhereUniqueInput;
	update: Prisma.XOR<
		Prisma.CollaborativeChallengeUpdateWithoutChallengeInput,
		Prisma.CollaborativeChallengeUncheckedUpdateWithoutChallengeInput
	>;
	create: Prisma.XOR<
		Prisma.CollaborativeChallengeCreateWithoutChallengeInput,
		Prisma.CollaborativeChallengeUncheckedCreateWithoutChallengeInput
	>;
};

export type CollaborativeChallengeUpdateWithWhereUniqueWithoutChallengeInput = {
	where: Prisma.CollaborativeChallengeWhereUniqueInput;
	data: Prisma.XOR<
		Prisma.CollaborativeChallengeUpdateWithoutChallengeInput,
		Prisma.CollaborativeChallengeUncheckedUpdateWithoutChallengeInput
	>;
};

export type CollaborativeChallengeUpdateManyWithWhereWithoutChallengeInput = {
	where: Prisma.CollaborativeChallengeScalarWhereInput;
	data: Prisma.XOR<
		Prisma.CollaborativeChallengeUpdateManyMutationInput,
		Prisma.CollaborativeChallengeUncheckedUpdateManyWithoutChallengeInput
	>;
};

export type CollaborativeChallengeCreateManyInitiatorUserInput = {
	id?: string;
	challengeId: string;
	partnerUserId: string;
	initiatorCompleted?: boolean;
	partnerCompleted?: boolean;
	initiatorCompletedAt?: Date | string | null;
	partnerCompletedAt?: Date | string | null;
	xpBonusAwarded?: number | null;
	status?: string;
	expiresAt: Date | string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
};

export type CollaborativeChallengeCreateManyPartnerUserInput = {
	id?: string;
	challengeId: string;
	initiatorUserId: string;
	initiatorCompleted?: boolean;
	partnerCompleted?: boolean;
	initiatorCompletedAt?: Date | string | null;
	partnerCompletedAt?: Date | string | null;
	xpBonusAwarded?: number | null;
	status?: string;
	expiresAt: Date | string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
};

export type CollaborativeChallengeUpdateWithoutInitiatorUserInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	initiatorCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	partnerCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	initiatorCompletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	partnerCompletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	xpBonusAwarded?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	status?: Prisma.StringFieldUpdateOperationsInput | string;
	expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	challenge?: Prisma.ChallengeUpdateOneRequiredWithoutCollaborativeChallengesNestedInput;
	partnerUser?: Prisma.UserUpdateOneRequiredWithoutPartnerChallengesNestedInput;
};

export type CollaborativeChallengeUncheckedUpdateWithoutInitiatorUserInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	challengeId?: Prisma.StringFieldUpdateOperationsInput | string;
	partnerUserId?: Prisma.StringFieldUpdateOperationsInput | string;
	initiatorCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	partnerCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	initiatorCompletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	partnerCompletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	xpBonusAwarded?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	status?: Prisma.StringFieldUpdateOperationsInput | string;
	expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type CollaborativeChallengeUncheckedUpdateManyWithoutInitiatorUserInput =
	{
		id?: Prisma.StringFieldUpdateOperationsInput | string;
		challengeId?: Prisma.StringFieldUpdateOperationsInput | string;
		partnerUserId?: Prisma.StringFieldUpdateOperationsInput | string;
		initiatorCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
		partnerCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
		initiatorCompletedAt?:
			| Prisma.NullableDateTimeFieldUpdateOperationsInput
			| Date
			| string
			| null;
		partnerCompletedAt?:
			| Prisma.NullableDateTimeFieldUpdateOperationsInput
			| Date
			| string
			| null;
		xpBonusAwarded?:
			| Prisma.NullableIntFieldUpdateOperationsInput
			| number
			| null;
		status?: Prisma.StringFieldUpdateOperationsInput | string;
		expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
		createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
		updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	};

export type CollaborativeChallengeUpdateWithoutPartnerUserInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	initiatorCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	partnerCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	initiatorCompletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	partnerCompletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	xpBonusAwarded?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	status?: Prisma.StringFieldUpdateOperationsInput | string;
	expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	challenge?: Prisma.ChallengeUpdateOneRequiredWithoutCollaborativeChallengesNestedInput;
	initiatorUser?: Prisma.UserUpdateOneRequiredWithoutInitiatedChallengesNestedInput;
};

export type CollaborativeChallengeUncheckedUpdateWithoutPartnerUserInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	challengeId?: Prisma.StringFieldUpdateOperationsInput | string;
	initiatorUserId?: Prisma.StringFieldUpdateOperationsInput | string;
	initiatorCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	partnerCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	initiatorCompletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	partnerCompletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	xpBonusAwarded?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	status?: Prisma.StringFieldUpdateOperationsInput | string;
	expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type CollaborativeChallengeUncheckedUpdateManyWithoutPartnerUserInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	challengeId?: Prisma.StringFieldUpdateOperationsInput | string;
	initiatorUserId?: Prisma.StringFieldUpdateOperationsInput | string;
	initiatorCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	partnerCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	initiatorCompletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	partnerCompletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	xpBonusAwarded?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	status?: Prisma.StringFieldUpdateOperationsInput | string;
	expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type CollaborativeChallengeCreateManyChallengeInput = {
	id?: string;
	initiatorUserId: string;
	partnerUserId: string;
	initiatorCompleted?: boolean;
	partnerCompleted?: boolean;
	initiatorCompletedAt?: Date | string | null;
	partnerCompletedAt?: Date | string | null;
	xpBonusAwarded?: number | null;
	status?: string;
	expiresAt: Date | string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
};

export type CollaborativeChallengeUpdateWithoutChallengeInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	initiatorCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	partnerCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	initiatorCompletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	partnerCompletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	xpBonusAwarded?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	status?: Prisma.StringFieldUpdateOperationsInput | string;
	expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	initiatorUser?: Prisma.UserUpdateOneRequiredWithoutInitiatedChallengesNestedInput;
	partnerUser?: Prisma.UserUpdateOneRequiredWithoutPartnerChallengesNestedInput;
};

export type CollaborativeChallengeUncheckedUpdateWithoutChallengeInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	initiatorUserId?: Prisma.StringFieldUpdateOperationsInput | string;
	partnerUserId?: Prisma.StringFieldUpdateOperationsInput | string;
	initiatorCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	partnerCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	initiatorCompletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	partnerCompletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	xpBonusAwarded?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	status?: Prisma.StringFieldUpdateOperationsInput | string;
	expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type CollaborativeChallengeUncheckedUpdateManyWithoutChallengeInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	initiatorUserId?: Prisma.StringFieldUpdateOperationsInput | string;
	partnerUserId?: Prisma.StringFieldUpdateOperationsInput | string;
	initiatorCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	partnerCompleted?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	initiatorCompletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	partnerCompletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	xpBonusAwarded?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	status?: Prisma.StringFieldUpdateOperationsInput | string;
	expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type CollaborativeChallengeSelect<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		challengeId?: boolean;
		initiatorUserId?: boolean;
		partnerUserId?: boolean;
		initiatorCompleted?: boolean;
		partnerCompleted?: boolean;
		initiatorCompletedAt?: boolean;
		partnerCompletedAt?: boolean;
		xpBonusAwarded?: boolean;
		status?: boolean;
		expiresAt?: boolean;
		createdAt?: boolean;
		updatedAt?: boolean;
		challenge?: boolean | Prisma.ChallengeDefaultArgs<ExtArgs>;
		initiatorUser?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
		partnerUser?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
	},
	ExtArgs["result"]["collaborativeChallenge"]
>;

export type CollaborativeChallengeSelectCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		challengeId?: boolean;
		initiatorUserId?: boolean;
		partnerUserId?: boolean;
		initiatorCompleted?: boolean;
		partnerCompleted?: boolean;
		initiatorCompletedAt?: boolean;
		partnerCompletedAt?: boolean;
		xpBonusAwarded?: boolean;
		status?: boolean;
		expiresAt?: boolean;
		createdAt?: boolean;
		updatedAt?: boolean;
		challenge?: boolean | Prisma.ChallengeDefaultArgs<ExtArgs>;
		initiatorUser?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
		partnerUser?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
	},
	ExtArgs["result"]["collaborativeChallenge"]
>;

export type CollaborativeChallengeSelectUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		challengeId?: boolean;
		initiatorUserId?: boolean;
		partnerUserId?: boolean;
		initiatorCompleted?: boolean;
		partnerCompleted?: boolean;
		initiatorCompletedAt?: boolean;
		partnerCompletedAt?: boolean;
		xpBonusAwarded?: boolean;
		status?: boolean;
		expiresAt?: boolean;
		createdAt?: boolean;
		updatedAt?: boolean;
		challenge?: boolean | Prisma.ChallengeDefaultArgs<ExtArgs>;
		initiatorUser?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
		partnerUser?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
	},
	ExtArgs["result"]["collaborativeChallenge"]
>;

export type CollaborativeChallengeSelectScalar = {
	id?: boolean;
	challengeId?: boolean;
	initiatorUserId?: boolean;
	partnerUserId?: boolean;
	initiatorCompleted?: boolean;
	partnerCompleted?: boolean;
	initiatorCompletedAt?: boolean;
	partnerCompletedAt?: boolean;
	xpBonusAwarded?: boolean;
	status?: boolean;
	expiresAt?: boolean;
	createdAt?: boolean;
	updatedAt?: boolean;
};

export type CollaborativeChallengeOmit<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
	| "id"
	| "challengeId"
	| "initiatorUserId"
	| "partnerUserId"
	| "initiatorCompleted"
	| "partnerCompleted"
	| "initiatorCompletedAt"
	| "partnerCompletedAt"
	| "xpBonusAwarded"
	| "status"
	| "expiresAt"
	| "createdAt"
	| "updatedAt",
	ExtArgs["result"]["collaborativeChallenge"]
>;
export type CollaborativeChallengeInclude<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	challenge?: boolean | Prisma.ChallengeDefaultArgs<ExtArgs>;
	initiatorUser?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
	partnerUser?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
};
export type CollaborativeChallengeIncludeCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	challenge?: boolean | Prisma.ChallengeDefaultArgs<ExtArgs>;
	initiatorUser?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
	partnerUser?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
};
export type CollaborativeChallengeIncludeUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	challenge?: boolean | Prisma.ChallengeDefaultArgs<ExtArgs>;
	initiatorUser?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
	partnerUser?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
};

export type $CollaborativeChallengePayload<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	name: "CollaborativeChallenge";
	objects: {
		challenge: Prisma.$ChallengePayload<ExtArgs>;
		initiatorUser: Prisma.$UserPayload<ExtArgs>;
		partnerUser: Prisma.$UserPayload<ExtArgs>;
	};
	scalars: runtime.Types.Extensions.GetPayloadResult<
		{
			id: string;
			challengeId: string;
			initiatorUserId: string;
			partnerUserId: string;
			initiatorCompleted: boolean;
			partnerCompleted: boolean;
			initiatorCompletedAt: Date | null;
			partnerCompletedAt: Date | null;
			xpBonusAwarded: number | null;
			status: string;
			expiresAt: Date;
			createdAt: Date;
			updatedAt: Date;
		},
		ExtArgs["result"]["collaborativeChallenge"]
	>;
	composites: {};
};

export type CollaborativeChallengeGetPayload<
	S extends boolean | null | undefined | CollaborativeChallengeDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$CollaborativeChallengePayload, S>;

export type CollaborativeChallengeCountArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = Omit<
	CollaborativeChallengeFindManyArgs,
	"select" | "include" | "distinct" | "omit"
> & {
	select?: CollaborativeChallengeCountAggregateInputType | true;
};

export interface CollaborativeChallengeDelegate<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> {
	[K: symbol]: {
		types: Prisma.TypeMap<ExtArgs>["model"]["CollaborativeChallenge"];
		meta: { name: "CollaborativeChallenge" };
	};
	/**
	 * Find zero or one CollaborativeChallenge that matches the filter.
	 * @param {CollaborativeChallengeFindUniqueArgs} args - Arguments to find a CollaborativeChallenge
	 * @example
	 * // Get one CollaborativeChallenge
	 * const collaborativeChallenge = await prisma.collaborativeChallenge.findUnique({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUnique<T extends CollaborativeChallengeFindUniqueArgs>(
		args: Prisma.SelectSubset<T, CollaborativeChallengeFindUniqueArgs<ExtArgs>>,
	): Prisma.Prisma__CollaborativeChallengeClient<
		runtime.Types.Result.GetResult<
			Prisma.$CollaborativeChallengePayload<ExtArgs>,
			T,
			"findUnique",
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find one CollaborativeChallenge that matches the filter or throw an error with `error.code='P2025'`
	 * if no matches were found.
	 * @param {CollaborativeChallengeFindUniqueOrThrowArgs} args - Arguments to find a CollaborativeChallenge
	 * @example
	 * // Get one CollaborativeChallenge
	 * const collaborativeChallenge = await prisma.collaborativeChallenge.findUniqueOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUniqueOrThrow<T extends CollaborativeChallengeFindUniqueOrThrowArgs>(
		args: Prisma.SelectSubset<
			T,
			CollaborativeChallengeFindUniqueOrThrowArgs<ExtArgs>
		>,
	): Prisma.Prisma__CollaborativeChallengeClient<
		runtime.Types.Result.GetResult<
			Prisma.$CollaborativeChallengePayload<ExtArgs>,
			T,
			"findUniqueOrThrow",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first CollaborativeChallenge that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {CollaborativeChallengeFindFirstArgs} args - Arguments to find a CollaborativeChallenge
	 * @example
	 * // Get one CollaborativeChallenge
	 * const collaborativeChallenge = await prisma.collaborativeChallenge.findFirst({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirst<T extends CollaborativeChallengeFindFirstArgs>(
		args?: Prisma.SelectSubset<T, CollaborativeChallengeFindFirstArgs<ExtArgs>>,
	): Prisma.Prisma__CollaborativeChallengeClient<
		runtime.Types.Result.GetResult<
			Prisma.$CollaborativeChallengePayload<ExtArgs>,
			T,
			"findFirst",
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first CollaborativeChallenge that matches the filter or
	 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {CollaborativeChallengeFindFirstOrThrowArgs} args - Arguments to find a CollaborativeChallenge
	 * @example
	 * // Get one CollaborativeChallenge
	 * const collaborativeChallenge = await prisma.collaborativeChallenge.findFirstOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirstOrThrow<T extends CollaborativeChallengeFindFirstOrThrowArgs>(
		args?: Prisma.SelectSubset<
			T,
			CollaborativeChallengeFindFirstOrThrowArgs<ExtArgs>
		>,
	): Prisma.Prisma__CollaborativeChallengeClient<
		runtime.Types.Result.GetResult<
			Prisma.$CollaborativeChallengePayload<ExtArgs>,
			T,
			"findFirstOrThrow",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find zero or more CollaborativeChallenges that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {CollaborativeChallengeFindManyArgs} args - Arguments to filter and select certain fields only.
	 * @example
	 * // Get all CollaborativeChallenges
	 * const collaborativeChallenges = await prisma.collaborativeChallenge.findMany()
	 *
	 * // Get first 10 CollaborativeChallenges
	 * const collaborativeChallenges = await prisma.collaborativeChallenge.findMany({ take: 10 })
	 *
	 * // Only select the `id`
	 * const collaborativeChallengeWithIdOnly = await prisma.collaborativeChallenge.findMany({ select: { id: true } })
	 *
	 */
	findMany<T extends CollaborativeChallengeFindManyArgs>(
		args?: Prisma.SelectSubset<T, CollaborativeChallengeFindManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$CollaborativeChallengePayload<ExtArgs>,
			T,
			"findMany",
			GlobalOmitOptions
		>
	>;

	/**
	 * Create a CollaborativeChallenge.
	 * @param {CollaborativeChallengeCreateArgs} args - Arguments to create a CollaborativeChallenge.
	 * @example
	 * // Create one CollaborativeChallenge
	 * const CollaborativeChallenge = await prisma.collaborativeChallenge.create({
	 *   data: {
	 *     // ... data to create a CollaborativeChallenge
	 *   }
	 * })
	 *
	 */
	create<T extends CollaborativeChallengeCreateArgs>(
		args: Prisma.SelectSubset<T, CollaborativeChallengeCreateArgs<ExtArgs>>,
	): Prisma.Prisma__CollaborativeChallengeClient<
		runtime.Types.Result.GetResult<
			Prisma.$CollaborativeChallengePayload<ExtArgs>,
			T,
			"create",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Create many CollaborativeChallenges.
	 * @param {CollaborativeChallengeCreateManyArgs} args - Arguments to create many CollaborativeChallenges.
	 * @example
	 * // Create many CollaborativeChallenges
	 * const collaborativeChallenge = await prisma.collaborativeChallenge.createMany({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 */
	createMany<T extends CollaborativeChallengeCreateManyArgs>(
		args?: Prisma.SelectSubset<
			T,
			CollaborativeChallengeCreateManyArgs<ExtArgs>
		>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Create many CollaborativeChallenges and returns the data saved in the database.
	 * @param {CollaborativeChallengeCreateManyAndReturnArgs} args - Arguments to create many CollaborativeChallenges.
	 * @example
	 * // Create many CollaborativeChallenges
	 * const collaborativeChallenge = await prisma.collaborativeChallenge.createManyAndReturn({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Create many CollaborativeChallenges and only return the `id`
	 * const collaborativeChallengeWithIdOnly = await prisma.collaborativeChallenge.createManyAndReturn({
	 *   select: { id: true },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 *
	 */
	createManyAndReturn<T extends CollaborativeChallengeCreateManyAndReturnArgs>(
		args?: Prisma.SelectSubset<
			T,
			CollaborativeChallengeCreateManyAndReturnArgs<ExtArgs>
		>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$CollaborativeChallengePayload<ExtArgs>,
			T,
			"createManyAndReturn",
			GlobalOmitOptions
		>
	>;

	/**
	 * Delete a CollaborativeChallenge.
	 * @param {CollaborativeChallengeDeleteArgs} args - Arguments to delete one CollaborativeChallenge.
	 * @example
	 * // Delete one CollaborativeChallenge
	 * const CollaborativeChallenge = await prisma.collaborativeChallenge.delete({
	 *   where: {
	 *     // ... filter to delete one CollaborativeChallenge
	 *   }
	 * })
	 *
	 */
	delete<T extends CollaborativeChallengeDeleteArgs>(
		args: Prisma.SelectSubset<T, CollaborativeChallengeDeleteArgs<ExtArgs>>,
	): Prisma.Prisma__CollaborativeChallengeClient<
		runtime.Types.Result.GetResult<
			Prisma.$CollaborativeChallengePayload<ExtArgs>,
			T,
			"delete",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Update one CollaborativeChallenge.
	 * @param {CollaborativeChallengeUpdateArgs} args - Arguments to update one CollaborativeChallenge.
	 * @example
	 * // Update one CollaborativeChallenge
	 * const collaborativeChallenge = await prisma.collaborativeChallenge.update({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	update<T extends CollaborativeChallengeUpdateArgs>(
		args: Prisma.SelectSubset<T, CollaborativeChallengeUpdateArgs<ExtArgs>>,
	): Prisma.Prisma__CollaborativeChallengeClient<
		runtime.Types.Result.GetResult<
			Prisma.$CollaborativeChallengePayload<ExtArgs>,
			T,
			"update",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Delete zero or more CollaborativeChallenges.
	 * @param {CollaborativeChallengeDeleteManyArgs} args - Arguments to filter CollaborativeChallenges to delete.
	 * @example
	 * // Delete a few CollaborativeChallenges
	 * const { count } = await prisma.collaborativeChallenge.deleteMany({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 *
	 */
	deleteMany<T extends CollaborativeChallengeDeleteManyArgs>(
		args?: Prisma.SelectSubset<
			T,
			CollaborativeChallengeDeleteManyArgs<ExtArgs>
		>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Update zero or more CollaborativeChallenges.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {CollaborativeChallengeUpdateManyArgs} args - Arguments to update one or more rows.
	 * @example
	 * // Update many CollaborativeChallenges
	 * const collaborativeChallenge = await prisma.collaborativeChallenge.updateMany({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	updateMany<T extends CollaborativeChallengeUpdateManyArgs>(
		args: Prisma.SelectSubset<T, CollaborativeChallengeUpdateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Update zero or more CollaborativeChallenges and returns the data updated in the database.
	 * @param {CollaborativeChallengeUpdateManyAndReturnArgs} args - Arguments to update many CollaborativeChallenges.
	 * @example
	 * // Update many CollaborativeChallenges
	 * const collaborativeChallenge = await prisma.collaborativeChallenge.updateManyAndReturn({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Update zero or more CollaborativeChallenges and only return the `id`
	 * const collaborativeChallengeWithIdOnly = await prisma.collaborativeChallenge.updateManyAndReturn({
	 *   select: { id: true },
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 *
	 */
	updateManyAndReturn<T extends CollaborativeChallengeUpdateManyAndReturnArgs>(
		args: Prisma.SelectSubset<
			T,
			CollaborativeChallengeUpdateManyAndReturnArgs<ExtArgs>
		>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$CollaborativeChallengePayload<ExtArgs>,
			T,
			"updateManyAndReturn",
			GlobalOmitOptions
		>
	>;

	/**
	 * Create or update one CollaborativeChallenge.
	 * @param {CollaborativeChallengeUpsertArgs} args - Arguments to update or create a CollaborativeChallenge.
	 * @example
	 * // Update or create a CollaborativeChallenge
	 * const collaborativeChallenge = await prisma.collaborativeChallenge.upsert({
	 *   create: {
	 *     // ... data to create a CollaborativeChallenge
	 *   },
	 *   update: {
	 *     // ... in case it already exists, update
	 *   },
	 *   where: {
	 *     // ... the filter for the CollaborativeChallenge we want to update
	 *   }
	 * })
	 */
	upsert<T extends CollaborativeChallengeUpsertArgs>(
		args: Prisma.SelectSubset<T, CollaborativeChallengeUpsertArgs<ExtArgs>>,
	): Prisma.Prisma__CollaborativeChallengeClient<
		runtime.Types.Result.GetResult<
			Prisma.$CollaborativeChallengePayload<ExtArgs>,
			T,
			"upsert",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Count the number of CollaborativeChallenges.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {CollaborativeChallengeCountArgs} args - Arguments to filter CollaborativeChallenges to count.
	 * @example
	 * // Count the number of CollaborativeChallenges
	 * const count = await prisma.collaborativeChallenge.count({
	 *   where: {
	 *     // ... the filter for the CollaborativeChallenges we want to count
	 *   }
	 * })
	 **/
	count<T extends CollaborativeChallengeCountArgs>(
		args?: Prisma.Subset<T, CollaborativeChallengeCountArgs>,
	): Prisma.PrismaPromise<
		T extends runtime.Types.Utils.Record<"select", any>
			? T["select"] extends true
				? number
				: Prisma.GetScalarType<
						T["select"],
						CollaborativeChallengeCountAggregateOutputType
					>
			: number
	>;

	/**
	 * Allows you to perform aggregations operations on a CollaborativeChallenge.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {CollaborativeChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
	 * @example
	 * // Ordered by age ascending
	 * // Where email contains prisma.io
	 * // Limited to the 10 users
	 * const aggregations = await prisma.user.aggregate({
	 *   _avg: {
	 *     age: true,
	 *   },
	 *   where: {
	 *     email: {
	 *       contains: "prisma.io",
	 *     },
	 *   },
	 *   orderBy: {
	 *     age: "asc",
	 *   },
	 *   take: 10,
	 * })
	 **/
	aggregate<T extends CollaborativeChallengeAggregateArgs>(
		args: Prisma.Subset<T, CollaborativeChallengeAggregateArgs>,
	): Prisma.PrismaPromise<GetCollaborativeChallengeAggregateType<T>>;

	/**
	 * Group by CollaborativeChallenge.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {CollaborativeChallengeGroupByArgs} args - Group by arguments.
	 * @example
	 * // Group by city, order by createdAt, get count
	 * const result = await prisma.user.groupBy({
	 *   by: ['city', 'createdAt'],
	 *   orderBy: {
	 *     createdAt: true
	 *   },
	 *   _count: {
	 *     _all: true
	 *   },
	 * })
	 *
	 **/
	groupBy<
		T extends CollaborativeChallengeGroupByArgs,
		HasSelectOrTake extends Prisma.Or<
			Prisma.Extends<"skip", Prisma.Keys<T>>,
			Prisma.Extends<"take", Prisma.Keys<T>>
		>,
		OrderByArg extends Prisma.True extends HasSelectOrTake
			? { orderBy: CollaborativeChallengeGroupByArgs["orderBy"] }
			: { orderBy?: CollaborativeChallengeGroupByArgs["orderBy"] },
		OrderFields extends Prisma.ExcludeUnderscoreKeys<
			Prisma.Keys<Prisma.MaybeTupleToUnion<T["orderBy"]>>
		>,
		ByFields extends Prisma.MaybeTupleToUnion<T["by"]>,
		ByValid extends Prisma.Has<ByFields, OrderFields>,
		HavingFields extends Prisma.GetHavingFields<T["having"]>,
		HavingValid extends Prisma.Has<ByFields, HavingFields>,
		ByEmpty extends T["by"] extends never[] ? Prisma.True : Prisma.False,
		InputErrors extends ByEmpty extends Prisma.True
			? `Error: "by" must not be empty.`
			: HavingValid extends Prisma.False
				? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
										Error,
										"Field ",
										P,
										` in "having" needs to be provided in "by"`,
									];
					}[HavingFields]
				: "take" extends Prisma.Keys<T>
					? "orderBy" extends Prisma.Keys<T>
						? ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields]
						: 'Error: If you provide "take", you also need to provide "orderBy"'
					: "skip" extends Prisma.Keys<T>
						? "orderBy" extends Prisma.Keys<T>
							? ByValid extends Prisma.True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
									}[OrderFields]
							: 'Error: If you provide "skip", you also need to provide "orderBy"'
						: ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields],
	>(
		args: Prisma.SubsetIntersection<
			T,
			CollaborativeChallengeGroupByArgs,
			OrderByArg
		> &
			InputErrors,
	): {} extends InputErrors
		? GetCollaborativeChallengeGroupByPayload<T>
		: Prisma.PrismaPromise<InputErrors>;
	/**
	 * Fields of the CollaborativeChallenge model
	 */
	readonly fields: CollaborativeChallengeFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for CollaborativeChallenge.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__CollaborativeChallengeClient<
	T,
	Null = never,
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
	readonly [Symbol.toStringTag]: "PrismaPromise";
	challenge<T extends Prisma.ChallengeDefaultArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.ChallengeDefaultArgs<ExtArgs>>,
	): Prisma.Prisma__ChallengeClient<
		| runtime.Types.Result.GetResult<
				Prisma.$ChallengePayload<ExtArgs>,
				T,
				"findUniqueOrThrow",
				GlobalOmitOptions
		  >
		| Null,
		Null,
		ExtArgs,
		GlobalOmitOptions
	>;
	initiatorUser<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>,
	): Prisma.Prisma__UserClient<
		| runtime.Types.Result.GetResult<
				Prisma.$UserPayload<ExtArgs>,
				T,
				"findUniqueOrThrow",
				GlobalOmitOptions
		  >
		| Null,
		Null,
		ExtArgs,
		GlobalOmitOptions
	>;
	partnerUser<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>,
	): Prisma.Prisma__UserClient<
		| runtime.Types.Result.GetResult<
				Prisma.$UserPayload<ExtArgs>,
				T,
				"findUniqueOrThrow",
				GlobalOmitOptions
		  >
		| Null,
		Null,
		ExtArgs,
		GlobalOmitOptions
	>;
	/**
	 * Attaches callbacks for the resolution and/or rejection of the Promise.
	 * @param onfulfilled The callback to execute when the Promise is resolved.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of which ever callback is executed.
	 */
	then<TResult1 = T, TResult2 = never>(
		onfulfilled?:
			| ((value: T) => TResult1 | PromiseLike<TResult1>)
			| undefined
			| null,
		onrejected?:
			| ((reason: any) => TResult2 | PromiseLike<TResult2>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
	/**
	 * Attaches a callback for only the rejection of the Promise.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of the callback.
	 */
	catch<TResult = never>(
		onrejected?:
			| ((reason: any) => TResult | PromiseLike<TResult>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<T | TResult>;
	/**
	 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
	 * resolved value cannot be modified from the callback.
	 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
	 * @returns A Promise for the completion of the callback.
	 */
	finally(
		onfinally?: (() => void) | undefined | null,
	): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the CollaborativeChallenge model
 */
export interface CollaborativeChallengeFieldRefs {
	readonly id: Prisma.FieldRef<"CollaborativeChallenge", "String">;
	readonly challengeId: Prisma.FieldRef<"CollaborativeChallenge", "String">;
	readonly initiatorUserId: Prisma.FieldRef<"CollaborativeChallenge", "String">;
	readonly partnerUserId: Prisma.FieldRef<"CollaborativeChallenge", "String">;
	readonly initiatorCompleted: Prisma.FieldRef<
		"CollaborativeChallenge",
		"Boolean"
	>;
	readonly partnerCompleted: Prisma.FieldRef<
		"CollaborativeChallenge",
		"Boolean"
	>;
	readonly initiatorCompletedAt: Prisma.FieldRef<
		"CollaborativeChallenge",
		"DateTime"
	>;
	readonly partnerCompletedAt: Prisma.FieldRef<
		"CollaborativeChallenge",
		"DateTime"
	>;
	readonly xpBonusAwarded: Prisma.FieldRef<"CollaborativeChallenge", "Int">;
	readonly status: Prisma.FieldRef<"CollaborativeChallenge", "String">;
	readonly expiresAt: Prisma.FieldRef<"CollaborativeChallenge", "DateTime">;
	readonly createdAt: Prisma.FieldRef<"CollaborativeChallenge", "DateTime">;
	readonly updatedAt: Prisma.FieldRef<"CollaborativeChallenge", "DateTime">;
}

// Custom InputTypes
/**
 * CollaborativeChallenge findUnique
 */
export type CollaborativeChallengeFindUniqueArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the CollaborativeChallenge
	 */
	select?: Prisma.CollaborativeChallengeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the CollaborativeChallenge
	 */
	omit?: Prisma.CollaborativeChallengeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CollaborativeChallengeInclude<ExtArgs> | null;
	/**
	 * Filter, which CollaborativeChallenge to fetch.
	 */
	where: Prisma.CollaborativeChallengeWhereUniqueInput;
};

/**
 * CollaborativeChallenge findUniqueOrThrow
 */
export type CollaborativeChallengeFindUniqueOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the CollaborativeChallenge
	 */
	select?: Prisma.CollaborativeChallengeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the CollaborativeChallenge
	 */
	omit?: Prisma.CollaborativeChallengeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CollaborativeChallengeInclude<ExtArgs> | null;
	/**
	 * Filter, which CollaborativeChallenge to fetch.
	 */
	where: Prisma.CollaborativeChallengeWhereUniqueInput;
};

/**
 * CollaborativeChallenge findFirst
 */
export type CollaborativeChallengeFindFirstArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the CollaborativeChallenge
	 */
	select?: Prisma.CollaborativeChallengeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the CollaborativeChallenge
	 */
	omit?: Prisma.CollaborativeChallengeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CollaborativeChallengeInclude<ExtArgs> | null;
	/**
	 * Filter, which CollaborativeChallenge to fetch.
	 */
	where?: Prisma.CollaborativeChallengeWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of CollaborativeChallenges to fetch.
	 */
	orderBy?:
		| Prisma.CollaborativeChallengeOrderByWithRelationInput
		| Prisma.CollaborativeChallengeOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for CollaborativeChallenges.
	 */
	cursor?: Prisma.CollaborativeChallengeWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` CollaborativeChallenges from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` CollaborativeChallenges.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of CollaborativeChallenges.
	 */
	distinct?:
		| Prisma.CollaborativeChallengeScalarFieldEnum
		| Prisma.CollaborativeChallengeScalarFieldEnum[];
};

/**
 * CollaborativeChallenge findFirstOrThrow
 */
export type CollaborativeChallengeFindFirstOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the CollaborativeChallenge
	 */
	select?: Prisma.CollaborativeChallengeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the CollaborativeChallenge
	 */
	omit?: Prisma.CollaborativeChallengeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CollaborativeChallengeInclude<ExtArgs> | null;
	/**
	 * Filter, which CollaborativeChallenge to fetch.
	 */
	where?: Prisma.CollaborativeChallengeWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of CollaborativeChallenges to fetch.
	 */
	orderBy?:
		| Prisma.CollaborativeChallengeOrderByWithRelationInput
		| Prisma.CollaborativeChallengeOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for CollaborativeChallenges.
	 */
	cursor?: Prisma.CollaborativeChallengeWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` CollaborativeChallenges from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` CollaborativeChallenges.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of CollaborativeChallenges.
	 */
	distinct?:
		| Prisma.CollaborativeChallengeScalarFieldEnum
		| Prisma.CollaborativeChallengeScalarFieldEnum[];
};

/**
 * CollaborativeChallenge findMany
 */
export type CollaborativeChallengeFindManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the CollaborativeChallenge
	 */
	select?: Prisma.CollaborativeChallengeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the CollaborativeChallenge
	 */
	omit?: Prisma.CollaborativeChallengeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CollaborativeChallengeInclude<ExtArgs> | null;
	/**
	 * Filter, which CollaborativeChallenges to fetch.
	 */
	where?: Prisma.CollaborativeChallengeWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of CollaborativeChallenges to fetch.
	 */
	orderBy?:
		| Prisma.CollaborativeChallengeOrderByWithRelationInput
		| Prisma.CollaborativeChallengeOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for listing CollaborativeChallenges.
	 */
	cursor?: Prisma.CollaborativeChallengeWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` CollaborativeChallenges from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` CollaborativeChallenges.
	 */
	skip?: number;
	distinct?:
		| Prisma.CollaborativeChallengeScalarFieldEnum
		| Prisma.CollaborativeChallengeScalarFieldEnum[];
};

/**
 * CollaborativeChallenge create
 */
export type CollaborativeChallengeCreateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the CollaborativeChallenge
	 */
	select?: Prisma.CollaborativeChallengeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the CollaborativeChallenge
	 */
	omit?: Prisma.CollaborativeChallengeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CollaborativeChallengeInclude<ExtArgs> | null;
	/**
	 * The data needed to create a CollaborativeChallenge.
	 */
	data: Prisma.XOR<
		Prisma.CollaborativeChallengeCreateInput,
		Prisma.CollaborativeChallengeUncheckedCreateInput
	>;
};

/**
 * CollaborativeChallenge createMany
 */
export type CollaborativeChallengeCreateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to create many CollaborativeChallenges.
	 */
	data:
		| Prisma.CollaborativeChallengeCreateManyInput
		| Prisma.CollaborativeChallengeCreateManyInput[];
};

/**
 * CollaborativeChallenge createManyAndReturn
 */
export type CollaborativeChallengeCreateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the CollaborativeChallenge
	 */
	select?: Prisma.CollaborativeChallengeSelectCreateManyAndReturn<ExtArgs> | null;
	/**
	 * Omit specific fields from the CollaborativeChallenge
	 */
	omit?: Prisma.CollaborativeChallengeOmit<ExtArgs> | null;
	/**
	 * The data used to create many CollaborativeChallenges.
	 */
	data:
		| Prisma.CollaborativeChallengeCreateManyInput
		| Prisma.CollaborativeChallengeCreateManyInput[];
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CollaborativeChallengeIncludeCreateManyAndReturn<ExtArgs> | null;
};

/**
 * CollaborativeChallenge update
 */
export type CollaborativeChallengeUpdateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the CollaborativeChallenge
	 */
	select?: Prisma.CollaborativeChallengeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the CollaborativeChallenge
	 */
	omit?: Prisma.CollaborativeChallengeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CollaborativeChallengeInclude<ExtArgs> | null;
	/**
	 * The data needed to update a CollaborativeChallenge.
	 */
	data: Prisma.XOR<
		Prisma.CollaborativeChallengeUpdateInput,
		Prisma.CollaborativeChallengeUncheckedUpdateInput
	>;
	/**
	 * Choose, which CollaborativeChallenge to update.
	 */
	where: Prisma.CollaborativeChallengeWhereUniqueInput;
};

/**
 * CollaborativeChallenge updateMany
 */
export type CollaborativeChallengeUpdateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to update CollaborativeChallenges.
	 */
	data: Prisma.XOR<
		Prisma.CollaborativeChallengeUpdateManyMutationInput,
		Prisma.CollaborativeChallengeUncheckedUpdateManyInput
	>;
	/**
	 * Filter which CollaborativeChallenges to update
	 */
	where?: Prisma.CollaborativeChallengeWhereInput;
	/**
	 * Limit how many CollaborativeChallenges to update.
	 */
	limit?: number;
};

/**
 * CollaborativeChallenge updateManyAndReturn
 */
export type CollaborativeChallengeUpdateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the CollaborativeChallenge
	 */
	select?: Prisma.CollaborativeChallengeSelectUpdateManyAndReturn<ExtArgs> | null;
	/**
	 * Omit specific fields from the CollaborativeChallenge
	 */
	omit?: Prisma.CollaborativeChallengeOmit<ExtArgs> | null;
	/**
	 * The data used to update CollaborativeChallenges.
	 */
	data: Prisma.XOR<
		Prisma.CollaborativeChallengeUpdateManyMutationInput,
		Prisma.CollaborativeChallengeUncheckedUpdateManyInput
	>;
	/**
	 * Filter which CollaborativeChallenges to update
	 */
	where?: Prisma.CollaborativeChallengeWhereInput;
	/**
	 * Limit how many CollaborativeChallenges to update.
	 */
	limit?: number;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CollaborativeChallengeIncludeUpdateManyAndReturn<ExtArgs> | null;
};

/**
 * CollaborativeChallenge upsert
 */
export type CollaborativeChallengeUpsertArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the CollaborativeChallenge
	 */
	select?: Prisma.CollaborativeChallengeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the CollaborativeChallenge
	 */
	omit?: Prisma.CollaborativeChallengeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CollaborativeChallengeInclude<ExtArgs> | null;
	/**
	 * The filter to search for the CollaborativeChallenge to update in case it exists.
	 */
	where: Prisma.CollaborativeChallengeWhereUniqueInput;
	/**
	 * In case the CollaborativeChallenge found by the `where` argument doesn't exist, create a new CollaborativeChallenge with this data.
	 */
	create: Prisma.XOR<
		Prisma.CollaborativeChallengeCreateInput,
		Prisma.CollaborativeChallengeUncheckedCreateInput
	>;
	/**
	 * In case the CollaborativeChallenge was found with the provided `where` argument, update it with this data.
	 */
	update: Prisma.XOR<
		Prisma.CollaborativeChallengeUpdateInput,
		Prisma.CollaborativeChallengeUncheckedUpdateInput
	>;
};

/**
 * CollaborativeChallenge delete
 */
export type CollaborativeChallengeDeleteArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the CollaborativeChallenge
	 */
	select?: Prisma.CollaborativeChallengeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the CollaborativeChallenge
	 */
	omit?: Prisma.CollaborativeChallengeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CollaborativeChallengeInclude<ExtArgs> | null;
	/**
	 * Filter which CollaborativeChallenge to delete.
	 */
	where: Prisma.CollaborativeChallengeWhereUniqueInput;
};

/**
 * CollaborativeChallenge deleteMany
 */
export type CollaborativeChallengeDeleteManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which CollaborativeChallenges to delete
	 */
	where?: Prisma.CollaborativeChallengeWhereInput;
	/**
	 * Limit how many CollaborativeChallenges to delete.
	 */
	limit?: number;
};

/**
 * CollaborativeChallenge without action
 */
export type CollaborativeChallengeDefaultArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the CollaborativeChallenge
	 */
	select?: Prisma.CollaborativeChallengeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the CollaborativeChallenge
	 */
	omit?: Prisma.CollaborativeChallengeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CollaborativeChallengeInclude<ExtArgs> | null;
};
