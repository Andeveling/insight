/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports the `UserRecommendation` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client";
import type * as $Enums from "../enums";
import type * as Prisma from "../internal/prismaNamespace";

/**
 * Model UserRecommendation
 *
 */
export type UserRecommendationModel =
	runtime.Types.Result.DefaultSelection<Prisma.$UserRecommendationPayload>;

export type AggregateUserRecommendation = {
	_count: UserRecommendationCountAggregateOutputType | null;
	_min: UserRecommendationMinAggregateOutputType | null;
	_max: UserRecommendationMaxAggregateOutputType | null;
};

export type UserRecommendationMinAggregateOutputType = {
	id: string | null;
	userId: string | null;
	recommendationType: string | null;
	recommendations: string | null;
	strengthsHash: string | null;
	modelUsed: string | null;
	expiresAt: Date | null;
	createdAt: Date | null;
	updatedAt: Date | null;
};

export type UserRecommendationMaxAggregateOutputType = {
	id: string | null;
	userId: string | null;
	recommendationType: string | null;
	recommendations: string | null;
	strengthsHash: string | null;
	modelUsed: string | null;
	expiresAt: Date | null;
	createdAt: Date | null;
	updatedAt: Date | null;
};

export type UserRecommendationCountAggregateOutputType = {
	id: number;
	userId: number;
	recommendationType: number;
	recommendations: number;
	strengthsHash: number;
	modelUsed: number;
	expiresAt: number;
	createdAt: number;
	updatedAt: number;
	_all: number;
};

export type UserRecommendationMinAggregateInputType = {
	id?: true;
	userId?: true;
	recommendationType?: true;
	recommendations?: true;
	strengthsHash?: true;
	modelUsed?: true;
	expiresAt?: true;
	createdAt?: true;
	updatedAt?: true;
};

export type UserRecommendationMaxAggregateInputType = {
	id?: true;
	userId?: true;
	recommendationType?: true;
	recommendations?: true;
	strengthsHash?: true;
	modelUsed?: true;
	expiresAt?: true;
	createdAt?: true;
	updatedAt?: true;
};

export type UserRecommendationCountAggregateInputType = {
	id?: true;
	userId?: true;
	recommendationType?: true;
	recommendations?: true;
	strengthsHash?: true;
	modelUsed?: true;
	expiresAt?: true;
	createdAt?: true;
	updatedAt?: true;
	_all?: true;
};

export type UserRecommendationAggregateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which UserRecommendation to aggregate.
	 */
	where?: Prisma.UserRecommendationWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of UserRecommendations to fetch.
	 */
	orderBy?:
		| Prisma.UserRecommendationOrderByWithRelationInput
		| Prisma.UserRecommendationOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the start position
	 */
	cursor?: Prisma.UserRecommendationWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` UserRecommendations from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` UserRecommendations.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Count returned UserRecommendations
	 **/
	_count?: true | UserRecommendationCountAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the minimum value
	 **/
	_min?: UserRecommendationMinAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the maximum value
	 **/
	_max?: UserRecommendationMaxAggregateInputType;
};

export type GetUserRecommendationAggregateType<
	T extends UserRecommendationAggregateArgs,
> = {
	[P in keyof T & keyof AggregateUserRecommendation]: P extends
		| "_count"
		| "count"
		? T[P] extends true
			? number
			: Prisma.GetScalarType<T[P], AggregateUserRecommendation[P]>
		: Prisma.GetScalarType<T[P], AggregateUserRecommendation[P]>;
};

export type UserRecommendationGroupByArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.UserRecommendationWhereInput;
	orderBy?:
		| Prisma.UserRecommendationOrderByWithAggregationInput
		| Prisma.UserRecommendationOrderByWithAggregationInput[];
	by:
		| Prisma.UserRecommendationScalarFieldEnum[]
		| Prisma.UserRecommendationScalarFieldEnum;
	having?: Prisma.UserRecommendationScalarWhereWithAggregatesInput;
	take?: number;
	skip?: number;
	_count?: UserRecommendationCountAggregateInputType | true;
	_min?: UserRecommendationMinAggregateInputType;
	_max?: UserRecommendationMaxAggregateInputType;
};

export type UserRecommendationGroupByOutputType = {
	id: string;
	userId: string;
	recommendationType: string;
	recommendations: string;
	strengthsHash: string;
	modelUsed: string;
	expiresAt: Date;
	createdAt: Date;
	updatedAt: Date;
	_count: UserRecommendationCountAggregateOutputType | null;
	_min: UserRecommendationMinAggregateOutputType | null;
	_max: UserRecommendationMaxAggregateOutputType | null;
};

type GetUserRecommendationGroupByPayload<
	T extends UserRecommendationGroupByArgs,
> = Prisma.PrismaPromise<
	Array<
		Prisma.PickEnumerable<UserRecommendationGroupByOutputType, T["by"]> & {
			[P in keyof T &
				keyof UserRecommendationGroupByOutputType]: P extends "_count"
				? T[P] extends boolean
					? number
					: Prisma.GetScalarType<T[P], UserRecommendationGroupByOutputType[P]>
				: Prisma.GetScalarType<T[P], UserRecommendationGroupByOutputType[P]>;
		}
	>
>;

export type UserRecommendationWhereInput = {
	AND?:
		| Prisma.UserRecommendationWhereInput
		| Prisma.UserRecommendationWhereInput[];
	OR?: Prisma.UserRecommendationWhereInput[];
	NOT?:
		| Prisma.UserRecommendationWhereInput
		| Prisma.UserRecommendationWhereInput[];
	id?: Prisma.StringFilter<"UserRecommendation"> | string;
	userId?: Prisma.StringFilter<"UserRecommendation"> | string;
	recommendationType?: Prisma.StringFilter<"UserRecommendation"> | string;
	recommendations?: Prisma.StringFilter<"UserRecommendation"> | string;
	strengthsHash?: Prisma.StringFilter<"UserRecommendation"> | string;
	modelUsed?: Prisma.StringFilter<"UserRecommendation"> | string;
	expiresAt?: Prisma.DateTimeFilter<"UserRecommendation"> | Date | string;
	createdAt?: Prisma.DateTimeFilter<"UserRecommendation"> | Date | string;
	updatedAt?: Prisma.DateTimeFilter<"UserRecommendation"> | Date | string;
	user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>;
};

export type UserRecommendationOrderByWithRelationInput = {
	id?: Prisma.SortOrder;
	userId?: Prisma.SortOrder;
	recommendationType?: Prisma.SortOrder;
	recommendations?: Prisma.SortOrder;
	strengthsHash?: Prisma.SortOrder;
	modelUsed?: Prisma.SortOrder;
	expiresAt?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	user?: Prisma.UserOrderByWithRelationInput;
};

export type UserRecommendationWhereUniqueInput = Prisma.AtLeast<
	{
		id?: string;
		userId_recommendationType?: Prisma.UserRecommendationUserIdRecommendationTypeCompoundUniqueInput;
		AND?:
			| Prisma.UserRecommendationWhereInput
			| Prisma.UserRecommendationWhereInput[];
		OR?: Prisma.UserRecommendationWhereInput[];
		NOT?:
			| Prisma.UserRecommendationWhereInput
			| Prisma.UserRecommendationWhereInput[];
		userId?: Prisma.StringFilter<"UserRecommendation"> | string;
		recommendationType?: Prisma.StringFilter<"UserRecommendation"> | string;
		recommendations?: Prisma.StringFilter<"UserRecommendation"> | string;
		strengthsHash?: Prisma.StringFilter<"UserRecommendation"> | string;
		modelUsed?: Prisma.StringFilter<"UserRecommendation"> | string;
		expiresAt?: Prisma.DateTimeFilter<"UserRecommendation"> | Date | string;
		createdAt?: Prisma.DateTimeFilter<"UserRecommendation"> | Date | string;
		updatedAt?: Prisma.DateTimeFilter<"UserRecommendation"> | Date | string;
		user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>;
	},
	"id" | "userId_recommendationType"
>;

export type UserRecommendationOrderByWithAggregationInput = {
	id?: Prisma.SortOrder;
	userId?: Prisma.SortOrder;
	recommendationType?: Prisma.SortOrder;
	recommendations?: Prisma.SortOrder;
	strengthsHash?: Prisma.SortOrder;
	modelUsed?: Prisma.SortOrder;
	expiresAt?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	_count?: Prisma.UserRecommendationCountOrderByAggregateInput;
	_max?: Prisma.UserRecommendationMaxOrderByAggregateInput;
	_min?: Prisma.UserRecommendationMinOrderByAggregateInput;
};

export type UserRecommendationScalarWhereWithAggregatesInput = {
	AND?:
		| Prisma.UserRecommendationScalarWhereWithAggregatesInput
		| Prisma.UserRecommendationScalarWhereWithAggregatesInput[];
	OR?: Prisma.UserRecommendationScalarWhereWithAggregatesInput[];
	NOT?:
		| Prisma.UserRecommendationScalarWhereWithAggregatesInput
		| Prisma.UserRecommendationScalarWhereWithAggregatesInput[];
	id?: Prisma.StringWithAggregatesFilter<"UserRecommendation"> | string;
	userId?: Prisma.StringWithAggregatesFilter<"UserRecommendation"> | string;
	recommendationType?:
		| Prisma.StringWithAggregatesFilter<"UserRecommendation">
		| string;
	recommendations?:
		| Prisma.StringWithAggregatesFilter<"UserRecommendation">
		| string;
	strengthsHash?:
		| Prisma.StringWithAggregatesFilter<"UserRecommendation">
		| string;
	modelUsed?: Prisma.StringWithAggregatesFilter<"UserRecommendation"> | string;
	expiresAt?:
		| Prisma.DateTimeWithAggregatesFilter<"UserRecommendation">
		| Date
		| string;
	createdAt?:
		| Prisma.DateTimeWithAggregatesFilter<"UserRecommendation">
		| Date
		| string;
	updatedAt?:
		| Prisma.DateTimeWithAggregatesFilter<"UserRecommendation">
		| Date
		| string;
};

export type UserRecommendationCreateInput = {
	id?: string;
	recommendationType: string;
	recommendations: string;
	strengthsHash: string;
	modelUsed: string;
	expiresAt: Date | string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	user: Prisma.UserCreateNestedOneWithoutRecommendationsInput;
};

export type UserRecommendationUncheckedCreateInput = {
	id?: string;
	userId: string;
	recommendationType: string;
	recommendations: string;
	strengthsHash: string;
	modelUsed: string;
	expiresAt: Date | string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
};

export type UserRecommendationUpdateInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	recommendationType?: Prisma.StringFieldUpdateOperationsInput | string;
	recommendations?: Prisma.StringFieldUpdateOperationsInput | string;
	strengthsHash?: Prisma.StringFieldUpdateOperationsInput | string;
	modelUsed?: Prisma.StringFieldUpdateOperationsInput | string;
	expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	user?: Prisma.UserUpdateOneRequiredWithoutRecommendationsNestedInput;
};

export type UserRecommendationUncheckedUpdateInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	userId?: Prisma.StringFieldUpdateOperationsInput | string;
	recommendationType?: Prisma.StringFieldUpdateOperationsInput | string;
	recommendations?: Prisma.StringFieldUpdateOperationsInput | string;
	strengthsHash?: Prisma.StringFieldUpdateOperationsInput | string;
	modelUsed?: Prisma.StringFieldUpdateOperationsInput | string;
	expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type UserRecommendationCreateManyInput = {
	id?: string;
	userId: string;
	recommendationType: string;
	recommendations: string;
	strengthsHash: string;
	modelUsed: string;
	expiresAt: Date | string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
};

export type UserRecommendationUpdateManyMutationInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	recommendationType?: Prisma.StringFieldUpdateOperationsInput | string;
	recommendations?: Prisma.StringFieldUpdateOperationsInput | string;
	strengthsHash?: Prisma.StringFieldUpdateOperationsInput | string;
	modelUsed?: Prisma.StringFieldUpdateOperationsInput | string;
	expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type UserRecommendationUncheckedUpdateManyInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	userId?: Prisma.StringFieldUpdateOperationsInput | string;
	recommendationType?: Prisma.StringFieldUpdateOperationsInput | string;
	recommendations?: Prisma.StringFieldUpdateOperationsInput | string;
	strengthsHash?: Prisma.StringFieldUpdateOperationsInput | string;
	modelUsed?: Prisma.StringFieldUpdateOperationsInput | string;
	expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type UserRecommendationListRelationFilter = {
	every?: Prisma.UserRecommendationWhereInput;
	some?: Prisma.UserRecommendationWhereInput;
	none?: Prisma.UserRecommendationWhereInput;
};

export type UserRecommendationOrderByRelationAggregateInput = {
	_count?: Prisma.SortOrder;
};

export type UserRecommendationUserIdRecommendationTypeCompoundUniqueInput = {
	userId: string;
	recommendationType: string;
};

export type UserRecommendationCountOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	userId?: Prisma.SortOrder;
	recommendationType?: Prisma.SortOrder;
	recommendations?: Prisma.SortOrder;
	strengthsHash?: Prisma.SortOrder;
	modelUsed?: Prisma.SortOrder;
	expiresAt?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
};

export type UserRecommendationMaxOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	userId?: Prisma.SortOrder;
	recommendationType?: Prisma.SortOrder;
	recommendations?: Prisma.SortOrder;
	strengthsHash?: Prisma.SortOrder;
	modelUsed?: Prisma.SortOrder;
	expiresAt?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
};

export type UserRecommendationMinOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	userId?: Prisma.SortOrder;
	recommendationType?: Prisma.SortOrder;
	recommendations?: Prisma.SortOrder;
	strengthsHash?: Prisma.SortOrder;
	modelUsed?: Prisma.SortOrder;
	expiresAt?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
};

export type UserRecommendationCreateNestedManyWithoutUserInput = {
	create?:
		| Prisma.XOR<
				Prisma.UserRecommendationCreateWithoutUserInput,
				Prisma.UserRecommendationUncheckedCreateWithoutUserInput
		  >
		| Prisma.UserRecommendationCreateWithoutUserInput[]
		| Prisma.UserRecommendationUncheckedCreateWithoutUserInput[];
	connectOrCreate?:
		| Prisma.UserRecommendationCreateOrConnectWithoutUserInput
		| Prisma.UserRecommendationCreateOrConnectWithoutUserInput[];
	createMany?: Prisma.UserRecommendationCreateManyUserInputEnvelope;
	connect?:
		| Prisma.UserRecommendationWhereUniqueInput
		| Prisma.UserRecommendationWhereUniqueInput[];
};

export type UserRecommendationUncheckedCreateNestedManyWithoutUserInput = {
	create?:
		| Prisma.XOR<
				Prisma.UserRecommendationCreateWithoutUserInput,
				Prisma.UserRecommendationUncheckedCreateWithoutUserInput
		  >
		| Prisma.UserRecommendationCreateWithoutUserInput[]
		| Prisma.UserRecommendationUncheckedCreateWithoutUserInput[];
	connectOrCreate?:
		| Prisma.UserRecommendationCreateOrConnectWithoutUserInput
		| Prisma.UserRecommendationCreateOrConnectWithoutUserInput[];
	createMany?: Prisma.UserRecommendationCreateManyUserInputEnvelope;
	connect?:
		| Prisma.UserRecommendationWhereUniqueInput
		| Prisma.UserRecommendationWhereUniqueInput[];
};

export type UserRecommendationUpdateManyWithoutUserNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.UserRecommendationCreateWithoutUserInput,
				Prisma.UserRecommendationUncheckedCreateWithoutUserInput
		  >
		| Prisma.UserRecommendationCreateWithoutUserInput[]
		| Prisma.UserRecommendationUncheckedCreateWithoutUserInput[];
	connectOrCreate?:
		| Prisma.UserRecommendationCreateOrConnectWithoutUserInput
		| Prisma.UserRecommendationCreateOrConnectWithoutUserInput[];
	upsert?:
		| Prisma.UserRecommendationUpsertWithWhereUniqueWithoutUserInput
		| Prisma.UserRecommendationUpsertWithWhereUniqueWithoutUserInput[];
	createMany?: Prisma.UserRecommendationCreateManyUserInputEnvelope;
	set?:
		| Prisma.UserRecommendationWhereUniqueInput
		| Prisma.UserRecommendationWhereUniqueInput[];
	disconnect?:
		| Prisma.UserRecommendationWhereUniqueInput
		| Prisma.UserRecommendationWhereUniqueInput[];
	delete?:
		| Prisma.UserRecommendationWhereUniqueInput
		| Prisma.UserRecommendationWhereUniqueInput[];
	connect?:
		| Prisma.UserRecommendationWhereUniqueInput
		| Prisma.UserRecommendationWhereUniqueInput[];
	update?:
		| Prisma.UserRecommendationUpdateWithWhereUniqueWithoutUserInput
		| Prisma.UserRecommendationUpdateWithWhereUniqueWithoutUserInput[];
	updateMany?:
		| Prisma.UserRecommendationUpdateManyWithWhereWithoutUserInput
		| Prisma.UserRecommendationUpdateManyWithWhereWithoutUserInput[];
	deleteMany?:
		| Prisma.UserRecommendationScalarWhereInput
		| Prisma.UserRecommendationScalarWhereInput[];
};

export type UserRecommendationUncheckedUpdateManyWithoutUserNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.UserRecommendationCreateWithoutUserInput,
				Prisma.UserRecommendationUncheckedCreateWithoutUserInput
		  >
		| Prisma.UserRecommendationCreateWithoutUserInput[]
		| Prisma.UserRecommendationUncheckedCreateWithoutUserInput[];
	connectOrCreate?:
		| Prisma.UserRecommendationCreateOrConnectWithoutUserInput
		| Prisma.UserRecommendationCreateOrConnectWithoutUserInput[];
	upsert?:
		| Prisma.UserRecommendationUpsertWithWhereUniqueWithoutUserInput
		| Prisma.UserRecommendationUpsertWithWhereUniqueWithoutUserInput[];
	createMany?: Prisma.UserRecommendationCreateManyUserInputEnvelope;
	set?:
		| Prisma.UserRecommendationWhereUniqueInput
		| Prisma.UserRecommendationWhereUniqueInput[];
	disconnect?:
		| Prisma.UserRecommendationWhereUniqueInput
		| Prisma.UserRecommendationWhereUniqueInput[];
	delete?:
		| Prisma.UserRecommendationWhereUniqueInput
		| Prisma.UserRecommendationWhereUniqueInput[];
	connect?:
		| Prisma.UserRecommendationWhereUniqueInput
		| Prisma.UserRecommendationWhereUniqueInput[];
	update?:
		| Prisma.UserRecommendationUpdateWithWhereUniqueWithoutUserInput
		| Prisma.UserRecommendationUpdateWithWhereUniqueWithoutUserInput[];
	updateMany?:
		| Prisma.UserRecommendationUpdateManyWithWhereWithoutUserInput
		| Prisma.UserRecommendationUpdateManyWithWhereWithoutUserInput[];
	deleteMany?:
		| Prisma.UserRecommendationScalarWhereInput
		| Prisma.UserRecommendationScalarWhereInput[];
};

export type UserRecommendationCreateWithoutUserInput = {
	id?: string;
	recommendationType: string;
	recommendations: string;
	strengthsHash: string;
	modelUsed: string;
	expiresAt: Date | string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
};

export type UserRecommendationUncheckedCreateWithoutUserInput = {
	id?: string;
	recommendationType: string;
	recommendations: string;
	strengthsHash: string;
	modelUsed: string;
	expiresAt: Date | string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
};

export type UserRecommendationCreateOrConnectWithoutUserInput = {
	where: Prisma.UserRecommendationWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.UserRecommendationCreateWithoutUserInput,
		Prisma.UserRecommendationUncheckedCreateWithoutUserInput
	>;
};

export type UserRecommendationCreateManyUserInputEnvelope = {
	data:
		| Prisma.UserRecommendationCreateManyUserInput
		| Prisma.UserRecommendationCreateManyUserInput[];
};

export type UserRecommendationUpsertWithWhereUniqueWithoutUserInput = {
	where: Prisma.UserRecommendationWhereUniqueInput;
	update: Prisma.XOR<
		Prisma.UserRecommendationUpdateWithoutUserInput,
		Prisma.UserRecommendationUncheckedUpdateWithoutUserInput
	>;
	create: Prisma.XOR<
		Prisma.UserRecommendationCreateWithoutUserInput,
		Prisma.UserRecommendationUncheckedCreateWithoutUserInput
	>;
};

export type UserRecommendationUpdateWithWhereUniqueWithoutUserInput = {
	where: Prisma.UserRecommendationWhereUniqueInput;
	data: Prisma.XOR<
		Prisma.UserRecommendationUpdateWithoutUserInput,
		Prisma.UserRecommendationUncheckedUpdateWithoutUserInput
	>;
};

export type UserRecommendationUpdateManyWithWhereWithoutUserInput = {
	where: Prisma.UserRecommendationScalarWhereInput;
	data: Prisma.XOR<
		Prisma.UserRecommendationUpdateManyMutationInput,
		Prisma.UserRecommendationUncheckedUpdateManyWithoutUserInput
	>;
};

export type UserRecommendationScalarWhereInput = {
	AND?:
		| Prisma.UserRecommendationScalarWhereInput
		| Prisma.UserRecommendationScalarWhereInput[];
	OR?: Prisma.UserRecommendationScalarWhereInput[];
	NOT?:
		| Prisma.UserRecommendationScalarWhereInput
		| Prisma.UserRecommendationScalarWhereInput[];
	id?: Prisma.StringFilter<"UserRecommendation"> | string;
	userId?: Prisma.StringFilter<"UserRecommendation"> | string;
	recommendationType?: Prisma.StringFilter<"UserRecommendation"> | string;
	recommendations?: Prisma.StringFilter<"UserRecommendation"> | string;
	strengthsHash?: Prisma.StringFilter<"UserRecommendation"> | string;
	modelUsed?: Prisma.StringFilter<"UserRecommendation"> | string;
	expiresAt?: Prisma.DateTimeFilter<"UserRecommendation"> | Date | string;
	createdAt?: Prisma.DateTimeFilter<"UserRecommendation"> | Date | string;
	updatedAt?: Prisma.DateTimeFilter<"UserRecommendation"> | Date | string;
};

export type UserRecommendationCreateManyUserInput = {
	id?: string;
	recommendationType: string;
	recommendations: string;
	strengthsHash: string;
	modelUsed: string;
	expiresAt: Date | string;
	createdAt?: Date | string;
	updatedAt?: Date | string;
};

export type UserRecommendationUpdateWithoutUserInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	recommendationType?: Prisma.StringFieldUpdateOperationsInput | string;
	recommendations?: Prisma.StringFieldUpdateOperationsInput | string;
	strengthsHash?: Prisma.StringFieldUpdateOperationsInput | string;
	modelUsed?: Prisma.StringFieldUpdateOperationsInput | string;
	expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type UserRecommendationUncheckedUpdateWithoutUserInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	recommendationType?: Prisma.StringFieldUpdateOperationsInput | string;
	recommendations?: Prisma.StringFieldUpdateOperationsInput | string;
	strengthsHash?: Prisma.StringFieldUpdateOperationsInput | string;
	modelUsed?: Prisma.StringFieldUpdateOperationsInput | string;
	expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type UserRecommendationUncheckedUpdateManyWithoutUserInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	recommendationType?: Prisma.StringFieldUpdateOperationsInput | string;
	recommendations?: Prisma.StringFieldUpdateOperationsInput | string;
	strengthsHash?: Prisma.StringFieldUpdateOperationsInput | string;
	modelUsed?: Prisma.StringFieldUpdateOperationsInput | string;
	expiresAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
};

export type UserRecommendationSelect<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		userId?: boolean;
		recommendationType?: boolean;
		recommendations?: boolean;
		strengthsHash?: boolean;
		modelUsed?: boolean;
		expiresAt?: boolean;
		createdAt?: boolean;
		updatedAt?: boolean;
		user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
	},
	ExtArgs["result"]["userRecommendation"]
>;

export type UserRecommendationSelectCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		userId?: boolean;
		recommendationType?: boolean;
		recommendations?: boolean;
		strengthsHash?: boolean;
		modelUsed?: boolean;
		expiresAt?: boolean;
		createdAt?: boolean;
		updatedAt?: boolean;
		user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
	},
	ExtArgs["result"]["userRecommendation"]
>;

export type UserRecommendationSelectUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		userId?: boolean;
		recommendationType?: boolean;
		recommendations?: boolean;
		strengthsHash?: boolean;
		modelUsed?: boolean;
		expiresAt?: boolean;
		createdAt?: boolean;
		updatedAt?: boolean;
		user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
	},
	ExtArgs["result"]["userRecommendation"]
>;

export type UserRecommendationSelectScalar = {
	id?: boolean;
	userId?: boolean;
	recommendationType?: boolean;
	recommendations?: boolean;
	strengthsHash?: boolean;
	modelUsed?: boolean;
	expiresAt?: boolean;
	createdAt?: boolean;
	updatedAt?: boolean;
};

export type UserRecommendationOmit<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
	| "id"
	| "userId"
	| "recommendationType"
	| "recommendations"
	| "strengthsHash"
	| "modelUsed"
	| "expiresAt"
	| "createdAt"
	| "updatedAt",
	ExtArgs["result"]["userRecommendation"]
>;
export type UserRecommendationInclude<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
};
export type UserRecommendationIncludeCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
};
export type UserRecommendationIncludeUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
};

export type $UserRecommendationPayload<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	name: "UserRecommendation";
	objects: {
		user: Prisma.$UserPayload<ExtArgs>;
	};
	scalars: runtime.Types.Extensions.GetPayloadResult<
		{
			id: string;
			userId: string;
			recommendationType: string;
			recommendations: string;
			strengthsHash: string;
			modelUsed: string;
			expiresAt: Date;
			createdAt: Date;
			updatedAt: Date;
		},
		ExtArgs["result"]["userRecommendation"]
	>;
	composites: {};
};

export type UserRecommendationGetPayload<
	S extends boolean | null | undefined | UserRecommendationDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$UserRecommendationPayload, S>;

export type UserRecommendationCountArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = Omit<
	UserRecommendationFindManyArgs,
	"select" | "include" | "distinct" | "omit"
> & {
	select?: UserRecommendationCountAggregateInputType | true;
};

export interface UserRecommendationDelegate<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> {
	[K: symbol]: {
		types: Prisma.TypeMap<ExtArgs>["model"]["UserRecommendation"];
		meta: { name: "UserRecommendation" };
	};
	/**
	 * Find zero or one UserRecommendation that matches the filter.
	 * @param {UserRecommendationFindUniqueArgs} args - Arguments to find a UserRecommendation
	 * @example
	 * // Get one UserRecommendation
	 * const userRecommendation = await prisma.userRecommendation.findUnique({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUnique<T extends UserRecommendationFindUniqueArgs>(
		args: Prisma.SelectSubset<T, UserRecommendationFindUniqueArgs<ExtArgs>>,
	): Prisma.Prisma__UserRecommendationClient<
		runtime.Types.Result.GetResult<
			Prisma.$UserRecommendationPayload<ExtArgs>,
			T,
			"findUnique",
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find one UserRecommendation that matches the filter or throw an error with `error.code='P2025'`
	 * if no matches were found.
	 * @param {UserRecommendationFindUniqueOrThrowArgs} args - Arguments to find a UserRecommendation
	 * @example
	 * // Get one UserRecommendation
	 * const userRecommendation = await prisma.userRecommendation.findUniqueOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUniqueOrThrow<T extends UserRecommendationFindUniqueOrThrowArgs>(
		args: Prisma.SelectSubset<
			T,
			UserRecommendationFindUniqueOrThrowArgs<ExtArgs>
		>,
	): Prisma.Prisma__UserRecommendationClient<
		runtime.Types.Result.GetResult<
			Prisma.$UserRecommendationPayload<ExtArgs>,
			T,
			"findUniqueOrThrow",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first UserRecommendation that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {UserRecommendationFindFirstArgs} args - Arguments to find a UserRecommendation
	 * @example
	 * // Get one UserRecommendation
	 * const userRecommendation = await prisma.userRecommendation.findFirst({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirst<T extends UserRecommendationFindFirstArgs>(
		args?: Prisma.SelectSubset<T, UserRecommendationFindFirstArgs<ExtArgs>>,
	): Prisma.Prisma__UserRecommendationClient<
		runtime.Types.Result.GetResult<
			Prisma.$UserRecommendationPayload<ExtArgs>,
			T,
			"findFirst",
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first UserRecommendation that matches the filter or
	 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {UserRecommendationFindFirstOrThrowArgs} args - Arguments to find a UserRecommendation
	 * @example
	 * // Get one UserRecommendation
	 * const userRecommendation = await prisma.userRecommendation.findFirstOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirstOrThrow<T extends UserRecommendationFindFirstOrThrowArgs>(
		args?: Prisma.SelectSubset<
			T,
			UserRecommendationFindFirstOrThrowArgs<ExtArgs>
		>,
	): Prisma.Prisma__UserRecommendationClient<
		runtime.Types.Result.GetResult<
			Prisma.$UserRecommendationPayload<ExtArgs>,
			T,
			"findFirstOrThrow",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find zero or more UserRecommendations that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {UserRecommendationFindManyArgs} args - Arguments to filter and select certain fields only.
	 * @example
	 * // Get all UserRecommendations
	 * const userRecommendations = await prisma.userRecommendation.findMany()
	 *
	 * // Get first 10 UserRecommendations
	 * const userRecommendations = await prisma.userRecommendation.findMany({ take: 10 })
	 *
	 * // Only select the `id`
	 * const userRecommendationWithIdOnly = await prisma.userRecommendation.findMany({ select: { id: true } })
	 *
	 */
	findMany<T extends UserRecommendationFindManyArgs>(
		args?: Prisma.SelectSubset<T, UserRecommendationFindManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$UserRecommendationPayload<ExtArgs>,
			T,
			"findMany",
			GlobalOmitOptions
		>
	>;

	/**
	 * Create a UserRecommendation.
	 * @param {UserRecommendationCreateArgs} args - Arguments to create a UserRecommendation.
	 * @example
	 * // Create one UserRecommendation
	 * const UserRecommendation = await prisma.userRecommendation.create({
	 *   data: {
	 *     // ... data to create a UserRecommendation
	 *   }
	 * })
	 *
	 */
	create<T extends UserRecommendationCreateArgs>(
		args: Prisma.SelectSubset<T, UserRecommendationCreateArgs<ExtArgs>>,
	): Prisma.Prisma__UserRecommendationClient<
		runtime.Types.Result.GetResult<
			Prisma.$UserRecommendationPayload<ExtArgs>,
			T,
			"create",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Create many UserRecommendations.
	 * @param {UserRecommendationCreateManyArgs} args - Arguments to create many UserRecommendations.
	 * @example
	 * // Create many UserRecommendations
	 * const userRecommendation = await prisma.userRecommendation.createMany({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 */
	createMany<T extends UserRecommendationCreateManyArgs>(
		args?: Prisma.SelectSubset<T, UserRecommendationCreateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Create many UserRecommendations and returns the data saved in the database.
	 * @param {UserRecommendationCreateManyAndReturnArgs} args - Arguments to create many UserRecommendations.
	 * @example
	 * // Create many UserRecommendations
	 * const userRecommendation = await prisma.userRecommendation.createManyAndReturn({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Create many UserRecommendations and only return the `id`
	 * const userRecommendationWithIdOnly = await prisma.userRecommendation.createManyAndReturn({
	 *   select: { id: true },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 *
	 */
	createManyAndReturn<T extends UserRecommendationCreateManyAndReturnArgs>(
		args?: Prisma.SelectSubset<
			T,
			UserRecommendationCreateManyAndReturnArgs<ExtArgs>
		>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$UserRecommendationPayload<ExtArgs>,
			T,
			"createManyAndReturn",
			GlobalOmitOptions
		>
	>;

	/**
	 * Delete a UserRecommendation.
	 * @param {UserRecommendationDeleteArgs} args - Arguments to delete one UserRecommendation.
	 * @example
	 * // Delete one UserRecommendation
	 * const UserRecommendation = await prisma.userRecommendation.delete({
	 *   where: {
	 *     // ... filter to delete one UserRecommendation
	 *   }
	 * })
	 *
	 */
	delete<T extends UserRecommendationDeleteArgs>(
		args: Prisma.SelectSubset<T, UserRecommendationDeleteArgs<ExtArgs>>,
	): Prisma.Prisma__UserRecommendationClient<
		runtime.Types.Result.GetResult<
			Prisma.$UserRecommendationPayload<ExtArgs>,
			T,
			"delete",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Update one UserRecommendation.
	 * @param {UserRecommendationUpdateArgs} args - Arguments to update one UserRecommendation.
	 * @example
	 * // Update one UserRecommendation
	 * const userRecommendation = await prisma.userRecommendation.update({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	update<T extends UserRecommendationUpdateArgs>(
		args: Prisma.SelectSubset<T, UserRecommendationUpdateArgs<ExtArgs>>,
	): Prisma.Prisma__UserRecommendationClient<
		runtime.Types.Result.GetResult<
			Prisma.$UserRecommendationPayload<ExtArgs>,
			T,
			"update",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Delete zero or more UserRecommendations.
	 * @param {UserRecommendationDeleteManyArgs} args - Arguments to filter UserRecommendations to delete.
	 * @example
	 * // Delete a few UserRecommendations
	 * const { count } = await prisma.userRecommendation.deleteMany({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 *
	 */
	deleteMany<T extends UserRecommendationDeleteManyArgs>(
		args?: Prisma.SelectSubset<T, UserRecommendationDeleteManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Update zero or more UserRecommendations.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {UserRecommendationUpdateManyArgs} args - Arguments to update one or more rows.
	 * @example
	 * // Update many UserRecommendations
	 * const userRecommendation = await prisma.userRecommendation.updateMany({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	updateMany<T extends UserRecommendationUpdateManyArgs>(
		args: Prisma.SelectSubset<T, UserRecommendationUpdateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Update zero or more UserRecommendations and returns the data updated in the database.
	 * @param {UserRecommendationUpdateManyAndReturnArgs} args - Arguments to update many UserRecommendations.
	 * @example
	 * // Update many UserRecommendations
	 * const userRecommendation = await prisma.userRecommendation.updateManyAndReturn({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Update zero or more UserRecommendations and only return the `id`
	 * const userRecommendationWithIdOnly = await prisma.userRecommendation.updateManyAndReturn({
	 *   select: { id: true },
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 *
	 */
	updateManyAndReturn<T extends UserRecommendationUpdateManyAndReturnArgs>(
		args: Prisma.SelectSubset<
			T,
			UserRecommendationUpdateManyAndReturnArgs<ExtArgs>
		>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$UserRecommendationPayload<ExtArgs>,
			T,
			"updateManyAndReturn",
			GlobalOmitOptions
		>
	>;

	/**
	 * Create or update one UserRecommendation.
	 * @param {UserRecommendationUpsertArgs} args - Arguments to update or create a UserRecommendation.
	 * @example
	 * // Update or create a UserRecommendation
	 * const userRecommendation = await prisma.userRecommendation.upsert({
	 *   create: {
	 *     // ... data to create a UserRecommendation
	 *   },
	 *   update: {
	 *     // ... in case it already exists, update
	 *   },
	 *   where: {
	 *     // ... the filter for the UserRecommendation we want to update
	 *   }
	 * })
	 */
	upsert<T extends UserRecommendationUpsertArgs>(
		args: Prisma.SelectSubset<T, UserRecommendationUpsertArgs<ExtArgs>>,
	): Prisma.Prisma__UserRecommendationClient<
		runtime.Types.Result.GetResult<
			Prisma.$UserRecommendationPayload<ExtArgs>,
			T,
			"upsert",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Count the number of UserRecommendations.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {UserRecommendationCountArgs} args - Arguments to filter UserRecommendations to count.
	 * @example
	 * // Count the number of UserRecommendations
	 * const count = await prisma.userRecommendation.count({
	 *   where: {
	 *     // ... the filter for the UserRecommendations we want to count
	 *   }
	 * })
	 **/
	count<T extends UserRecommendationCountArgs>(
		args?: Prisma.Subset<T, UserRecommendationCountArgs>,
	): Prisma.PrismaPromise<
		T extends runtime.Types.Utils.Record<"select", any>
			? T["select"] extends true
				? number
				: Prisma.GetScalarType<
						T["select"],
						UserRecommendationCountAggregateOutputType
					>
			: number
	>;

	/**
	 * Allows you to perform aggregations operations on a UserRecommendation.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {UserRecommendationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
	 * @example
	 * // Ordered by age ascending
	 * // Where email contains prisma.io
	 * // Limited to the 10 users
	 * const aggregations = await prisma.user.aggregate({
	 *   _avg: {
	 *     age: true,
	 *   },
	 *   where: {
	 *     email: {
	 *       contains: "prisma.io",
	 *     },
	 *   },
	 *   orderBy: {
	 *     age: "asc",
	 *   },
	 *   take: 10,
	 * })
	 **/
	aggregate<T extends UserRecommendationAggregateArgs>(
		args: Prisma.Subset<T, UserRecommendationAggregateArgs>,
	): Prisma.PrismaPromise<GetUserRecommendationAggregateType<T>>;

	/**
	 * Group by UserRecommendation.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {UserRecommendationGroupByArgs} args - Group by arguments.
	 * @example
	 * // Group by city, order by createdAt, get count
	 * const result = await prisma.user.groupBy({
	 *   by: ['city', 'createdAt'],
	 *   orderBy: {
	 *     createdAt: true
	 *   },
	 *   _count: {
	 *     _all: true
	 *   },
	 * })
	 *
	 **/
	groupBy<
		T extends UserRecommendationGroupByArgs,
		HasSelectOrTake extends Prisma.Or<
			Prisma.Extends<"skip", Prisma.Keys<T>>,
			Prisma.Extends<"take", Prisma.Keys<T>>
		>,
		OrderByArg extends Prisma.True extends HasSelectOrTake
			? { orderBy: UserRecommendationGroupByArgs["orderBy"] }
			: { orderBy?: UserRecommendationGroupByArgs["orderBy"] },
		OrderFields extends Prisma.ExcludeUnderscoreKeys<
			Prisma.Keys<Prisma.MaybeTupleToUnion<T["orderBy"]>>
		>,
		ByFields extends Prisma.MaybeTupleToUnion<T["by"]>,
		ByValid extends Prisma.Has<ByFields, OrderFields>,
		HavingFields extends Prisma.GetHavingFields<T["having"]>,
		HavingValid extends Prisma.Has<ByFields, HavingFields>,
		ByEmpty extends T["by"] extends never[] ? Prisma.True : Prisma.False,
		InputErrors extends ByEmpty extends Prisma.True
			? `Error: "by" must not be empty.`
			: HavingValid extends Prisma.False
				? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
										Error,
										"Field ",
										P,
										` in "having" needs to be provided in "by"`,
									];
					}[HavingFields]
				: "take" extends Prisma.Keys<T>
					? "orderBy" extends Prisma.Keys<T>
						? ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields]
						: 'Error: If you provide "take", you also need to provide "orderBy"'
					: "skip" extends Prisma.Keys<T>
						? "orderBy" extends Prisma.Keys<T>
							? ByValid extends Prisma.True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
									}[OrderFields]
							: 'Error: If you provide "skip", you also need to provide "orderBy"'
						: ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields],
	>(
		args: Prisma.SubsetIntersection<
			T,
			UserRecommendationGroupByArgs,
			OrderByArg
		> &
			InputErrors,
	): {} extends InputErrors
		? GetUserRecommendationGroupByPayload<T>
		: Prisma.PrismaPromise<InputErrors>;
	/**
	 * Fields of the UserRecommendation model
	 */
	readonly fields: UserRecommendationFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for UserRecommendation.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__UserRecommendationClient<
	T,
	Null = never,
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
	readonly [Symbol.toStringTag]: "PrismaPromise";
	user<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>,
	): Prisma.Prisma__UserClient<
		| runtime.Types.Result.GetResult<
				Prisma.$UserPayload<ExtArgs>,
				T,
				"findUniqueOrThrow",
				GlobalOmitOptions
		  >
		| Null,
		Null,
		ExtArgs,
		GlobalOmitOptions
	>;
	/**
	 * Attaches callbacks for the resolution and/or rejection of the Promise.
	 * @param onfulfilled The callback to execute when the Promise is resolved.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of which ever callback is executed.
	 */
	then<TResult1 = T, TResult2 = never>(
		onfulfilled?:
			| ((value: T) => TResult1 | PromiseLike<TResult1>)
			| undefined
			| null,
		onrejected?:
			| ((reason: any) => TResult2 | PromiseLike<TResult2>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
	/**
	 * Attaches a callback for only the rejection of the Promise.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of the callback.
	 */
	catch<TResult = never>(
		onrejected?:
			| ((reason: any) => TResult | PromiseLike<TResult>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<T | TResult>;
	/**
	 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
	 * resolved value cannot be modified from the callback.
	 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
	 * @returns A Promise for the completion of the callback.
	 */
	finally(
		onfinally?: (() => void) | undefined | null,
	): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the UserRecommendation model
 */
export interface UserRecommendationFieldRefs {
	readonly id: Prisma.FieldRef<"UserRecommendation", "String">;
	readonly userId: Prisma.FieldRef<"UserRecommendation", "String">;
	readonly recommendationType: Prisma.FieldRef<"UserRecommendation", "String">;
	readonly recommendations: Prisma.FieldRef<"UserRecommendation", "String">;
	readonly strengthsHash: Prisma.FieldRef<"UserRecommendation", "String">;
	readonly modelUsed: Prisma.FieldRef<"UserRecommendation", "String">;
	readonly expiresAt: Prisma.FieldRef<"UserRecommendation", "DateTime">;
	readonly createdAt: Prisma.FieldRef<"UserRecommendation", "DateTime">;
	readonly updatedAt: Prisma.FieldRef<"UserRecommendation", "DateTime">;
}

// Custom InputTypes
/**
 * UserRecommendation findUnique
 */
export type UserRecommendationFindUniqueArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the UserRecommendation
	 */
	select?: Prisma.UserRecommendationSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the UserRecommendation
	 */
	omit?: Prisma.UserRecommendationOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.UserRecommendationInclude<ExtArgs> | null;
	/**
	 * Filter, which UserRecommendation to fetch.
	 */
	where: Prisma.UserRecommendationWhereUniqueInput;
};

/**
 * UserRecommendation findUniqueOrThrow
 */
export type UserRecommendationFindUniqueOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the UserRecommendation
	 */
	select?: Prisma.UserRecommendationSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the UserRecommendation
	 */
	omit?: Prisma.UserRecommendationOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.UserRecommendationInclude<ExtArgs> | null;
	/**
	 * Filter, which UserRecommendation to fetch.
	 */
	where: Prisma.UserRecommendationWhereUniqueInput;
};

/**
 * UserRecommendation findFirst
 */
export type UserRecommendationFindFirstArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the UserRecommendation
	 */
	select?: Prisma.UserRecommendationSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the UserRecommendation
	 */
	omit?: Prisma.UserRecommendationOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.UserRecommendationInclude<ExtArgs> | null;
	/**
	 * Filter, which UserRecommendation to fetch.
	 */
	where?: Prisma.UserRecommendationWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of UserRecommendations to fetch.
	 */
	orderBy?:
		| Prisma.UserRecommendationOrderByWithRelationInput
		| Prisma.UserRecommendationOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for UserRecommendations.
	 */
	cursor?: Prisma.UserRecommendationWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` UserRecommendations from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` UserRecommendations.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of UserRecommendations.
	 */
	distinct?:
		| Prisma.UserRecommendationScalarFieldEnum
		| Prisma.UserRecommendationScalarFieldEnum[];
};

/**
 * UserRecommendation findFirstOrThrow
 */
export type UserRecommendationFindFirstOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the UserRecommendation
	 */
	select?: Prisma.UserRecommendationSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the UserRecommendation
	 */
	omit?: Prisma.UserRecommendationOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.UserRecommendationInclude<ExtArgs> | null;
	/**
	 * Filter, which UserRecommendation to fetch.
	 */
	where?: Prisma.UserRecommendationWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of UserRecommendations to fetch.
	 */
	orderBy?:
		| Prisma.UserRecommendationOrderByWithRelationInput
		| Prisma.UserRecommendationOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for UserRecommendations.
	 */
	cursor?: Prisma.UserRecommendationWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` UserRecommendations from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` UserRecommendations.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of UserRecommendations.
	 */
	distinct?:
		| Prisma.UserRecommendationScalarFieldEnum
		| Prisma.UserRecommendationScalarFieldEnum[];
};

/**
 * UserRecommendation findMany
 */
export type UserRecommendationFindManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the UserRecommendation
	 */
	select?: Prisma.UserRecommendationSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the UserRecommendation
	 */
	omit?: Prisma.UserRecommendationOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.UserRecommendationInclude<ExtArgs> | null;
	/**
	 * Filter, which UserRecommendations to fetch.
	 */
	where?: Prisma.UserRecommendationWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of UserRecommendations to fetch.
	 */
	orderBy?:
		| Prisma.UserRecommendationOrderByWithRelationInput
		| Prisma.UserRecommendationOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for listing UserRecommendations.
	 */
	cursor?: Prisma.UserRecommendationWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` UserRecommendations from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` UserRecommendations.
	 */
	skip?: number;
	distinct?:
		| Prisma.UserRecommendationScalarFieldEnum
		| Prisma.UserRecommendationScalarFieldEnum[];
};

/**
 * UserRecommendation create
 */
export type UserRecommendationCreateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the UserRecommendation
	 */
	select?: Prisma.UserRecommendationSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the UserRecommendation
	 */
	omit?: Prisma.UserRecommendationOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.UserRecommendationInclude<ExtArgs> | null;
	/**
	 * The data needed to create a UserRecommendation.
	 */
	data: Prisma.XOR<
		Prisma.UserRecommendationCreateInput,
		Prisma.UserRecommendationUncheckedCreateInput
	>;
};

/**
 * UserRecommendation createMany
 */
export type UserRecommendationCreateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to create many UserRecommendations.
	 */
	data:
		| Prisma.UserRecommendationCreateManyInput
		| Prisma.UserRecommendationCreateManyInput[];
};

/**
 * UserRecommendation createManyAndReturn
 */
export type UserRecommendationCreateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the UserRecommendation
	 */
	select?: Prisma.UserRecommendationSelectCreateManyAndReturn<ExtArgs> | null;
	/**
	 * Omit specific fields from the UserRecommendation
	 */
	omit?: Prisma.UserRecommendationOmit<ExtArgs> | null;
	/**
	 * The data used to create many UserRecommendations.
	 */
	data:
		| Prisma.UserRecommendationCreateManyInput
		| Prisma.UserRecommendationCreateManyInput[];
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.UserRecommendationIncludeCreateManyAndReturn<ExtArgs> | null;
};

/**
 * UserRecommendation update
 */
export type UserRecommendationUpdateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the UserRecommendation
	 */
	select?: Prisma.UserRecommendationSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the UserRecommendation
	 */
	omit?: Prisma.UserRecommendationOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.UserRecommendationInclude<ExtArgs> | null;
	/**
	 * The data needed to update a UserRecommendation.
	 */
	data: Prisma.XOR<
		Prisma.UserRecommendationUpdateInput,
		Prisma.UserRecommendationUncheckedUpdateInput
	>;
	/**
	 * Choose, which UserRecommendation to update.
	 */
	where: Prisma.UserRecommendationWhereUniqueInput;
};

/**
 * UserRecommendation updateMany
 */
export type UserRecommendationUpdateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to update UserRecommendations.
	 */
	data: Prisma.XOR<
		Prisma.UserRecommendationUpdateManyMutationInput,
		Prisma.UserRecommendationUncheckedUpdateManyInput
	>;
	/**
	 * Filter which UserRecommendations to update
	 */
	where?: Prisma.UserRecommendationWhereInput;
	/**
	 * Limit how many UserRecommendations to update.
	 */
	limit?: number;
};

/**
 * UserRecommendation updateManyAndReturn
 */
export type UserRecommendationUpdateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the UserRecommendation
	 */
	select?: Prisma.UserRecommendationSelectUpdateManyAndReturn<ExtArgs> | null;
	/**
	 * Omit specific fields from the UserRecommendation
	 */
	omit?: Prisma.UserRecommendationOmit<ExtArgs> | null;
	/**
	 * The data used to update UserRecommendations.
	 */
	data: Prisma.XOR<
		Prisma.UserRecommendationUpdateManyMutationInput,
		Prisma.UserRecommendationUncheckedUpdateManyInput
	>;
	/**
	 * Filter which UserRecommendations to update
	 */
	where?: Prisma.UserRecommendationWhereInput;
	/**
	 * Limit how many UserRecommendations to update.
	 */
	limit?: number;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.UserRecommendationIncludeUpdateManyAndReturn<ExtArgs> | null;
};

/**
 * UserRecommendation upsert
 */
export type UserRecommendationUpsertArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the UserRecommendation
	 */
	select?: Prisma.UserRecommendationSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the UserRecommendation
	 */
	omit?: Prisma.UserRecommendationOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.UserRecommendationInclude<ExtArgs> | null;
	/**
	 * The filter to search for the UserRecommendation to update in case it exists.
	 */
	where: Prisma.UserRecommendationWhereUniqueInput;
	/**
	 * In case the UserRecommendation found by the `where` argument doesn't exist, create a new UserRecommendation with this data.
	 */
	create: Prisma.XOR<
		Prisma.UserRecommendationCreateInput,
		Prisma.UserRecommendationUncheckedCreateInput
	>;
	/**
	 * In case the UserRecommendation was found with the provided `where` argument, update it with this data.
	 */
	update: Prisma.XOR<
		Prisma.UserRecommendationUpdateInput,
		Prisma.UserRecommendationUncheckedUpdateInput
	>;
};

/**
 * UserRecommendation delete
 */
export type UserRecommendationDeleteArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the UserRecommendation
	 */
	select?: Prisma.UserRecommendationSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the UserRecommendation
	 */
	omit?: Prisma.UserRecommendationOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.UserRecommendationInclude<ExtArgs> | null;
	/**
	 * Filter which UserRecommendation to delete.
	 */
	where: Prisma.UserRecommendationWhereUniqueInput;
};

/**
 * UserRecommendation deleteMany
 */
export type UserRecommendationDeleteManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which UserRecommendations to delete
	 */
	where?: Prisma.UserRecommendationWhereInput;
	/**
	 * Limit how many UserRecommendations to delete.
	 */
	limit?: number;
};

/**
 * UserRecommendation without action
 */
export type UserRecommendationDefaultArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the UserRecommendation
	 */
	select?: Prisma.UserRecommendationSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the UserRecommendation
	 */
	omit?: Prisma.UserRecommendationOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.UserRecommendationInclude<ExtArgs> | null;
};
