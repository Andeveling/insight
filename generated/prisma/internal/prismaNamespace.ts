/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client";
import type * as Prisma from "../models";
import { type PrismaClient } from "./class";

export type * from "../models";

export type DMMF = typeof runtime.DMMF;

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>;

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError =
	runtime.PrismaClientKnownRequestError;
export type PrismaClientKnownRequestError =
	runtime.PrismaClientKnownRequestError;

export const PrismaClientUnknownRequestError =
	runtime.PrismaClientUnknownRequestError;
export type PrismaClientUnknownRequestError =
	runtime.PrismaClientUnknownRequestError;

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;

export const PrismaClientInitializationError =
	runtime.PrismaClientInitializationError;
export type PrismaClientInitializationError =
	runtime.PrismaClientInitializationError;

export const PrismaClientValidationError = runtime.PrismaClientValidationError;
export type PrismaClientValidationError = runtime.PrismaClientValidationError;

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag;
export const empty = runtime.empty;
export const join = runtime.join;
export const raw = runtime.raw;
export const Sql = runtime.Sql;
export type Sql = runtime.Sql;

/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal;
export type Decimal = runtime.Decimal;

export type DecimalJsLike = runtime.DecimalJsLike;

/**
 * Extensions
 */
export type Extension = runtime.Types.Extensions.UserArgs;
export const getExtensionContext = runtime.Extensions.getExtensionContext;
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<
	T,
	F
>;
export type Payload<
	T,
	F extends runtime.Operation = never,
> = runtime.Types.Public.Payload<T, F>;
export type Result<
	T,
	A,
	F extends runtime.Operation,
> = runtime.Types.Public.Result<T, A, F>;
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>;

export type PrismaVersion = {
	client: string;
	engine: string;
};

/**
 * Prisma Client JS version: 7.1.0
 * Query Engine version: ab635e6b9d606fa5c8fb8b1a7f909c3c3c1c98ba
 */
export const prismaVersion: PrismaVersion = {
	client: "7.1.0",
	engine: "ab635e6b9d606fa5c8fb8b1a7f909c3c3c1c98ba",
};

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes;
export type JsonObject = runtime.JsonObject;
export type JsonArray = runtime.JsonArray;
export type JsonValue = runtime.JsonValue;
export type InputJsonObject = runtime.InputJsonObject;
export type InputJsonArray = runtime.InputJsonArray;
export type InputJsonValue = runtime.InputJsonValue;

export const NullTypes = {
	DbNull: runtime.NullTypes.DbNull as new (
		secret: never,
	) => typeof runtime.DbNull,
	JsonNull: runtime.NullTypes.JsonNull as new (
		secret: never,
	) => typeof runtime.JsonNull,
	AnyNull: runtime.NullTypes.AnyNull as new (
		secret: never,
	) => typeof runtime.AnyNull,
};
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull;

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull;

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull;

type SelectAndInclude = {
	select: any;
	include: any;
};

type SelectAndOmit = {
	select: any;
	omit: any;
};

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
	[P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
	[key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
	[key in keyof T]: key extends keyof U ? T[key] : never;
} & (T extends SelectAndInclude
	? "Please either choose `select` or `include`."
	: T extends SelectAndOmit
		? "Please either choose `select` or `omit`."
		: {});

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
	[key in keyof T]: key extends keyof U ? T[key] : never;
} & K;

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> = T extends object
	? U extends object
		? (Without<T, U> & U) | (Without<U, T> & T)
		: U
	: T;

/**
 * Is T a Record?
 */
type IsObject<T extends any> =
	T extends Array<any>
		? False
		: T extends Date
			? False
			: T extends Uint8Array
				? False
				: T extends BigInt
					? False
					: T extends object
						? True
						: False;

/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
	{
		// Merge all but K
		[P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
	}[K];

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>;

type _Either<O extends object, K extends Key, strict extends Boolean> = {
	1: EitherStrict<O, K>;
	0: EitherLoose<O, K>;
}[strict];

export type Either<
	O extends object,
	K extends Key,
	strict extends Boolean = 1,
> = O extends unknown ? _Either<O, K, strict> : never;

export type Union = any;

export type PatchUndefined<O extends object, O1 extends object> = {
	[K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
} & {};

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
	U extends unknown
		? (k: U) => void
		: never
) extends (k: infer I) => void
	? I
	: never;

export type Overwrite<O extends object, O1 extends object> = {
	[K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<
	Overwrite<
		U,
		{
			[K in keyof U]-?: At<U, K>;
		}
	>
>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown
	? AtStrict<O, K>
	: never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
	1: AtStrict<O, K>;
	0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function
	? A
	: {
			[K in keyof A]: A[K];
		} & {};

export type OptionalFlat<O> = {
	[K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
	[P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
	O extends unknown
		?
				| (K extends keyof O ? { [P in K]: O[P] } & O : O)
				| ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
		: never
>;

type _Strict<U, _U = U> = U extends unknown
	? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
	: never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False;

export type True = 1;

export type False = 0;

export type Not<B extends Boolean> = {
	0: 1;
	1: 0;
}[B];

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
	? 0 // anything `never` is false
	: A1 extends A2
		? 1
		: 0;

export type Has<U extends Union, U1 extends Union> = Not<
	Extends<Exclude<U1, U>, U1>
>;

export type Or<B1 extends Boolean, B2 extends Boolean> = {
	0: {
		0: 0;
		1: 1;
	};
	1: {
		0: 1;
		1: 1;
	};
}[B1][B2];

export type Keys<U extends Union> = U extends unknown ? keyof U : never;

export type GetScalarType<T, O> = O extends object
	? {
			[P in keyof T]: P extends keyof O ? O[P] : never;
		}
	: never;

type FieldPaths<
	T,
	U = Omit<T, "_avg" | "_sum" | "_count" | "_min" | "_max">,
> = IsObject<T> extends True ? U : T;

export type GetHavingFields<T> = {
	[K in keyof T]: Or<
		Or<Extends<"OR", K>, Extends<"AND", K>>,
		Extends<"NOT", K>
	> extends True
		? // infer is only needed to not hit TS limit
			// based on the brilliant idea of Pierre-Antoine Mills
			// https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
			T[K] extends infer TK
			? GetHavingFields<
					UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
				>
			: never
		: {} extends FieldPaths<T[K]>
			? never
			: K;
}[keyof T];

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<
	T,
	K extends Enumerable<keyof T> | keyof T,
> = Prisma__Pick<T, MaybeTupleToUnion<K>>;

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
	? never
	: T;

export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

type FieldRefInputType<Model, FieldType> = Model extends never
	? never
	: FieldRef<Model, FieldType>;

export const ModelName = {
	User: "User",
	Session: "Session",
	Account: "Account",
	Verification: "Verification",
	UserProfile: "UserProfile",
	UserDNA: "UserDNA",
	Team: "Team",
	TeamMember: "TeamMember",
	Domain: "Domain",
	Strength: "Strength",
	UserStrength: "UserStrength",
	Focus: "Focus",
	DomainFocus: "DomainFocus",
	Culture: "Culture",
	Report: "Report",
	AssessmentQuestion: "AssessmentQuestion",
	UserAssessmentAnswer: "UserAssessmentAnswer",
	AssessmentSession: "AssessmentSession",
	FeedbackRequest: "FeedbackRequest",
	FeedbackQuestion: "FeedbackQuestion",
	FeedbackResponse: "FeedbackResponse",
	FeedbackSummary: "FeedbackSummary",
	StrengthAdjustment: "StrengthAdjustment",
	SubTeam: "SubTeam",
	ProjectTypeProfile: "ProjectTypeProfile",
	UserGamification: "UserGamification",
	XpTransaction: "XpTransaction",
	Badge: "Badge",
	UserBadge: "UserBadge",
	UserProfessionalProfile: "UserProfessionalProfile",
	DevelopmentModule: "DevelopmentModule",
	Challenge: "Challenge",
	UserModuleProgress: "UserModuleProgress",
	UserChallengeProgress: "UserChallengeProgress",
	CollaborativeChallenge: "CollaborativeChallenge",
	UserRecommendation: "UserRecommendation",
	MaturityLevelDefinition: "MaturityLevelDefinition",
	StrengthMaturityLevel: "StrengthMaturityLevel",
	ComboBreaker: "ComboBreaker",
	ComboStrength: "ComboStrength",
	Quest: "Quest",
	QuestCompletion: "QuestCompletion",
} as const;

export type ModelName = (typeof ModelName)[keyof typeof ModelName];

export interface TypeMapCb<GlobalOmitOptions = {}>
	extends runtime.Types.Utils.Fn<
		{ extArgs: runtime.Types.Extensions.InternalArgs },
		runtime.Types.Utils.Record<string, any>
	> {
	returns: TypeMap<this["params"]["extArgs"], GlobalOmitOptions>;
}

export type TypeMap<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> = {
	globalOmitOptions: {
		omit: GlobalOmitOptions;
	};
	meta: {
		modelProps:
			| "user"
			| "session"
			| "account"
			| "verification"
			| "userProfile"
			| "userDNA"
			| "team"
			| "teamMember"
			| "domain"
			| "strength"
			| "userStrength"
			| "focus"
			| "domainFocus"
			| "culture"
			| "report"
			| "assessmentQuestion"
			| "userAssessmentAnswer"
			| "assessmentSession"
			| "feedbackRequest"
			| "feedbackQuestion"
			| "feedbackResponse"
			| "feedbackSummary"
			| "strengthAdjustment"
			| "subTeam"
			| "projectTypeProfile"
			| "userGamification"
			| "xpTransaction"
			| "badge"
			| "userBadge"
			| "userProfessionalProfile"
			| "developmentModule"
			| "challenge"
			| "userModuleProgress"
			| "userChallengeProgress"
			| "collaborativeChallenge"
			| "userRecommendation"
			| "maturityLevelDefinition"
			| "strengthMaturityLevel"
			| "comboBreaker"
			| "comboStrength"
			| "quest"
			| "questCompletion";
		txIsolationLevel: TransactionIsolationLevel;
	};
	model: {
		User: {
			payload: Prisma.$UserPayload<ExtArgs>;
			fields: Prisma.UserFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.UserFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
				};
				findFirst: {
					args: Prisma.UserFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
				};
				findMany: {
					args: Prisma.UserFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[];
				};
				create: {
					args: Prisma.UserCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
				};
				createMany: {
					args: Prisma.UserCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[];
				};
				delete: {
					args: Prisma.UserDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
				};
				update: {
					args: Prisma.UserUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
				};
				deleteMany: {
					args: Prisma.UserDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.UserUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[];
				};
				upsert: {
					args: Prisma.UserUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
				};
				aggregate: {
					args: Prisma.UserAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateUser>;
				};
				groupBy: {
					args: Prisma.UserGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[];
				};
				count: {
					args: Prisma.UserCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType>
						| number;
				};
			};
		};
		Session: {
			payload: Prisma.$SessionPayload<ExtArgs>;
			fields: Prisma.SessionFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.SessionFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
				};
				findFirst: {
					args: Prisma.SessionFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
				};
				findMany: {
					args: Prisma.SessionFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[];
				};
				create: {
					args: Prisma.SessionCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
				};
				createMany: {
					args: Prisma.SessionCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[];
				};
				delete: {
					args: Prisma.SessionDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
				};
				update: {
					args: Prisma.SessionUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
				};
				deleteMany: {
					args: Prisma.SessionDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.SessionUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[];
				};
				upsert: {
					args: Prisma.SessionUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
				};
				aggregate: {
					args: Prisma.SessionAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateSession>;
				};
				groupBy: {
					args: Prisma.SessionGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.SessionGroupByOutputType>[];
				};
				count: {
					args: Prisma.SessionCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.SessionCountAggregateOutputType>
						| number;
				};
			};
		};
		Account: {
			payload: Prisma.$AccountPayload<ExtArgs>;
			fields: Prisma.AccountFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.AccountFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>;
				};
				findFirst: {
					args: Prisma.AccountFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>;
				};
				findMany: {
					args: Prisma.AccountFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[];
				};
				create: {
					args: Prisma.AccountCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>;
				};
				createMany: {
					args: Prisma.AccountCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[];
				};
				delete: {
					args: Prisma.AccountDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>;
				};
				update: {
					args: Prisma.AccountUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>;
				};
				deleteMany: {
					args: Prisma.AccountDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.AccountUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[];
				};
				upsert: {
					args: Prisma.AccountUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>;
				};
				aggregate: {
					args: Prisma.AccountAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateAccount>;
				};
				groupBy: {
					args: Prisma.AccountGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AccountGroupByOutputType>[];
				};
				count: {
					args: Prisma.AccountCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.AccountCountAggregateOutputType>
						| number;
				};
			};
		};
		Verification: {
			payload: Prisma.$VerificationPayload<ExtArgs>;
			fields: Prisma.VerificationFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.VerificationFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>;
				};
				findFirst: {
					args: Prisma.VerificationFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>;
				};
				findMany: {
					args: Prisma.VerificationFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>[];
				};
				create: {
					args: Prisma.VerificationCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>;
				};
				createMany: {
					args: Prisma.VerificationCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>[];
				};
				delete: {
					args: Prisma.VerificationDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>;
				};
				update: {
					args: Prisma.VerificationUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>;
				};
				deleteMany: {
					args: Prisma.VerificationDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.VerificationUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>[];
				};
				upsert: {
					args: Prisma.VerificationUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationPayload>;
				};
				aggregate: {
					args: Prisma.VerificationAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateVerification>;
				};
				groupBy: {
					args: Prisma.VerificationGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.VerificationGroupByOutputType>[];
				};
				count: {
					args: Prisma.VerificationCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.VerificationCountAggregateOutputType>
						| number;
				};
			};
		};
		UserProfile: {
			payload: Prisma.$UserProfilePayload<ExtArgs>;
			fields: Prisma.UserProfileFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.UserProfileFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>;
				};
				findFirst: {
					args: Prisma.UserProfileFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>;
				};
				findMany: {
					args: Prisma.UserProfileFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>[];
				};
				create: {
					args: Prisma.UserProfileCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>;
				};
				createMany: {
					args: Prisma.UserProfileCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.UserProfileCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>[];
				};
				delete: {
					args: Prisma.UserProfileDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>;
				};
				update: {
					args: Prisma.UserProfileUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>;
				};
				deleteMany: {
					args: Prisma.UserProfileDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.UserProfileUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.UserProfileUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>[];
				};
				upsert: {
					args: Prisma.UserProfileUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>;
				};
				aggregate: {
					args: Prisma.UserProfileAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateUserProfile>;
				};
				groupBy: {
					args: Prisma.UserProfileGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.UserProfileGroupByOutputType>[];
				};
				count: {
					args: Prisma.UserProfileCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.UserProfileCountAggregateOutputType>
						| number;
				};
			};
		};
		UserDNA: {
			payload: Prisma.$UserDNAPayload<ExtArgs>;
			fields: Prisma.UserDNAFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.UserDNAFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDNAPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.UserDNAFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDNAPayload>;
				};
				findFirst: {
					args: Prisma.UserDNAFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDNAPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.UserDNAFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDNAPayload>;
				};
				findMany: {
					args: Prisma.UserDNAFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDNAPayload>[];
				};
				create: {
					args: Prisma.UserDNACreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDNAPayload>;
				};
				createMany: {
					args: Prisma.UserDNACreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.UserDNACreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDNAPayload>[];
				};
				delete: {
					args: Prisma.UserDNADeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDNAPayload>;
				};
				update: {
					args: Prisma.UserDNAUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDNAPayload>;
				};
				deleteMany: {
					args: Prisma.UserDNADeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.UserDNAUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.UserDNAUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDNAPayload>[];
				};
				upsert: {
					args: Prisma.UserDNAUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserDNAPayload>;
				};
				aggregate: {
					args: Prisma.UserDNAAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateUserDNA>;
				};
				groupBy: {
					args: Prisma.UserDNAGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.UserDNAGroupByOutputType>[];
				};
				count: {
					args: Prisma.UserDNACountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.UserDNACountAggregateOutputType>
						| number;
				};
			};
		};
		Team: {
			payload: Prisma.$TeamPayload<ExtArgs>;
			fields: Prisma.TeamFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.TeamFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>;
				};
				findFirst: {
					args: Prisma.TeamFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>;
				};
				findMany: {
					args: Prisma.TeamFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>[];
				};
				create: {
					args: Prisma.TeamCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>;
				};
				createMany: {
					args: Prisma.TeamCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>[];
				};
				delete: {
					args: Prisma.TeamDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>;
				};
				update: {
					args: Prisma.TeamUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>;
				};
				deleteMany: {
					args: Prisma.TeamDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.TeamUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>[];
				};
				upsert: {
					args: Prisma.TeamUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>;
				};
				aggregate: {
					args: Prisma.TeamAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateTeam>;
				};
				groupBy: {
					args: Prisma.TeamGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.TeamGroupByOutputType>[];
				};
				count: {
					args: Prisma.TeamCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.TeamCountAggregateOutputType>
						| number;
				};
			};
		};
		TeamMember: {
			payload: Prisma.$TeamMemberPayload<ExtArgs>;
			fields: Prisma.TeamMemberFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
				};
				findFirst: {
					args: Prisma.TeamMemberFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
				};
				findMany: {
					args: Prisma.TeamMemberFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload>[];
				};
				create: {
					args: Prisma.TeamMemberCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
				};
				createMany: {
					args: Prisma.TeamMemberCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.TeamMemberCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload>[];
				};
				delete: {
					args: Prisma.TeamMemberDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
				};
				update: {
					args: Prisma.TeamMemberUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
				};
				deleteMany: {
					args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.TeamMemberUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload>[];
				};
				upsert: {
					args: Prisma.TeamMemberUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
				};
				aggregate: {
					args: Prisma.TeamMemberAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateTeamMember>;
				};
				groupBy: {
					args: Prisma.TeamMemberGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.TeamMemberGroupByOutputType>[];
				};
				count: {
					args: Prisma.TeamMemberCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.TeamMemberCountAggregateOutputType>
						| number;
				};
			};
		};
		Domain: {
			payload: Prisma.$DomainPayload<ExtArgs>;
			fields: Prisma.DomainFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.DomainFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.DomainFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainPayload>;
				};
				findFirst: {
					args: Prisma.DomainFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.DomainFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainPayload>;
				};
				findMany: {
					args: Prisma.DomainFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainPayload>[];
				};
				create: {
					args: Prisma.DomainCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainPayload>;
				};
				createMany: {
					args: Prisma.DomainCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.DomainCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainPayload>[];
				};
				delete: {
					args: Prisma.DomainDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainPayload>;
				};
				update: {
					args: Prisma.DomainUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainPayload>;
				};
				deleteMany: {
					args: Prisma.DomainDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.DomainUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.DomainUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainPayload>[];
				};
				upsert: {
					args: Prisma.DomainUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainPayload>;
				};
				aggregate: {
					args: Prisma.DomainAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateDomain>;
				};
				groupBy: {
					args: Prisma.DomainGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.DomainGroupByOutputType>[];
				};
				count: {
					args: Prisma.DomainCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.DomainCountAggregateOutputType>
						| number;
				};
			};
		};
		Strength: {
			payload: Prisma.$StrengthPayload<ExtArgs>;
			fields: Prisma.StrengthFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.StrengthFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.StrengthFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthPayload>;
				};
				findFirst: {
					args: Prisma.StrengthFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.StrengthFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthPayload>;
				};
				findMany: {
					args: Prisma.StrengthFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthPayload>[];
				};
				create: {
					args: Prisma.StrengthCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthPayload>;
				};
				createMany: {
					args: Prisma.StrengthCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.StrengthCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthPayload>[];
				};
				delete: {
					args: Prisma.StrengthDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthPayload>;
				};
				update: {
					args: Prisma.StrengthUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthPayload>;
				};
				deleteMany: {
					args: Prisma.StrengthDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.StrengthUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.StrengthUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthPayload>[];
				};
				upsert: {
					args: Prisma.StrengthUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthPayload>;
				};
				aggregate: {
					args: Prisma.StrengthAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateStrength>;
				};
				groupBy: {
					args: Prisma.StrengthGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.StrengthGroupByOutputType>[];
				};
				count: {
					args: Prisma.StrengthCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.StrengthCountAggregateOutputType>
						| number;
				};
			};
		};
		UserStrength: {
			payload: Prisma.$UserStrengthPayload<ExtArgs>;
			fields: Prisma.UserStrengthFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.UserStrengthFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserStrengthPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.UserStrengthFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserStrengthPayload>;
				};
				findFirst: {
					args: Prisma.UserStrengthFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserStrengthPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.UserStrengthFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserStrengthPayload>;
				};
				findMany: {
					args: Prisma.UserStrengthFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserStrengthPayload>[];
				};
				create: {
					args: Prisma.UserStrengthCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserStrengthPayload>;
				};
				createMany: {
					args: Prisma.UserStrengthCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.UserStrengthCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserStrengthPayload>[];
				};
				delete: {
					args: Prisma.UserStrengthDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserStrengthPayload>;
				};
				update: {
					args: Prisma.UserStrengthUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserStrengthPayload>;
				};
				deleteMany: {
					args: Prisma.UserStrengthDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.UserStrengthUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.UserStrengthUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserStrengthPayload>[];
				};
				upsert: {
					args: Prisma.UserStrengthUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserStrengthPayload>;
				};
				aggregate: {
					args: Prisma.UserStrengthAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateUserStrength>;
				};
				groupBy: {
					args: Prisma.UserStrengthGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.UserStrengthGroupByOutputType>[];
				};
				count: {
					args: Prisma.UserStrengthCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.UserStrengthCountAggregateOutputType>
						| number;
				};
			};
		};
		Focus: {
			payload: Prisma.$FocusPayload<ExtArgs>;
			fields: Prisma.FocusFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.FocusFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FocusPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.FocusFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FocusPayload>;
				};
				findFirst: {
					args: Prisma.FocusFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FocusPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.FocusFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FocusPayload>;
				};
				findMany: {
					args: Prisma.FocusFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FocusPayload>[];
				};
				create: {
					args: Prisma.FocusCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FocusPayload>;
				};
				createMany: {
					args: Prisma.FocusCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.FocusCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FocusPayload>[];
				};
				delete: {
					args: Prisma.FocusDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FocusPayload>;
				};
				update: {
					args: Prisma.FocusUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FocusPayload>;
				};
				deleteMany: {
					args: Prisma.FocusDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.FocusUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.FocusUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FocusPayload>[];
				};
				upsert: {
					args: Prisma.FocusUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FocusPayload>;
				};
				aggregate: {
					args: Prisma.FocusAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateFocus>;
				};
				groupBy: {
					args: Prisma.FocusGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.FocusGroupByOutputType>[];
				};
				count: {
					args: Prisma.FocusCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.FocusCountAggregateOutputType>
						| number;
				};
			};
		};
		DomainFocus: {
			payload: Prisma.$DomainFocusPayload<ExtArgs>;
			fields: Prisma.DomainFocusFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.DomainFocusFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainFocusPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.DomainFocusFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainFocusPayload>;
				};
				findFirst: {
					args: Prisma.DomainFocusFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainFocusPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.DomainFocusFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainFocusPayload>;
				};
				findMany: {
					args: Prisma.DomainFocusFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainFocusPayload>[];
				};
				create: {
					args: Prisma.DomainFocusCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainFocusPayload>;
				};
				createMany: {
					args: Prisma.DomainFocusCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.DomainFocusCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainFocusPayload>[];
				};
				delete: {
					args: Prisma.DomainFocusDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainFocusPayload>;
				};
				update: {
					args: Prisma.DomainFocusUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainFocusPayload>;
				};
				deleteMany: {
					args: Prisma.DomainFocusDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.DomainFocusUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.DomainFocusUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainFocusPayload>[];
				};
				upsert: {
					args: Prisma.DomainFocusUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainFocusPayload>;
				};
				aggregate: {
					args: Prisma.DomainFocusAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateDomainFocus>;
				};
				groupBy: {
					args: Prisma.DomainFocusGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.DomainFocusGroupByOutputType>[];
				};
				count: {
					args: Prisma.DomainFocusCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.DomainFocusCountAggregateOutputType>
						| number;
				};
			};
		};
		Culture: {
			payload: Prisma.$CulturePayload<ExtArgs>;
			fields: Prisma.CultureFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.CultureFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CulturePayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.CultureFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CulturePayload>;
				};
				findFirst: {
					args: Prisma.CultureFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CulturePayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.CultureFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CulturePayload>;
				};
				findMany: {
					args: Prisma.CultureFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CulturePayload>[];
				};
				create: {
					args: Prisma.CultureCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CulturePayload>;
				};
				createMany: {
					args: Prisma.CultureCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.CultureCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CulturePayload>[];
				};
				delete: {
					args: Prisma.CultureDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CulturePayload>;
				};
				update: {
					args: Prisma.CultureUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CulturePayload>;
				};
				deleteMany: {
					args: Prisma.CultureDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.CultureUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.CultureUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CulturePayload>[];
				};
				upsert: {
					args: Prisma.CultureUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CulturePayload>;
				};
				aggregate: {
					args: Prisma.CultureAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateCulture>;
				};
				groupBy: {
					args: Prisma.CultureGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.CultureGroupByOutputType>[];
				};
				count: {
					args: Prisma.CultureCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.CultureCountAggregateOutputType>
						| number;
				};
			};
		};
		Report: {
			payload: Prisma.$ReportPayload<ExtArgs>;
			fields: Prisma.ReportFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.ReportFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>;
				};
				findFirst: {
					args: Prisma.ReportFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>;
				};
				findMany: {
					args: Prisma.ReportFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>[];
				};
				create: {
					args: Prisma.ReportCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>;
				};
				createMany: {
					args: Prisma.ReportCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>[];
				};
				delete: {
					args: Prisma.ReportDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>;
				};
				update: {
					args: Prisma.ReportUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>;
				};
				deleteMany: {
					args: Prisma.ReportDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.ReportUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.ReportUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>[];
				};
				upsert: {
					args: Prisma.ReportUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>;
				};
				aggregate: {
					args: Prisma.ReportAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateReport>;
				};
				groupBy: {
					args: Prisma.ReportGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.ReportGroupByOutputType>[];
				};
				count: {
					args: Prisma.ReportCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.ReportCountAggregateOutputType>
						| number;
				};
			};
		};
		AssessmentQuestion: {
			payload: Prisma.$AssessmentQuestionPayload<ExtArgs>;
			fields: Prisma.AssessmentQuestionFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.AssessmentQuestionFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.AssessmentQuestionFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>;
				};
				findFirst: {
					args: Prisma.AssessmentQuestionFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.AssessmentQuestionFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>;
				};
				findMany: {
					args: Prisma.AssessmentQuestionFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>[];
				};
				create: {
					args: Prisma.AssessmentQuestionCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>;
				};
				createMany: {
					args: Prisma.AssessmentQuestionCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.AssessmentQuestionCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>[];
				};
				delete: {
					args: Prisma.AssessmentQuestionDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>;
				};
				update: {
					args: Prisma.AssessmentQuestionUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>;
				};
				deleteMany: {
					args: Prisma.AssessmentQuestionDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.AssessmentQuestionUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.AssessmentQuestionUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>[];
				};
				upsert: {
					args: Prisma.AssessmentQuestionUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>;
				};
				aggregate: {
					args: Prisma.AssessmentQuestionAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateAssessmentQuestion>;
				};
				groupBy: {
					args: Prisma.AssessmentQuestionGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AssessmentQuestionGroupByOutputType>[];
				};
				count: {
					args: Prisma.AssessmentQuestionCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.AssessmentQuestionCountAggregateOutputType>
						| number;
				};
			};
		};
		UserAssessmentAnswer: {
			payload: Prisma.$UserAssessmentAnswerPayload<ExtArgs>;
			fields: Prisma.UserAssessmentAnswerFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.UserAssessmentAnswerFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAssessmentAnswerPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.UserAssessmentAnswerFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAssessmentAnswerPayload>;
				};
				findFirst: {
					args: Prisma.UserAssessmentAnswerFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAssessmentAnswerPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.UserAssessmentAnswerFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAssessmentAnswerPayload>;
				};
				findMany: {
					args: Prisma.UserAssessmentAnswerFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAssessmentAnswerPayload>[];
				};
				create: {
					args: Prisma.UserAssessmentAnswerCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAssessmentAnswerPayload>;
				};
				createMany: {
					args: Prisma.UserAssessmentAnswerCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.UserAssessmentAnswerCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAssessmentAnswerPayload>[];
				};
				delete: {
					args: Prisma.UserAssessmentAnswerDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAssessmentAnswerPayload>;
				};
				update: {
					args: Prisma.UserAssessmentAnswerUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAssessmentAnswerPayload>;
				};
				deleteMany: {
					args: Prisma.UserAssessmentAnswerDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.UserAssessmentAnswerUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.UserAssessmentAnswerUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAssessmentAnswerPayload>[];
				};
				upsert: {
					args: Prisma.UserAssessmentAnswerUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAssessmentAnswerPayload>;
				};
				aggregate: {
					args: Prisma.UserAssessmentAnswerAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateUserAssessmentAnswer>;
				};
				groupBy: {
					args: Prisma.UserAssessmentAnswerGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.UserAssessmentAnswerGroupByOutputType>[];
				};
				count: {
					args: Prisma.UserAssessmentAnswerCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.UserAssessmentAnswerCountAggregateOutputType>
						| number;
				};
			};
		};
		AssessmentSession: {
			payload: Prisma.$AssessmentSessionPayload<ExtArgs>;
			fields: Prisma.AssessmentSessionFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.AssessmentSessionFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentSessionPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.AssessmentSessionFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentSessionPayload>;
				};
				findFirst: {
					args: Prisma.AssessmentSessionFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentSessionPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.AssessmentSessionFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentSessionPayload>;
				};
				findMany: {
					args: Prisma.AssessmentSessionFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentSessionPayload>[];
				};
				create: {
					args: Prisma.AssessmentSessionCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentSessionPayload>;
				};
				createMany: {
					args: Prisma.AssessmentSessionCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.AssessmentSessionCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentSessionPayload>[];
				};
				delete: {
					args: Prisma.AssessmentSessionDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentSessionPayload>;
				};
				update: {
					args: Prisma.AssessmentSessionUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentSessionPayload>;
				};
				deleteMany: {
					args: Prisma.AssessmentSessionDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.AssessmentSessionUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.AssessmentSessionUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentSessionPayload>[];
				};
				upsert: {
					args: Prisma.AssessmentSessionUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentSessionPayload>;
				};
				aggregate: {
					args: Prisma.AssessmentSessionAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateAssessmentSession>;
				};
				groupBy: {
					args: Prisma.AssessmentSessionGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AssessmentSessionGroupByOutputType>[];
				};
				count: {
					args: Prisma.AssessmentSessionCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.AssessmentSessionCountAggregateOutputType>
						| number;
				};
			};
		};
		FeedbackRequest: {
			payload: Prisma.$FeedbackRequestPayload<ExtArgs>;
			fields: Prisma.FeedbackRequestFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.FeedbackRequestFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackRequestPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.FeedbackRequestFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackRequestPayload>;
				};
				findFirst: {
					args: Prisma.FeedbackRequestFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackRequestPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.FeedbackRequestFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackRequestPayload>;
				};
				findMany: {
					args: Prisma.FeedbackRequestFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackRequestPayload>[];
				};
				create: {
					args: Prisma.FeedbackRequestCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackRequestPayload>;
				};
				createMany: {
					args: Prisma.FeedbackRequestCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.FeedbackRequestCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackRequestPayload>[];
				};
				delete: {
					args: Prisma.FeedbackRequestDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackRequestPayload>;
				};
				update: {
					args: Prisma.FeedbackRequestUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackRequestPayload>;
				};
				deleteMany: {
					args: Prisma.FeedbackRequestDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.FeedbackRequestUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.FeedbackRequestUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackRequestPayload>[];
				};
				upsert: {
					args: Prisma.FeedbackRequestUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackRequestPayload>;
				};
				aggregate: {
					args: Prisma.FeedbackRequestAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateFeedbackRequest>;
				};
				groupBy: {
					args: Prisma.FeedbackRequestGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.FeedbackRequestGroupByOutputType>[];
				};
				count: {
					args: Prisma.FeedbackRequestCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.FeedbackRequestCountAggregateOutputType>
						| number;
				};
			};
		};
		FeedbackQuestion: {
			payload: Prisma.$FeedbackQuestionPayload<ExtArgs>;
			fields: Prisma.FeedbackQuestionFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.FeedbackQuestionFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackQuestionPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.FeedbackQuestionFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackQuestionPayload>;
				};
				findFirst: {
					args: Prisma.FeedbackQuestionFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackQuestionPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.FeedbackQuestionFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackQuestionPayload>;
				};
				findMany: {
					args: Prisma.FeedbackQuestionFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackQuestionPayload>[];
				};
				create: {
					args: Prisma.FeedbackQuestionCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackQuestionPayload>;
				};
				createMany: {
					args: Prisma.FeedbackQuestionCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.FeedbackQuestionCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackQuestionPayload>[];
				};
				delete: {
					args: Prisma.FeedbackQuestionDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackQuestionPayload>;
				};
				update: {
					args: Prisma.FeedbackQuestionUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackQuestionPayload>;
				};
				deleteMany: {
					args: Prisma.FeedbackQuestionDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.FeedbackQuestionUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.FeedbackQuestionUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackQuestionPayload>[];
				};
				upsert: {
					args: Prisma.FeedbackQuestionUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackQuestionPayload>;
				};
				aggregate: {
					args: Prisma.FeedbackQuestionAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateFeedbackQuestion>;
				};
				groupBy: {
					args: Prisma.FeedbackQuestionGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.FeedbackQuestionGroupByOutputType>[];
				};
				count: {
					args: Prisma.FeedbackQuestionCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.FeedbackQuestionCountAggregateOutputType>
						| number;
				};
			};
		};
		FeedbackResponse: {
			payload: Prisma.$FeedbackResponsePayload<ExtArgs>;
			fields: Prisma.FeedbackResponseFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.FeedbackResponseFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackResponsePayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.FeedbackResponseFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackResponsePayload>;
				};
				findFirst: {
					args: Prisma.FeedbackResponseFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackResponsePayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.FeedbackResponseFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackResponsePayload>;
				};
				findMany: {
					args: Prisma.FeedbackResponseFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackResponsePayload>[];
				};
				create: {
					args: Prisma.FeedbackResponseCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackResponsePayload>;
				};
				createMany: {
					args: Prisma.FeedbackResponseCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.FeedbackResponseCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackResponsePayload>[];
				};
				delete: {
					args: Prisma.FeedbackResponseDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackResponsePayload>;
				};
				update: {
					args: Prisma.FeedbackResponseUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackResponsePayload>;
				};
				deleteMany: {
					args: Prisma.FeedbackResponseDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.FeedbackResponseUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.FeedbackResponseUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackResponsePayload>[];
				};
				upsert: {
					args: Prisma.FeedbackResponseUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackResponsePayload>;
				};
				aggregate: {
					args: Prisma.FeedbackResponseAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateFeedbackResponse>;
				};
				groupBy: {
					args: Prisma.FeedbackResponseGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.FeedbackResponseGroupByOutputType>[];
				};
				count: {
					args: Prisma.FeedbackResponseCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.FeedbackResponseCountAggregateOutputType>
						| number;
				};
			};
		};
		FeedbackSummary: {
			payload: Prisma.$FeedbackSummaryPayload<ExtArgs>;
			fields: Prisma.FeedbackSummaryFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.FeedbackSummaryFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackSummaryPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.FeedbackSummaryFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackSummaryPayload>;
				};
				findFirst: {
					args: Prisma.FeedbackSummaryFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackSummaryPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.FeedbackSummaryFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackSummaryPayload>;
				};
				findMany: {
					args: Prisma.FeedbackSummaryFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackSummaryPayload>[];
				};
				create: {
					args: Prisma.FeedbackSummaryCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackSummaryPayload>;
				};
				createMany: {
					args: Prisma.FeedbackSummaryCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.FeedbackSummaryCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackSummaryPayload>[];
				};
				delete: {
					args: Prisma.FeedbackSummaryDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackSummaryPayload>;
				};
				update: {
					args: Prisma.FeedbackSummaryUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackSummaryPayload>;
				};
				deleteMany: {
					args: Prisma.FeedbackSummaryDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.FeedbackSummaryUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.FeedbackSummaryUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackSummaryPayload>[];
				};
				upsert: {
					args: Prisma.FeedbackSummaryUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackSummaryPayload>;
				};
				aggregate: {
					args: Prisma.FeedbackSummaryAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateFeedbackSummary>;
				};
				groupBy: {
					args: Prisma.FeedbackSummaryGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.FeedbackSummaryGroupByOutputType>[];
				};
				count: {
					args: Prisma.FeedbackSummaryCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.FeedbackSummaryCountAggregateOutputType>
						| number;
				};
			};
		};
		StrengthAdjustment: {
			payload: Prisma.$StrengthAdjustmentPayload<ExtArgs>;
			fields: Prisma.StrengthAdjustmentFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.StrengthAdjustmentFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthAdjustmentPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.StrengthAdjustmentFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthAdjustmentPayload>;
				};
				findFirst: {
					args: Prisma.StrengthAdjustmentFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthAdjustmentPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.StrengthAdjustmentFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthAdjustmentPayload>;
				};
				findMany: {
					args: Prisma.StrengthAdjustmentFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthAdjustmentPayload>[];
				};
				create: {
					args: Prisma.StrengthAdjustmentCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthAdjustmentPayload>;
				};
				createMany: {
					args: Prisma.StrengthAdjustmentCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.StrengthAdjustmentCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthAdjustmentPayload>[];
				};
				delete: {
					args: Prisma.StrengthAdjustmentDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthAdjustmentPayload>;
				};
				update: {
					args: Prisma.StrengthAdjustmentUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthAdjustmentPayload>;
				};
				deleteMany: {
					args: Prisma.StrengthAdjustmentDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.StrengthAdjustmentUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.StrengthAdjustmentUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthAdjustmentPayload>[];
				};
				upsert: {
					args: Prisma.StrengthAdjustmentUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthAdjustmentPayload>;
				};
				aggregate: {
					args: Prisma.StrengthAdjustmentAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateStrengthAdjustment>;
				};
				groupBy: {
					args: Prisma.StrengthAdjustmentGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.StrengthAdjustmentGroupByOutputType>[];
				};
				count: {
					args: Prisma.StrengthAdjustmentCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.StrengthAdjustmentCountAggregateOutputType>
						| number;
				};
			};
		};
		SubTeam: {
			payload: Prisma.$SubTeamPayload<ExtArgs>;
			fields: Prisma.SubTeamFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.SubTeamFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SubTeamPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.SubTeamFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SubTeamPayload>;
				};
				findFirst: {
					args: Prisma.SubTeamFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SubTeamPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.SubTeamFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SubTeamPayload>;
				};
				findMany: {
					args: Prisma.SubTeamFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SubTeamPayload>[];
				};
				create: {
					args: Prisma.SubTeamCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SubTeamPayload>;
				};
				createMany: {
					args: Prisma.SubTeamCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.SubTeamCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SubTeamPayload>[];
				};
				delete: {
					args: Prisma.SubTeamDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SubTeamPayload>;
				};
				update: {
					args: Prisma.SubTeamUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SubTeamPayload>;
				};
				deleteMany: {
					args: Prisma.SubTeamDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.SubTeamUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.SubTeamUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SubTeamPayload>[];
				};
				upsert: {
					args: Prisma.SubTeamUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SubTeamPayload>;
				};
				aggregate: {
					args: Prisma.SubTeamAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateSubTeam>;
				};
				groupBy: {
					args: Prisma.SubTeamGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.SubTeamGroupByOutputType>[];
				};
				count: {
					args: Prisma.SubTeamCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.SubTeamCountAggregateOutputType>
						| number;
				};
			};
		};
		ProjectTypeProfile: {
			payload: Prisma.$ProjectTypeProfilePayload<ExtArgs>;
			fields: Prisma.ProjectTypeProfileFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.ProjectTypeProfileFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectTypeProfilePayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.ProjectTypeProfileFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectTypeProfilePayload>;
				};
				findFirst: {
					args: Prisma.ProjectTypeProfileFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectTypeProfilePayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.ProjectTypeProfileFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectTypeProfilePayload>;
				};
				findMany: {
					args: Prisma.ProjectTypeProfileFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectTypeProfilePayload>[];
				};
				create: {
					args: Prisma.ProjectTypeProfileCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectTypeProfilePayload>;
				};
				createMany: {
					args: Prisma.ProjectTypeProfileCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.ProjectTypeProfileCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectTypeProfilePayload>[];
				};
				delete: {
					args: Prisma.ProjectTypeProfileDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectTypeProfilePayload>;
				};
				update: {
					args: Prisma.ProjectTypeProfileUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectTypeProfilePayload>;
				};
				deleteMany: {
					args: Prisma.ProjectTypeProfileDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.ProjectTypeProfileUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.ProjectTypeProfileUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectTypeProfilePayload>[];
				};
				upsert: {
					args: Prisma.ProjectTypeProfileUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectTypeProfilePayload>;
				};
				aggregate: {
					args: Prisma.ProjectTypeProfileAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateProjectTypeProfile>;
				};
				groupBy: {
					args: Prisma.ProjectTypeProfileGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.ProjectTypeProfileGroupByOutputType>[];
				};
				count: {
					args: Prisma.ProjectTypeProfileCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.ProjectTypeProfileCountAggregateOutputType>
						| number;
				};
			};
		};
		UserGamification: {
			payload: Prisma.$UserGamificationPayload<ExtArgs>;
			fields: Prisma.UserGamificationFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.UserGamificationFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserGamificationPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.UserGamificationFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserGamificationPayload>;
				};
				findFirst: {
					args: Prisma.UserGamificationFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserGamificationPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.UserGamificationFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserGamificationPayload>;
				};
				findMany: {
					args: Prisma.UserGamificationFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserGamificationPayload>[];
				};
				create: {
					args: Prisma.UserGamificationCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserGamificationPayload>;
				};
				createMany: {
					args: Prisma.UserGamificationCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.UserGamificationCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserGamificationPayload>[];
				};
				delete: {
					args: Prisma.UserGamificationDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserGamificationPayload>;
				};
				update: {
					args: Prisma.UserGamificationUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserGamificationPayload>;
				};
				deleteMany: {
					args: Prisma.UserGamificationDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.UserGamificationUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.UserGamificationUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserGamificationPayload>[];
				};
				upsert: {
					args: Prisma.UserGamificationUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserGamificationPayload>;
				};
				aggregate: {
					args: Prisma.UserGamificationAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateUserGamification>;
				};
				groupBy: {
					args: Prisma.UserGamificationGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.UserGamificationGroupByOutputType>[];
				};
				count: {
					args: Prisma.UserGamificationCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.UserGamificationCountAggregateOutputType>
						| number;
				};
			};
		};
		XpTransaction: {
			payload: Prisma.$XpTransactionPayload<ExtArgs>;
			fields: Prisma.XpTransactionFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.XpTransactionFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$XpTransactionPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.XpTransactionFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$XpTransactionPayload>;
				};
				findFirst: {
					args: Prisma.XpTransactionFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$XpTransactionPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.XpTransactionFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$XpTransactionPayload>;
				};
				findMany: {
					args: Prisma.XpTransactionFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$XpTransactionPayload>[];
				};
				create: {
					args: Prisma.XpTransactionCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$XpTransactionPayload>;
				};
				createMany: {
					args: Prisma.XpTransactionCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.XpTransactionCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$XpTransactionPayload>[];
				};
				delete: {
					args: Prisma.XpTransactionDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$XpTransactionPayload>;
				};
				update: {
					args: Prisma.XpTransactionUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$XpTransactionPayload>;
				};
				deleteMany: {
					args: Prisma.XpTransactionDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.XpTransactionUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.XpTransactionUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$XpTransactionPayload>[];
				};
				upsert: {
					args: Prisma.XpTransactionUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$XpTransactionPayload>;
				};
				aggregate: {
					args: Prisma.XpTransactionAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateXpTransaction>;
				};
				groupBy: {
					args: Prisma.XpTransactionGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.XpTransactionGroupByOutputType>[];
				};
				count: {
					args: Prisma.XpTransactionCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.XpTransactionCountAggregateOutputType>
						| number;
				};
			};
		};
		Badge: {
			payload: Prisma.$BadgePayload<ExtArgs>;
			fields: Prisma.BadgeFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.BadgeFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BadgePayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.BadgeFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BadgePayload>;
				};
				findFirst: {
					args: Prisma.BadgeFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BadgePayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.BadgeFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BadgePayload>;
				};
				findMany: {
					args: Prisma.BadgeFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BadgePayload>[];
				};
				create: {
					args: Prisma.BadgeCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BadgePayload>;
				};
				createMany: {
					args: Prisma.BadgeCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.BadgeCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BadgePayload>[];
				};
				delete: {
					args: Prisma.BadgeDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BadgePayload>;
				};
				update: {
					args: Prisma.BadgeUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BadgePayload>;
				};
				deleteMany: {
					args: Prisma.BadgeDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.BadgeUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.BadgeUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BadgePayload>[];
				};
				upsert: {
					args: Prisma.BadgeUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BadgePayload>;
				};
				aggregate: {
					args: Prisma.BadgeAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateBadge>;
				};
				groupBy: {
					args: Prisma.BadgeGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.BadgeGroupByOutputType>[];
				};
				count: {
					args: Prisma.BadgeCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.BadgeCountAggregateOutputType>
						| number;
				};
			};
		};
		UserBadge: {
			payload: Prisma.$UserBadgePayload<ExtArgs>;
			fields: Prisma.UserBadgeFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.UserBadgeFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.UserBadgeFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>;
				};
				findFirst: {
					args: Prisma.UserBadgeFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.UserBadgeFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>;
				};
				findMany: {
					args: Prisma.UserBadgeFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>[];
				};
				create: {
					args: Prisma.UserBadgeCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>;
				};
				createMany: {
					args: Prisma.UserBadgeCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.UserBadgeCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>[];
				};
				delete: {
					args: Prisma.UserBadgeDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>;
				};
				update: {
					args: Prisma.UserBadgeUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>;
				};
				deleteMany: {
					args: Prisma.UserBadgeDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.UserBadgeUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.UserBadgeUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>[];
				};
				upsert: {
					args: Prisma.UserBadgeUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>;
				};
				aggregate: {
					args: Prisma.UserBadgeAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateUserBadge>;
				};
				groupBy: {
					args: Prisma.UserBadgeGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.UserBadgeGroupByOutputType>[];
				};
				count: {
					args: Prisma.UserBadgeCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.UserBadgeCountAggregateOutputType>
						| number;
				};
			};
		};
		UserProfessionalProfile: {
			payload: Prisma.$UserProfessionalProfilePayload<ExtArgs>;
			fields: Prisma.UserProfessionalProfileFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.UserProfessionalProfileFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfessionalProfilePayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.UserProfessionalProfileFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfessionalProfilePayload>;
				};
				findFirst: {
					args: Prisma.UserProfessionalProfileFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfessionalProfilePayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.UserProfessionalProfileFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfessionalProfilePayload>;
				};
				findMany: {
					args: Prisma.UserProfessionalProfileFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfessionalProfilePayload>[];
				};
				create: {
					args: Prisma.UserProfessionalProfileCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfessionalProfilePayload>;
				};
				createMany: {
					args: Prisma.UserProfessionalProfileCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.UserProfessionalProfileCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfessionalProfilePayload>[];
				};
				delete: {
					args: Prisma.UserProfessionalProfileDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfessionalProfilePayload>;
				};
				update: {
					args: Prisma.UserProfessionalProfileUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfessionalProfilePayload>;
				};
				deleteMany: {
					args: Prisma.UserProfessionalProfileDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.UserProfessionalProfileUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.UserProfessionalProfileUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfessionalProfilePayload>[];
				};
				upsert: {
					args: Prisma.UserProfessionalProfileUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfessionalProfilePayload>;
				};
				aggregate: {
					args: Prisma.UserProfessionalProfileAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateUserProfessionalProfile>;
				};
				groupBy: {
					args: Prisma.UserProfessionalProfileGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.UserProfessionalProfileGroupByOutputType>[];
				};
				count: {
					args: Prisma.UserProfessionalProfileCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.UserProfessionalProfileCountAggregateOutputType>
						| number;
				};
			};
		};
		DevelopmentModule: {
			payload: Prisma.$DevelopmentModulePayload<ExtArgs>;
			fields: Prisma.DevelopmentModuleFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.DevelopmentModuleFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentModulePayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.DevelopmentModuleFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentModulePayload>;
				};
				findFirst: {
					args: Prisma.DevelopmentModuleFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentModulePayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.DevelopmentModuleFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentModulePayload>;
				};
				findMany: {
					args: Prisma.DevelopmentModuleFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentModulePayload>[];
				};
				create: {
					args: Prisma.DevelopmentModuleCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentModulePayload>;
				};
				createMany: {
					args: Prisma.DevelopmentModuleCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.DevelopmentModuleCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentModulePayload>[];
				};
				delete: {
					args: Prisma.DevelopmentModuleDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentModulePayload>;
				};
				update: {
					args: Prisma.DevelopmentModuleUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentModulePayload>;
				};
				deleteMany: {
					args: Prisma.DevelopmentModuleDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.DevelopmentModuleUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.DevelopmentModuleUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentModulePayload>[];
				};
				upsert: {
					args: Prisma.DevelopmentModuleUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentModulePayload>;
				};
				aggregate: {
					args: Prisma.DevelopmentModuleAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateDevelopmentModule>;
				};
				groupBy: {
					args: Prisma.DevelopmentModuleGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.DevelopmentModuleGroupByOutputType>[];
				};
				count: {
					args: Prisma.DevelopmentModuleCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.DevelopmentModuleCountAggregateOutputType>
						| number;
				};
			};
		};
		Challenge: {
			payload: Prisma.$ChallengePayload<ExtArgs>;
			fields: Prisma.ChallengeFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.ChallengeFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengePayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.ChallengeFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengePayload>;
				};
				findFirst: {
					args: Prisma.ChallengeFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengePayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.ChallengeFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengePayload>;
				};
				findMany: {
					args: Prisma.ChallengeFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengePayload>[];
				};
				create: {
					args: Prisma.ChallengeCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengePayload>;
				};
				createMany: {
					args: Prisma.ChallengeCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.ChallengeCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengePayload>[];
				};
				delete: {
					args: Prisma.ChallengeDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengePayload>;
				};
				update: {
					args: Prisma.ChallengeUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengePayload>;
				};
				deleteMany: {
					args: Prisma.ChallengeDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.ChallengeUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.ChallengeUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengePayload>[];
				};
				upsert: {
					args: Prisma.ChallengeUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengePayload>;
				};
				aggregate: {
					args: Prisma.ChallengeAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateChallenge>;
				};
				groupBy: {
					args: Prisma.ChallengeGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.ChallengeGroupByOutputType>[];
				};
				count: {
					args: Prisma.ChallengeCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.ChallengeCountAggregateOutputType>
						| number;
				};
			};
		};
		UserModuleProgress: {
			payload: Prisma.$UserModuleProgressPayload<ExtArgs>;
			fields: Prisma.UserModuleProgressFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.UserModuleProgressFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserModuleProgressPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.UserModuleProgressFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserModuleProgressPayload>;
				};
				findFirst: {
					args: Prisma.UserModuleProgressFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserModuleProgressPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.UserModuleProgressFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserModuleProgressPayload>;
				};
				findMany: {
					args: Prisma.UserModuleProgressFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserModuleProgressPayload>[];
				};
				create: {
					args: Prisma.UserModuleProgressCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserModuleProgressPayload>;
				};
				createMany: {
					args: Prisma.UserModuleProgressCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.UserModuleProgressCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserModuleProgressPayload>[];
				};
				delete: {
					args: Prisma.UserModuleProgressDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserModuleProgressPayload>;
				};
				update: {
					args: Prisma.UserModuleProgressUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserModuleProgressPayload>;
				};
				deleteMany: {
					args: Prisma.UserModuleProgressDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.UserModuleProgressUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.UserModuleProgressUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserModuleProgressPayload>[];
				};
				upsert: {
					args: Prisma.UserModuleProgressUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserModuleProgressPayload>;
				};
				aggregate: {
					args: Prisma.UserModuleProgressAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateUserModuleProgress>;
				};
				groupBy: {
					args: Prisma.UserModuleProgressGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.UserModuleProgressGroupByOutputType>[];
				};
				count: {
					args: Prisma.UserModuleProgressCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.UserModuleProgressCountAggregateOutputType>
						| number;
				};
			};
		};
		UserChallengeProgress: {
			payload: Prisma.$UserChallengeProgressPayload<ExtArgs>;
			fields: Prisma.UserChallengeProgressFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.UserChallengeProgressFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserChallengeProgressPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.UserChallengeProgressFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserChallengeProgressPayload>;
				};
				findFirst: {
					args: Prisma.UserChallengeProgressFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserChallengeProgressPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.UserChallengeProgressFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserChallengeProgressPayload>;
				};
				findMany: {
					args: Prisma.UserChallengeProgressFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserChallengeProgressPayload>[];
				};
				create: {
					args: Prisma.UserChallengeProgressCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserChallengeProgressPayload>;
				};
				createMany: {
					args: Prisma.UserChallengeProgressCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.UserChallengeProgressCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserChallengeProgressPayload>[];
				};
				delete: {
					args: Prisma.UserChallengeProgressDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserChallengeProgressPayload>;
				};
				update: {
					args: Prisma.UserChallengeProgressUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserChallengeProgressPayload>;
				};
				deleteMany: {
					args: Prisma.UserChallengeProgressDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.UserChallengeProgressUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.UserChallengeProgressUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserChallengeProgressPayload>[];
				};
				upsert: {
					args: Prisma.UserChallengeProgressUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserChallengeProgressPayload>;
				};
				aggregate: {
					args: Prisma.UserChallengeProgressAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateUserChallengeProgress>;
				};
				groupBy: {
					args: Prisma.UserChallengeProgressGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.UserChallengeProgressGroupByOutputType>[];
				};
				count: {
					args: Prisma.UserChallengeProgressCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.UserChallengeProgressCountAggregateOutputType>
						| number;
				};
			};
		};
		CollaborativeChallenge: {
			payload: Prisma.$CollaborativeChallengePayload<ExtArgs>;
			fields: Prisma.CollaborativeChallengeFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.CollaborativeChallengeFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CollaborativeChallengePayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.CollaborativeChallengeFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CollaborativeChallengePayload>;
				};
				findFirst: {
					args: Prisma.CollaborativeChallengeFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CollaborativeChallengePayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.CollaborativeChallengeFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CollaborativeChallengePayload>;
				};
				findMany: {
					args: Prisma.CollaborativeChallengeFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CollaborativeChallengePayload>[];
				};
				create: {
					args: Prisma.CollaborativeChallengeCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CollaborativeChallengePayload>;
				};
				createMany: {
					args: Prisma.CollaborativeChallengeCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.CollaborativeChallengeCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CollaborativeChallengePayload>[];
				};
				delete: {
					args: Prisma.CollaborativeChallengeDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CollaborativeChallengePayload>;
				};
				update: {
					args: Prisma.CollaborativeChallengeUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CollaborativeChallengePayload>;
				};
				deleteMany: {
					args: Prisma.CollaborativeChallengeDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.CollaborativeChallengeUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.CollaborativeChallengeUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CollaborativeChallengePayload>[];
				};
				upsert: {
					args: Prisma.CollaborativeChallengeUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CollaborativeChallengePayload>;
				};
				aggregate: {
					args: Prisma.CollaborativeChallengeAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateCollaborativeChallenge>;
				};
				groupBy: {
					args: Prisma.CollaborativeChallengeGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.CollaborativeChallengeGroupByOutputType>[];
				};
				count: {
					args: Prisma.CollaborativeChallengeCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.CollaborativeChallengeCountAggregateOutputType>
						| number;
				};
			};
		};
		UserRecommendation: {
			payload: Prisma.$UserRecommendationPayload<ExtArgs>;
			fields: Prisma.UserRecommendationFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.UserRecommendationFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRecommendationPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.UserRecommendationFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRecommendationPayload>;
				};
				findFirst: {
					args: Prisma.UserRecommendationFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRecommendationPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.UserRecommendationFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRecommendationPayload>;
				};
				findMany: {
					args: Prisma.UserRecommendationFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRecommendationPayload>[];
				};
				create: {
					args: Prisma.UserRecommendationCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRecommendationPayload>;
				};
				createMany: {
					args: Prisma.UserRecommendationCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.UserRecommendationCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRecommendationPayload>[];
				};
				delete: {
					args: Prisma.UserRecommendationDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRecommendationPayload>;
				};
				update: {
					args: Prisma.UserRecommendationUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRecommendationPayload>;
				};
				deleteMany: {
					args: Prisma.UserRecommendationDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.UserRecommendationUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.UserRecommendationUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRecommendationPayload>[];
				};
				upsert: {
					args: Prisma.UserRecommendationUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRecommendationPayload>;
				};
				aggregate: {
					args: Prisma.UserRecommendationAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateUserRecommendation>;
				};
				groupBy: {
					args: Prisma.UserRecommendationGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.UserRecommendationGroupByOutputType>[];
				};
				count: {
					args: Prisma.UserRecommendationCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.UserRecommendationCountAggregateOutputType>
						| number;
				};
			};
		};
		MaturityLevelDefinition: {
			payload: Prisma.$MaturityLevelDefinitionPayload<ExtArgs>;
			fields: Prisma.MaturityLevelDefinitionFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.MaturityLevelDefinitionFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$MaturityLevelDefinitionPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.MaturityLevelDefinitionFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$MaturityLevelDefinitionPayload>;
				};
				findFirst: {
					args: Prisma.MaturityLevelDefinitionFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$MaturityLevelDefinitionPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.MaturityLevelDefinitionFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$MaturityLevelDefinitionPayload>;
				};
				findMany: {
					args: Prisma.MaturityLevelDefinitionFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$MaturityLevelDefinitionPayload>[];
				};
				create: {
					args: Prisma.MaturityLevelDefinitionCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$MaturityLevelDefinitionPayload>;
				};
				createMany: {
					args: Prisma.MaturityLevelDefinitionCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.MaturityLevelDefinitionCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$MaturityLevelDefinitionPayload>[];
				};
				delete: {
					args: Prisma.MaturityLevelDefinitionDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$MaturityLevelDefinitionPayload>;
				};
				update: {
					args: Prisma.MaturityLevelDefinitionUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$MaturityLevelDefinitionPayload>;
				};
				deleteMany: {
					args: Prisma.MaturityLevelDefinitionDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.MaturityLevelDefinitionUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.MaturityLevelDefinitionUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$MaturityLevelDefinitionPayload>[];
				};
				upsert: {
					args: Prisma.MaturityLevelDefinitionUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$MaturityLevelDefinitionPayload>;
				};
				aggregate: {
					args: Prisma.MaturityLevelDefinitionAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateMaturityLevelDefinition>;
				};
				groupBy: {
					args: Prisma.MaturityLevelDefinitionGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.MaturityLevelDefinitionGroupByOutputType>[];
				};
				count: {
					args: Prisma.MaturityLevelDefinitionCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.MaturityLevelDefinitionCountAggregateOutputType>
						| number;
				};
			};
		};
		StrengthMaturityLevel: {
			payload: Prisma.$StrengthMaturityLevelPayload<ExtArgs>;
			fields: Prisma.StrengthMaturityLevelFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.StrengthMaturityLevelFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthMaturityLevelPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.StrengthMaturityLevelFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthMaturityLevelPayload>;
				};
				findFirst: {
					args: Prisma.StrengthMaturityLevelFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthMaturityLevelPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.StrengthMaturityLevelFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthMaturityLevelPayload>;
				};
				findMany: {
					args: Prisma.StrengthMaturityLevelFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthMaturityLevelPayload>[];
				};
				create: {
					args: Prisma.StrengthMaturityLevelCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthMaturityLevelPayload>;
				};
				createMany: {
					args: Prisma.StrengthMaturityLevelCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.StrengthMaturityLevelCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthMaturityLevelPayload>[];
				};
				delete: {
					args: Prisma.StrengthMaturityLevelDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthMaturityLevelPayload>;
				};
				update: {
					args: Prisma.StrengthMaturityLevelUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthMaturityLevelPayload>;
				};
				deleteMany: {
					args: Prisma.StrengthMaturityLevelDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.StrengthMaturityLevelUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.StrengthMaturityLevelUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthMaturityLevelPayload>[];
				};
				upsert: {
					args: Prisma.StrengthMaturityLevelUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrengthMaturityLevelPayload>;
				};
				aggregate: {
					args: Prisma.StrengthMaturityLevelAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateStrengthMaturityLevel>;
				};
				groupBy: {
					args: Prisma.StrengthMaturityLevelGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.StrengthMaturityLevelGroupByOutputType>[];
				};
				count: {
					args: Prisma.StrengthMaturityLevelCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.StrengthMaturityLevelCountAggregateOutputType>
						| number;
				};
			};
		};
		ComboBreaker: {
			payload: Prisma.$ComboBreakerPayload<ExtArgs>;
			fields: Prisma.ComboBreakerFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.ComboBreakerFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ComboBreakerPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.ComboBreakerFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ComboBreakerPayload>;
				};
				findFirst: {
					args: Prisma.ComboBreakerFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ComboBreakerPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.ComboBreakerFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ComboBreakerPayload>;
				};
				findMany: {
					args: Prisma.ComboBreakerFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ComboBreakerPayload>[];
				};
				create: {
					args: Prisma.ComboBreakerCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ComboBreakerPayload>;
				};
				createMany: {
					args: Prisma.ComboBreakerCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.ComboBreakerCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ComboBreakerPayload>[];
				};
				delete: {
					args: Prisma.ComboBreakerDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ComboBreakerPayload>;
				};
				update: {
					args: Prisma.ComboBreakerUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ComboBreakerPayload>;
				};
				deleteMany: {
					args: Prisma.ComboBreakerDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.ComboBreakerUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.ComboBreakerUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ComboBreakerPayload>[];
				};
				upsert: {
					args: Prisma.ComboBreakerUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ComboBreakerPayload>;
				};
				aggregate: {
					args: Prisma.ComboBreakerAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateComboBreaker>;
				};
				groupBy: {
					args: Prisma.ComboBreakerGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.ComboBreakerGroupByOutputType>[];
				};
				count: {
					args: Prisma.ComboBreakerCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.ComboBreakerCountAggregateOutputType>
						| number;
				};
			};
		};
		ComboStrength: {
			payload: Prisma.$ComboStrengthPayload<ExtArgs>;
			fields: Prisma.ComboStrengthFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.ComboStrengthFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ComboStrengthPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.ComboStrengthFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ComboStrengthPayload>;
				};
				findFirst: {
					args: Prisma.ComboStrengthFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ComboStrengthPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.ComboStrengthFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ComboStrengthPayload>;
				};
				findMany: {
					args: Prisma.ComboStrengthFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ComboStrengthPayload>[];
				};
				create: {
					args: Prisma.ComboStrengthCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ComboStrengthPayload>;
				};
				createMany: {
					args: Prisma.ComboStrengthCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.ComboStrengthCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ComboStrengthPayload>[];
				};
				delete: {
					args: Prisma.ComboStrengthDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ComboStrengthPayload>;
				};
				update: {
					args: Prisma.ComboStrengthUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ComboStrengthPayload>;
				};
				deleteMany: {
					args: Prisma.ComboStrengthDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.ComboStrengthUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.ComboStrengthUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ComboStrengthPayload>[];
				};
				upsert: {
					args: Prisma.ComboStrengthUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ComboStrengthPayload>;
				};
				aggregate: {
					args: Prisma.ComboStrengthAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateComboStrength>;
				};
				groupBy: {
					args: Prisma.ComboStrengthGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.ComboStrengthGroupByOutputType>[];
				};
				count: {
					args: Prisma.ComboStrengthCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.ComboStrengthCountAggregateOutputType>
						| number;
				};
			};
		};
		Quest: {
			payload: Prisma.$QuestPayload<ExtArgs>;
			fields: Prisma.QuestFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.QuestFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.QuestFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestPayload>;
				};
				findFirst: {
					args: Prisma.QuestFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.QuestFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestPayload>;
				};
				findMany: {
					args: Prisma.QuestFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestPayload>[];
				};
				create: {
					args: Prisma.QuestCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestPayload>;
				};
				createMany: {
					args: Prisma.QuestCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.QuestCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestPayload>[];
				};
				delete: {
					args: Prisma.QuestDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestPayload>;
				};
				update: {
					args: Prisma.QuestUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestPayload>;
				};
				deleteMany: {
					args: Prisma.QuestDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.QuestUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.QuestUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestPayload>[];
				};
				upsert: {
					args: Prisma.QuestUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestPayload>;
				};
				aggregate: {
					args: Prisma.QuestAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateQuest>;
				};
				groupBy: {
					args: Prisma.QuestGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.QuestGroupByOutputType>[];
				};
				count: {
					args: Prisma.QuestCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.QuestCountAggregateOutputType>
						| number;
				};
			};
		};
		QuestCompletion: {
			payload: Prisma.$QuestCompletionPayload<ExtArgs>;
			fields: Prisma.QuestCompletionFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.QuestCompletionFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestCompletionPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.QuestCompletionFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestCompletionPayload>;
				};
				findFirst: {
					args: Prisma.QuestCompletionFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestCompletionPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.QuestCompletionFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestCompletionPayload>;
				};
				findMany: {
					args: Prisma.QuestCompletionFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestCompletionPayload>[];
				};
				create: {
					args: Prisma.QuestCompletionCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestCompletionPayload>;
				};
				createMany: {
					args: Prisma.QuestCompletionCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.QuestCompletionCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestCompletionPayload>[];
				};
				delete: {
					args: Prisma.QuestCompletionDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestCompletionPayload>;
				};
				update: {
					args: Prisma.QuestCompletionUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestCompletionPayload>;
				};
				deleteMany: {
					args: Prisma.QuestCompletionDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.QuestCompletionUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.QuestCompletionUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestCompletionPayload>[];
				};
				upsert: {
					args: Prisma.QuestCompletionUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestCompletionPayload>;
				};
				aggregate: {
					args: Prisma.QuestCompletionAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateQuestCompletion>;
				};
				groupBy: {
					args: Prisma.QuestCompletionGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.QuestCompletionGroupByOutputType>[];
				};
				count: {
					args: Prisma.QuestCompletionCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.QuestCompletionCountAggregateOutputType>
						| number;
				};
			};
		};
	};
} & {
	other: {
		payload: any;
		operations: {
			$executeRaw: {
				args: [query: TemplateStringsArray | Sql, ...values: any[]];
				result: any;
			};
			$executeRawUnsafe: {
				args: [query: string, ...values: any[]];
				result: any;
			};
			$queryRaw: {
				args: [query: TemplateStringsArray | Sql, ...values: any[]];
				result: any;
			};
			$queryRawUnsafe: {
				args: [query: string, ...values: any[]];
				result: any;
			};
		};
	};
};

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
	Serializable: "Serializable",
} as const);

export type TransactionIsolationLevel =
	(typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

export const UserScalarFieldEnum = {
	id: "id",
	name: "name",
	email: "email",
	emailVerified: "emailVerified",
	image: "image",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type UserScalarFieldEnum =
	(typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

export const SessionScalarFieldEnum = {
	id: "id",
	expiresAt: "expiresAt",
	token: "token",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	ipAddress: "ipAddress",
	userAgent: "userAgent",
	userId: "userId",
} as const;

export type SessionScalarFieldEnum =
	(typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum];

export const AccountScalarFieldEnum = {
	id: "id",
	accountId: "accountId",
	providerId: "providerId",
	userId: "userId",
	accessToken: "accessToken",
	refreshToken: "refreshToken",
	idToken: "idToken",
	accessTokenExpiresAt: "accessTokenExpiresAt",
	refreshTokenExpiresAt: "refreshTokenExpiresAt",
	scope: "scope",
	password: "password",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type AccountScalarFieldEnum =
	(typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum];

export const VerificationScalarFieldEnum = {
	id: "id",
	identifier: "identifier",
	value: "value",
	expiresAt: "expiresAt",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type VerificationScalarFieldEnum =
	(typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum];

export const UserProfileScalarFieldEnum = {
	id: "id",
	userId: "userId",
	career: "career",
	age: "age",
	gender: "gender",
	description: "description",
	hobbies: "hobbies",
	profileImageUrl: "profileImageUrl",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type UserProfileScalarFieldEnum =
	(typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum];

export const UserDNAScalarFieldEnum = {
	id: "id",
	userId: "userId",
	title: "title",
	summary: "summary",
	dimensions: "dimensions",
	synergies: "synergies",
	idealRole: "idealRole",
	purpose: "purpose",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type UserDNAScalarFieldEnum =
	(typeof UserDNAScalarFieldEnum)[keyof typeof UserDNAScalarFieldEnum];

export const TeamScalarFieldEnum = {
	id: "id",
	name: "name",
	description: "description",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type TeamScalarFieldEnum =
	(typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum];

export const TeamMemberScalarFieldEnum = {
	id: "id",
	userId: "userId",
	teamId: "teamId",
	role: "role",
	joinedAt: "joinedAt",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type TeamMemberScalarFieldEnum =
	(typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum];

export const DomainScalarFieldEnum = {
	id: "id",
	name: "name",
	nameEs: "nameEs",
	description: "description",
	metaphor: "metaphor",
	keyQuestion: "keyQuestion",
	summary: "summary",
	contributionToTeam: "contributionToTeam",
	potentialPitfall: "potentialPitfall",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type DomainScalarFieldEnum =
	(typeof DomainScalarFieldEnum)[keyof typeof DomainScalarFieldEnum];

export const StrengthScalarFieldEnum = {
	id: "id",
	name: "name",
	nameEs: "nameEs",
	domainId: "domainId",
	briefDefinition: "briefDefinition",
	fullDefinition: "fullDefinition",
	howToUseMoreEffectively: "howToUseMoreEffectively",
	watchOuts: "watchOuts",
	strengthsDynamics: "strengthsDynamics",
	bestPartners: "bestPartners",
	careerApplications: "careerApplications",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type StrengthScalarFieldEnum =
	(typeof StrengthScalarFieldEnum)[keyof typeof StrengthScalarFieldEnum];

export const UserStrengthScalarFieldEnum = {
	id: "id",
	userId: "userId",
	strengthId: "strengthId",
	rank: "rank",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type UserStrengthScalarFieldEnum =
	(typeof UserStrengthScalarFieldEnum)[keyof typeof UserStrengthScalarFieldEnum];

export const FocusScalarFieldEnum = {
	id: "id",
	name: "name",
	nameEs: "nameEs",
	axis: "axis",
	description: "description",
	icon: "icon",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type FocusScalarFieldEnum =
	(typeof FocusScalarFieldEnum)[keyof typeof FocusScalarFieldEnum];

export const DomainFocusScalarFieldEnum = {
	id: "id",
	domainId: "domainId",
	focusId: "focusId",
	weight: "weight",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type DomainFocusScalarFieldEnum =
	(typeof DomainFocusScalarFieldEnum)[keyof typeof DomainFocusScalarFieldEnum];

export const CultureScalarFieldEnum = {
	id: "id",
	name: "name",
	nameEs: "nameEs",
	subtitle: "subtitle",
	description: "description",
	focusEnergyId: "focusEnergyId",
	focusOrientationId: "focusOrientationId",
	attributes: "attributes",
	icon: "icon",
	color: "color",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type CultureScalarFieldEnum =
	(typeof CultureScalarFieldEnum)[keyof typeof CultureScalarFieldEnum];

export const ReportScalarFieldEnum = {
	id: "id",
	type: "type",
	status: "status",
	version: "version",
	content: "content",
	error: "error",
	modelUsed: "modelUsed",
	metadata: "metadata",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	userId: "userId",
	teamId: "teamId",
} as const;

export type ReportScalarFieldEnum =
	(typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum];

export const AssessmentQuestionScalarFieldEnum = {
	id: "id",
	phase: "phase",
	order: "order",
	text: "text",
	type: "type",
	options: "options",
	scaleRange: "scaleRange",
	domainId: "domainId",
	strengthId: "strengthId",
	weight: "weight",
	maturityPolarity: "maturityPolarity",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type AssessmentQuestionScalarFieldEnum =
	(typeof AssessmentQuestionScalarFieldEnum)[keyof typeof AssessmentQuestionScalarFieldEnum];

export const UserAssessmentAnswerScalarFieldEnum = {
	id: "id",
	userId: "userId",
	sessionId: "sessionId",
	questionId: "questionId",
	answer: "answer",
	confidence: "confidence",
	answeredAt: "answeredAt",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type UserAssessmentAnswerScalarFieldEnum =
	(typeof UserAssessmentAnswerScalarFieldEnum)[keyof typeof UserAssessmentAnswerScalarFieldEnum];

export const AssessmentSessionScalarFieldEnum = {
	id: "id",
	userId: "userId",
	status: "status",
	phase: "phase",
	currentStep: "currentStep",
	totalSteps: "totalSteps",
	domainScores: "domainScores",
	strengthScores: "strengthScores",
	results: "results",
	startedAt: "startedAt",
	lastActivityAt: "lastActivityAt",
	completedAt: "completedAt",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type AssessmentSessionScalarFieldEnum =
	(typeof AssessmentSessionScalarFieldEnum)[keyof typeof AssessmentSessionScalarFieldEnum];

export const FeedbackRequestScalarFieldEnum = {
	id: "id",
	requesterId: "requesterId",
	respondentId: "respondentId",
	status: "status",
	isAnonymous: "isAnonymous",
	sentAt: "sentAt",
	completedAt: "completedAt",
	expiresAt: "expiresAt",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type FeedbackRequestScalarFieldEnum =
	(typeof FeedbackRequestScalarFieldEnum)[keyof typeof FeedbackRequestScalarFieldEnum];

export const FeedbackQuestionScalarFieldEnum = {
	id: "id",
	text: "text",
	answerType: "answerType",
	answerOptions: "answerOptions",
	strengthMapping: "strengthMapping",
	order: "order",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type FeedbackQuestionScalarFieldEnum =
	(typeof FeedbackQuestionScalarFieldEnum)[keyof typeof FeedbackQuestionScalarFieldEnum];

export const FeedbackResponseScalarFieldEnum = {
	id: "id",
	requestId: "requestId",
	questionId: "questionId",
	answer: "answer",
	anonymousHash: "anonymousHash",
	createdAt: "createdAt",
} as const;

export type FeedbackResponseScalarFieldEnum =
	(typeof FeedbackResponseScalarFieldEnum)[keyof typeof FeedbackResponseScalarFieldEnum];

export const FeedbackSummaryScalarFieldEnum = {
	id: "id",
	userId: "userId",
	totalResponses: "totalResponses",
	lastResponseAt: "lastResponseAt",
	strengthAdjustments: "strengthAdjustments",
	insights: "insights",
	insightsGeneratedAt: "insightsGeneratedAt",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type FeedbackSummaryScalarFieldEnum =
	(typeof FeedbackSummaryScalarFieldEnum)[keyof typeof FeedbackSummaryScalarFieldEnum];

export const StrengthAdjustmentScalarFieldEnum = {
	id: "id",
	userId: "userId",
	strengthId: "strengthId",
	suggestedDelta: "suggestedDelta",
	supportingData: "supportingData",
	status: "status",
	createdAt: "createdAt",
	processedAt: "processedAt",
} as const;

export type StrengthAdjustmentScalarFieldEnum =
	(typeof StrengthAdjustmentScalarFieldEnum)[keyof typeof StrengthAdjustmentScalarFieldEnum];

export const SubTeamScalarFieldEnum = {
	id: "id",
	parentTeamId: "parentTeamId",
	projectTypeProfileId: "projectTypeProfileId",
	name: "name",
	description: "description",
	members: "members",
	matchScore: "matchScore",
	analysis: "analysis",
	status: "status",
	createdBy: "createdBy",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	deletedAt: "deletedAt",
} as const;

export type SubTeamScalarFieldEnum =
	(typeof SubTeamScalarFieldEnum)[keyof typeof SubTeamScalarFieldEnum];

export const ProjectTypeProfileScalarFieldEnum = {
	id: "id",
	type: "type",
	name: "name",
	nameEs: "nameEs",
	idealStrengths: "idealStrengths",
	criticalDomains: "criticalDomains",
	cultureFit: "cultureFit",
	description: "description",
	descriptionEs: "descriptionEs",
	characteristics: "characteristics",
	characteristicsEs: "characteristicsEs",
	icon: "icon",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type ProjectTypeProfileScalarFieldEnum =
	(typeof ProjectTypeProfileScalarFieldEnum)[keyof typeof ProjectTypeProfileScalarFieldEnum];

export const UserGamificationScalarFieldEnum = {
	id: "id",
	userId: "userId",
	xpTotal: "xpTotal",
	currentLevel: "currentLevel",
	currentLevelXp: "currentLevelXp",
	nextLevelXpRequired: "nextLevelXpRequired",
	longestStreak: "longestStreak",
	currentStreak: "currentStreak",
	lastActivityDate: "lastActivityDate",
	modulesCompleted: "modulesCompleted",
	challengesCompleted: "challengesCompleted",
	collaborativeChallenges: "collaborativeChallenges",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type UserGamificationScalarFieldEnum =
	(typeof UserGamificationScalarFieldEnum)[keyof typeof UserGamificationScalarFieldEnum];

export const XpTransactionScalarFieldEnum = {
	id: "id",
	userId: "userId",
	amount: "amount",
	source: "source",
	sourceId: "sourceId",
	streakBonus: "streakBonus",
	metadata: "metadata",
	createdAt: "createdAt",
} as const;

export type XpTransactionScalarFieldEnum =
	(typeof XpTransactionScalarFieldEnum)[keyof typeof XpTransactionScalarFieldEnum];

export const BadgeScalarFieldEnum = {
	id: "id",
	key: "key",
	nameEs: "nameEs",
	descriptionEs: "descriptionEs",
	iconUrl: "iconUrl",
	tier: "tier",
	unlockCriteria: "unlockCriteria",
	xpReward: "xpReward",
	isActive: "isActive",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type BadgeScalarFieldEnum =
	(typeof BadgeScalarFieldEnum)[keyof typeof BadgeScalarFieldEnum];

export const UserBadgeScalarFieldEnum = {
	id: "id",
	gamificationId: "gamificationId",
	badgeId: "badgeId",
	unlockedAt: "unlockedAt",
} as const;

export type UserBadgeScalarFieldEnum =
	(typeof UserBadgeScalarFieldEnum)[keyof typeof UserBadgeScalarFieldEnum];

export const UserProfessionalProfileScalarFieldEnum = {
	id: "id",
	userId: "userId",
	roleStatus: "roleStatus",
	currentRole: "currentRole",
	industryContext: "industryContext",
	careerGoals: "careerGoals",
	completedAt: "completedAt",
	skippedAt: "skippedAt",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type UserProfessionalProfileScalarFieldEnum =
	(typeof UserProfessionalProfileScalarFieldEnum)[keyof typeof UserProfessionalProfileScalarFieldEnum];

export const DevelopmentModuleScalarFieldEnum = {
	id: "id",
	key: "key",
	titleEs: "titleEs",
	descriptionEs: "descriptionEs",
	content: "content",
	estimatedMinutes: "estimatedMinutes",
	xpReward: "xpReward",
	level: "level",
	strengthKey: "strengthKey",
	domainKey: "domainKey",
	order: "order",
	isActive: "isActive",
	moduleType: "moduleType",
	userId: "userId",
	isArchived: "isArchived",
	generatedBy: "generatedBy",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type DevelopmentModuleScalarFieldEnum =
	(typeof DevelopmentModuleScalarFieldEnum)[keyof typeof DevelopmentModuleScalarFieldEnum];

export const ChallengeScalarFieldEnum = {
	id: "id",
	moduleId: "moduleId",
	titleEs: "titleEs",
	descriptionEs: "descriptionEs",
	type: "type",
	xpReward: "xpReward",
	order: "order",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type ChallengeScalarFieldEnum =
	(typeof ChallengeScalarFieldEnum)[keyof typeof ChallengeScalarFieldEnum];

export const UserModuleProgressScalarFieldEnum = {
	id: "id",
	userId: "userId",
	moduleId: "moduleId",
	status: "status",
	completedChallenges: "completedChallenges",
	totalChallenges: "totalChallenges",
	moduleXpEarned: "moduleXpEarned",
	startedAt: "startedAt",
	completedAt: "completedAt",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type UserModuleProgressScalarFieldEnum =
	(typeof UserModuleProgressScalarFieldEnum)[keyof typeof UserModuleProgressScalarFieldEnum];

export const UserChallengeProgressScalarFieldEnum = {
	id: "id",
	userId: "userId",
	challengeId: "challengeId",
	completed: "completed",
	xpAwarded: "xpAwarded",
	completedAt: "completedAt",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type UserChallengeProgressScalarFieldEnum =
	(typeof UserChallengeProgressScalarFieldEnum)[keyof typeof UserChallengeProgressScalarFieldEnum];

export const CollaborativeChallengeScalarFieldEnum = {
	id: "id",
	challengeId: "challengeId",
	initiatorUserId: "initiatorUserId",
	partnerUserId: "partnerUserId",
	initiatorCompleted: "initiatorCompleted",
	partnerCompleted: "partnerCompleted",
	initiatorCompletedAt: "initiatorCompletedAt",
	partnerCompletedAt: "partnerCompletedAt",
	xpBonusAwarded: "xpBonusAwarded",
	status: "status",
	expiresAt: "expiresAt",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type CollaborativeChallengeScalarFieldEnum =
	(typeof CollaborativeChallengeScalarFieldEnum)[keyof typeof CollaborativeChallengeScalarFieldEnum];

export const UserRecommendationScalarFieldEnum = {
	id: "id",
	userId: "userId",
	recommendationType: "recommendationType",
	recommendations: "recommendations",
	strengthsHash: "strengthsHash",
	modelUsed: "modelUsed",
	expiresAt: "expiresAt",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type UserRecommendationScalarFieldEnum =
	(typeof UserRecommendationScalarFieldEnum)[keyof typeof UserRecommendationScalarFieldEnum];

export const MaturityLevelDefinitionScalarFieldEnum = {
	id: "id",
	level: "level",
	name: "name",
	description: "description",
	minXp: "minXp",
	maxXp: "maxXp",
	color: "color",
	icon: "icon",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type MaturityLevelDefinitionScalarFieldEnum =
	(typeof MaturityLevelDefinitionScalarFieldEnum)[keyof typeof MaturityLevelDefinitionScalarFieldEnum];

export const StrengthMaturityLevelScalarFieldEnum = {
	id: "id",
	userId: "userId",
	strengthId: "strengthId",
	currentXp: "currentXp",
	currentLevel: "currentLevel",
	lastXpGain: "lastXpGain",
	lastLevelUp: "lastLevelUp",
	totalXpEarned: "totalXpEarned",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type StrengthMaturityLevelScalarFieldEnum =
	(typeof StrengthMaturityLevelScalarFieldEnum)[keyof typeof StrengthMaturityLevelScalarFieldEnum];

export const ComboBreakerScalarFieldEnum = {
	id: "id",
	name: "name",
	description: "description",
	requiredCount: "requiredCount",
	xpReward: "xpReward",
	cooldownHours: "cooldownHours",
	icon: "icon",
	isActive: "isActive",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type ComboBreakerScalarFieldEnum =
	(typeof ComboBreakerScalarFieldEnum)[keyof typeof ComboBreakerScalarFieldEnum];

export const ComboStrengthScalarFieldEnum = {
	id: "id",
	comboBreakerId: "comboBreakerId",
	strengthId: "strengthId",
	createdAt: "createdAt",
} as const;

export type ComboStrengthScalarFieldEnum =
	(typeof ComboStrengthScalarFieldEnum)[keyof typeof ComboStrengthScalarFieldEnum];

export const QuestScalarFieldEnum = {
	id: "id",
	type: "type",
	strengthId: "strengthId",
	title: "title",
	description: "description",
	xpReward: "xpReward",
	difficulty: "difficulty",
	cooldownHours: "cooldownHours",
	requiresPartner: "requiresPartner",
	icon: "icon",
	isActive: "isActive",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type QuestScalarFieldEnum =
	(typeof QuestScalarFieldEnum)[keyof typeof QuestScalarFieldEnum];

export const QuestCompletionScalarFieldEnum = {
	id: "id",
	userId: "userId",
	questId: "questId",
	status: "status",
	startedAt: "startedAt",
	completedAt: "completedAt",
	expiresAt: "expiresAt",
	xpAwarded: "xpAwarded",
	partnerId: "partnerId",
	confirmedAt: "confirmedAt",
	confirmedBy: "confirmedBy",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
} as const;

export type QuestCompletionScalarFieldEnum =
	(typeof QuestCompletionScalarFieldEnum)[keyof typeof QuestCompletionScalarFieldEnum];

export const SortOrder = {
	asc: "asc",
	desc: "desc",
} as const;

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

export const NullsOrder = {
	first: "first",
	last: "last",
} as const;

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

/**
 * Field references
 */

/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"String"
>;

/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"Boolean"
>;

/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"DateTime"
>;

/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"Int"
>;

/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"Float"
>;

/**
 * Reference to a field of type 'ReportType'
 */
export type EnumReportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"ReportType"
>;

/**
 * Reference to a field of type 'ReportStatus'
 */
export type EnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"ReportStatus"
>;

/**
 * Reference to a field of type 'QuestionType'
 */
export type EnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"QuestionType"
>;

/**
 * Reference to a field of type 'MaturityPolarity'
 */
export type EnumMaturityPolarityFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"MaturityPolarity"
>;

/**
 * Reference to a field of type 'SessionStatus'
 */
export type EnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"SessionStatus"
>;

/**
 * Reference to a field of type 'FeedbackRequestStatus'
 */
export type EnumFeedbackRequestStatusFieldRefInput<$PrismaModel> =
	FieldRefInputType<$PrismaModel, "FeedbackRequestStatus">;

/**
 * Reference to a field of type 'StrengthAdjustmentStatus'
 */
export type EnumStrengthAdjustmentStatusFieldRefInput<$PrismaModel> =
	FieldRefInputType<$PrismaModel, "StrengthAdjustmentStatus">;

/**
 * Reference to a field of type 'MaturityLevel'
 */
export type EnumMaturityLevelFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"MaturityLevel"
>;

/**
 * Reference to a field of type 'QuestType'
 */
export type EnumQuestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"QuestType"
>;

/**
 * Reference to a field of type 'QuestStatus'
 */
export type EnumQuestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"QuestStatus"
>;

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
	count: number;
};

export const defineExtension = runtime.Extensions
	.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<
	"define",
	TypeMapCb,
	runtime.Types.Extensions.DefaultArgs
>;
export type DefaultPrismaClient = PrismaClient;
export type ErrorFormat = "pretty" | "colorless" | "minimal";
export type PrismaClientOptions = (
	| {
			/**
			 * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
			 */
			adapter: runtime.SqlDriverAdapterFactory;
			accelerateUrl?: never;
	  }
	| {
			/**
			 * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
			 */
			accelerateUrl: string;
			adapter?: never;
	  }
) & {
	/**
	 * @default "colorless"
	 */
	errorFormat?: ErrorFormat;
	/**
	 * @example
	 * ```
	 * // Shorthand for `emit: 'stdout'`
	 * log: ['query', 'info', 'warn', 'error']
	 *
	 * // Emit as events only
	 * log: [
	 *   { emit: 'event', level: 'query' },
	 *   { emit: 'event', level: 'info' },
	 *   { emit: 'event', level: 'warn' }
	 *   { emit: 'event', level: 'error' }
	 * ]
	 *
	 * / Emit as events and log to stdout
	 * og: [
	 *  { emit: 'stdout', level: 'query' },
	 *  { emit: 'stdout', level: 'info' },
	 *  { emit: 'stdout', level: 'warn' }
	 *  { emit: 'stdout', level: 'error' }
	 *
	 * ```
	 * Read more in our [docs](https://pris.ly/d/logging).
	 */
	log?: (LogLevel | LogDefinition)[];
	/**
	 * The default values for transactionOptions
	 * maxWait ?= 2000
	 * timeout ?= 5000
	 */
	transactionOptions?: {
		maxWait?: number;
		timeout?: number;
		isolationLevel?: TransactionIsolationLevel;
	};
	/**
	 * Global configuration for omitting model fields by default.
	 *
	 * @example
	 * ```
	 * const prisma = new PrismaClient({
	 *   omit: {
	 *     user: {
	 *       password: true
	 *     }
	 *   }
	 * })
	 * ```
	 */
	omit?: GlobalOmitConfig;
	/**
	 * SQL commenter plugins that add metadata to SQL queries as comments.
	 * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
	 *
	 * @example
	 * ```
	 * const prisma = new PrismaClient({
	 *   adapter,
	 *   comments: [
	 *     traceContext(),
	 *     queryInsights(),
	 *   ],
	 * })
	 * ```
	 */
	comments?: runtime.SqlCommenterPlugin[];
};
export type GlobalOmitConfig = {
	user?: Prisma.UserOmit;
	session?: Prisma.SessionOmit;
	account?: Prisma.AccountOmit;
	verification?: Prisma.VerificationOmit;
	userProfile?: Prisma.UserProfileOmit;
	userDNA?: Prisma.UserDNAOmit;
	team?: Prisma.TeamOmit;
	teamMember?: Prisma.TeamMemberOmit;
	domain?: Prisma.DomainOmit;
	strength?: Prisma.StrengthOmit;
	userStrength?: Prisma.UserStrengthOmit;
	focus?: Prisma.FocusOmit;
	domainFocus?: Prisma.DomainFocusOmit;
	culture?: Prisma.CultureOmit;
	report?: Prisma.ReportOmit;
	assessmentQuestion?: Prisma.AssessmentQuestionOmit;
	userAssessmentAnswer?: Prisma.UserAssessmentAnswerOmit;
	assessmentSession?: Prisma.AssessmentSessionOmit;
	feedbackRequest?: Prisma.FeedbackRequestOmit;
	feedbackQuestion?: Prisma.FeedbackQuestionOmit;
	feedbackResponse?: Prisma.FeedbackResponseOmit;
	feedbackSummary?: Prisma.FeedbackSummaryOmit;
	strengthAdjustment?: Prisma.StrengthAdjustmentOmit;
	subTeam?: Prisma.SubTeamOmit;
	projectTypeProfile?: Prisma.ProjectTypeProfileOmit;
	userGamification?: Prisma.UserGamificationOmit;
	xpTransaction?: Prisma.XpTransactionOmit;
	badge?: Prisma.BadgeOmit;
	userBadge?: Prisma.UserBadgeOmit;
	userProfessionalProfile?: Prisma.UserProfessionalProfileOmit;
	developmentModule?: Prisma.DevelopmentModuleOmit;
	challenge?: Prisma.ChallengeOmit;
	userModuleProgress?: Prisma.UserModuleProgressOmit;
	userChallengeProgress?: Prisma.UserChallengeProgressOmit;
	collaborativeChallenge?: Prisma.CollaborativeChallengeOmit;
	userRecommendation?: Prisma.UserRecommendationOmit;
	maturityLevelDefinition?: Prisma.MaturityLevelDefinitionOmit;
	strengthMaturityLevel?: Prisma.StrengthMaturityLevelOmit;
	comboBreaker?: Prisma.ComboBreakerOmit;
	comboStrength?: Prisma.ComboStrengthOmit;
	quest?: Prisma.QuestOmit;
	questCompletion?: Prisma.QuestCompletionOmit;
};

/* Types for Logging */
export type LogLevel = "info" | "query" | "warn" | "error";
export type LogDefinition = {
	level: LogLevel;
	emit: "stdout" | "event";
};

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
	T extends LogDefinition ? T["level"] : T
>;

export type GetEvents<T extends any[]> =
	T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;

export type QueryEvent = {
	timestamp: Date;
	query: string;
	params: string;
	duration: number;
	target: string;
};

export type LogEvent = {
	timestamp: Date;
	message: string;
	target: string;
};
/* End Types for Logging */

export type PrismaAction =
	| "findUnique"
	| "findUniqueOrThrow"
	| "findMany"
	| "findFirst"
	| "findFirstOrThrow"
	| "create"
	| "createMany"
	| "createManyAndReturn"
	| "update"
	| "updateMany"
	| "updateManyAndReturn"
	| "upsert"
	| "delete"
	| "deleteMany"
	| "executeRaw"
	| "queryRaw"
	| "aggregate"
	| "count"
	| "runCommandRaw"
	| "findRaw"
	| "groupBy";

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<
	DefaultPrismaClient,
	runtime.ITXClientDenyList
>;
